diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0d65b57b..8d4646d7 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -224,7 +224,10 @@ if(CMAKE_COMPILER_IS_CLANG)
 endif(CMAKE_COMPILER_IS_CLANG)
 
 if(CMAKE_COMPILER_IS_IAR)
-    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} --warn_about_c_style_casts --warnings_are_errors -Ohz")
+    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} --warn_about_c_style_casts")
+    set(CMAKE_C_FLAGS_RELEASE     "-Ohz")
+    set(CMAKE_C_FLAGS_DEBUG       "--debug -On")
+    set(CMAKE_C_FLAGS_CHECK       "--warnings_are_errors")
 endif(CMAKE_COMPILER_IS_IAR)
 
 if(CMAKE_COMPILER_IS_MSVC)
diff --git a/ChangeLog.d/LMS.txt b/ChangeLog.d/LMS.txt
new file mode 100644
index 00000000..0f09f018
--- /dev/null
+++ b/ChangeLog.d/LMS.txt
@@ -0,0 +1,12 @@
+Features
+    * Add the LMS post-quantum-safe stateful-hash asymmetric signature scheme
+      as defined in RFC8554 and NIST.SP.200-208. This currently only supports
+      one parameter set (LMS_SHA256_M32_H10), meaning that each private key can
+      be used to sign 1024 messages. As such, it is not intended for use in TLS,
+      but instead for verification of assets transmitted over an insecure
+      channel, particularly firmware images. This is one of the signature
+      schemes recommended by the IETF draft SUIT standard for IOT firmware
+      upgrades (RFC9019).
+    * Add the LM-OTS post-quantum-safe one-time signature scheme, which is
+      required for LMS. This can be used independently, but each key can only be
+      used to sign one message so is impractical for most circumstances.
diff --git a/include/mbedtls/check_config.h b/include/mbedtls/check_config.h
index 5fe98498..5bafe291 100644
--- a/include/mbedtls/check_config.h
+++ b/include/mbedtls/check_config.h
@@ -141,6 +141,7 @@
     !defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) &&                  \
     !defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED) &&                  \
     !defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED) &&                 \
+    !defined(MBEDTLS_ECP_DP_CURVE_SM2_ENABLED) &&                 \
     !defined(MBEDTLS_ECP_DP_CURVE448_ENABLED) ) )
 #error "MBEDTLS_ECP_C defined, but not all prerequisites"
 #endif
@@ -333,6 +334,16 @@
 #error "!MBEDTLS_SSL_KEEP_PEER_CERTIFICATE requires MBEDTLS_SHA512_C, MBEDTLS_SHA256_C or MBEDTLS_SHA1_C"
 #endif
 
+#if defined(MBEDTLS_LMOTS_C) &&                                       \
+    ( !defined(MBEDTLS_MD_C) )
+#error "MBEDTLS_LMOTS_C requires MBEDTLS_MD_C"
+#endif
+
+#if defined(MBEDTLS_LMS_C) &&                                          \
+    ( !defined(MBEDTLS_LMOTS_C) || !defined(MBEDTLS_MD_C) )
+#error "MBEDTLS_LMS_C requires MBEDTLS_LMOTS_C and MBEDTLS_MD_C"
+#endif
+
 #if defined(MBEDTLS_MEMORY_BUFFER_ALLOC_C) &&                          \
     ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
 #error "MBEDTLS_MEMORY_BUFFER_ALLOC_C defined, but not all prerequisites"
diff --git a/include/mbedtls/cipher.h b/include/mbedtls/cipher.h
index a3f52ea7..bf8ffd68 100644
--- a/include/mbedtls/cipher.h
+++ b/include/mbedtls/cipher.h
@@ -89,6 +89,7 @@ typedef enum {
     MBEDTLS_CIPHER_ID_CAMELLIA,  /**< The Camellia cipher. */
     MBEDTLS_CIPHER_ID_ARIA,      /**< The Aria cipher. */
     MBEDTLS_CIPHER_ID_CHACHA20,  /**< The ChaCha20 cipher. */
+    MBEDTLS_CIPHER_ID_SM4,
 } mbedtls_cipher_id_t;
 
 /**
@@ -137,6 +138,7 @@ typedef enum {
     MBEDTLS_CIPHER_DES_EDE_CBC,          /**< DES cipher with EDE CBC mode. */
     MBEDTLS_CIPHER_DES_EDE3_ECB,         /**< DES cipher with EDE3 ECB mode. */
     MBEDTLS_CIPHER_DES_EDE3_CBC,         /**< DES cipher with EDE3 CBC mode. */
+    MBEDTLS_CIPHER_DES_EDE3_CTR,
     MBEDTLS_CIPHER_AES_128_CCM,          /**< AES cipher with 128-bit CCM mode. */
     MBEDTLS_CIPHER_AES_192_CCM,          /**< AES cipher with 192-bit CCM mode. */
     MBEDTLS_CIPHER_AES_256_CCM,          /**< AES cipher with 256-bit CCM mode. */
@@ -183,6 +185,9 @@ typedef enum {
     MBEDTLS_CIPHER_AES_128_KWP,          /**< AES cipher with 128-bit NIST KWP mode. */
     MBEDTLS_CIPHER_AES_192_KWP,          /**< AES cipher with 192-bit NIST KWP mode. */
     MBEDTLS_CIPHER_AES_256_KWP,          /**< AES cipher with 256-bit NIST KWP mode. */
+    MBEDTLS_CIPHER_SM4_ECB,
+    MBEDTLS_CIPHER_SM4_CBC,
+    MBEDTLS_CIPHER_SM4_CTR,
 } mbedtls_cipher_type_t;
 
 /** Supported cipher modes. */
diff --git a/include/mbedtls/config_psa.h b/include/mbedtls/config_psa.h
index 2a6672e1..0e742de6 100644
--- a/include/mbedtls/config_psa.h
+++ b/include/mbedtls/config_psa.h
@@ -194,6 +194,11 @@ extern "C" {
 #endif /* !MBEDTLS_PSA_ACCEL_ALG_RSA_PSS */
 #endif /* PSA_WANT_ALG_RSA_PSS */
 
+#if defined(PSA_WANT_ALG_SM3) && !defined(MBEDTLS_PSA_ACCEL_ALG_SHA_1)
+#define MBEDTLS_PSA_BUILTIN_ALG_SM3 1
+#define MBEDTLS_SM3_C
+#endif
+
 #if defined(PSA_WANT_ALG_SHA_1) && !defined(MBEDTLS_PSA_ACCEL_ALG_SHA_1)
 #define MBEDTLS_PSA_BUILTIN_ALG_SHA_1 1
 #define MBEDTLS_SHA1_C
@@ -450,6 +455,8 @@ extern "C" {
 #if !defined(MBEDTLS_PSA_ACCEL_ALG_CHACHA20_POLY1305)
 #if defined(PSA_WANT_KEY_TYPE_CHACHA20)
 #define MBEDTLS_CHACHAPOLY_C
+#define MBEDTLS_CHACHA20_C
+#define MBEDTLS_POLY1305_C
 #define MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305 1
 #endif /* PSA_WANT_KEY_TYPE_CHACHA20 */
 #endif /* !MBEDTLS_PSA_ACCEL_ALG_CHACHA20_POLY1305 */
@@ -551,8 +558,9 @@ extern "C" {
 #endif /* !MBEDTLS_PSA_ACCEL_ECC_SECP_K1_256 */
 #endif /* PSA_WANT_ECC_SECP_K1_256 */
 
-
-
+#if defined(PSA_WANT_SM2_P256)
+#define MBEDTLS_ECP_DP_CURVE_SM2_ENABLED
+#endif
 /****************************************************************/
 /* Infer PSA requirements from Mbed TLS capabilities */
 /****************************************************************/
@@ -661,6 +669,11 @@ extern "C" {
 #define PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY 1
 #endif /* MBEDTLS_RSA_C */
 
+#if defined(MBEDTLS_SM3_C)
+#define MBEDTLS_PSA_BUILTIN_ALG_SM3 1
+#define PSA_WANT_ALG_SM3 1
+#endif
+
 #if defined(MBEDTLS_SHA1_C)
 #define MBEDTLS_PSA_BUILTIN_ALG_SHA_1 1
 #define PSA_WANT_ALG_SHA_1 1
diff --git a/include/mbedtls/ecp.h b/include/mbedtls/ecp.h
index ac8b7c0d..178cc868 100644
--- a/include/mbedtls/ecp.h
+++ b/include/mbedtls/ecp.h
@@ -73,6 +73,7 @@
     defined(MBEDTLS_ECP_DP_BP512R1_ENABLED) || \
     defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) || \
     defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) || \
+    defined(MBEDTLS_ECP_DP_CURVE_SM2_ENABLED) || \
     defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
 #define MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED
 #endif
@@ -126,6 +127,7 @@ typedef enum
     MBEDTLS_ECP_DP_SECP224K1,      /*!< Domain parameters for 224-bit "Koblitz" curve. */
     MBEDTLS_ECP_DP_SECP256K1,      /*!< Domain parameters for 256-bit "Koblitz" curve. */
     MBEDTLS_ECP_DP_CURVE448,       /*!< Domain parameters for Curve448. */
+    MBEDTLS_ECP_DP_CURVE_SM2,
 } mbedtls_ecp_group_id;
 
 /**
@@ -171,9 +173,15 @@ typedef struct mbedtls_ecp_curve_info
  */
 typedef struct mbedtls_ecp_point
 {
+#ifdef PLATFORM_RISCV
+    mbedtls_mpi X;          /*!< The X coordinate of the ECP point. */
+    mbedtls_mpi Y;          /*!< The Y coordinate of the ECP point. */
+    mbedtls_mpi Z;          /*!< The Z coordinate of the ECP point. */
+#else    
     mbedtls_mpi MBEDTLS_PRIVATE(X);          /*!< The X coordinate of the ECP point. */
     mbedtls_mpi MBEDTLS_PRIVATE(Y);          /*!< The Y coordinate of the ECP point. */
     mbedtls_mpi MBEDTLS_PRIVATE(Z);          /*!< The Z coordinate of the ECP point. */
+#endif
 }
 mbedtls_ecp_point;
 
@@ -419,10 +427,16 @@ typedef void mbedtls_ecp_restart_ctx;
  *          ::mbedtls_ecdsa_context structure.
  */
 typedef struct mbedtls_ecp_keypair
-{
+{   
+#ifdef PLATFORM_RISCV
+    mbedtls_ecp_group grp;      /*!<  Elliptic curve and base point     */
+    mbedtls_mpi d;              /*!<  our secret value                  */
+    mbedtls_ecp_point Q;        /*!<  our public value                  */
+#else    
     mbedtls_ecp_group MBEDTLS_PRIVATE(grp);      /*!<  Elliptic curve and base point     */
     mbedtls_mpi MBEDTLS_PRIVATE(d);              /*!<  our secret value                  */
     mbedtls_ecp_point MBEDTLS_PRIVATE(Q);        /*!<  our public value                  */
+#endif
 }
 mbedtls_ecp_keypair;
 
diff --git a/include/mbedtls/error.h b/include/mbedtls/error.h
index 8b2b9ea5..73d61dbc 100644
--- a/include/mbedtls/error.h
+++ b/include/mbedtls/error.h
@@ -82,6 +82,8 @@
  * POLY1305  3                  0x0057-0x005B
  * CHACHAPOLY 2 0x0054-0x0056
  * PLATFORM  2  0x0070-0x0072
+ * LMOTS     2  0x0076-0x0078
+ * LMS       2  0x0011-0x0017
  *
  * High-level module nr (3 bits - 0x0...-0x7...)
  * Name      ID  Nr of Errors
diff --git a/include/mbedtls/lmots.h b/include/mbedtls/lmots.h
new file mode 100644
index 00000000..c98f3bfd
--- /dev/null
+++ b/include/mbedtls/lmots.h
@@ -0,0 +1,303 @@
+/**
+ * \file lmots.h
+ *
+ * \brief This file provides an API for the LM-OTS post-quantum-safe one-time
+ *        public-key signature scheme.
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#ifndef MBEDTLS_LMOTS_H
+#define MBEDTLS_LMOTS_H
+
+#include "mbedtls/private_access.h"
+
+#include <stdint.h>
+#include <stddef.h>
+
+#define MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA -0x0076 /**< Bad data has been input to an LMOTS function */
+#define MBEDTLS_ERR_LMOTS_VERIFY_FAILED  -0x0078 /**< LMOTS signature verification failed */
+
+#define MBEDTLS_LMOTS_N_HASH_LEN            (32)
+#define MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN      (34)
+#define MBEDTLS_LMOTS_TYPE_LEN              (4)
+#define MBEDTLS_LMOTS_C_RANDOM_VALUE_LEN    (MBEDTLS_LMOTS_N_HASH_LEN)
+#define MBEDTLS_LMOTS_I_KEY_ID_LEN          (16)
+#define MBEDTLS_LMOTS_Q_LEAF_ID_LEN         (4)
+
+#define MBEDTLS_LMOTS_SIG_LEN (MBEDTLS_LMOTS_TYPE_LEN + MBEDTLS_LMOTS_C_RANDOM_VALUE_LEN + \
+                               (MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN * MBEDTLS_LMOTS_N_HASH_LEN))
+
+#define MBEDTLS_LMOTS_PUBKEY_LEN (MBEDTLS_LMOTS_TYPE_LEN + MBEDTLS_LMOTS_I_KEY_ID_LEN + \
+                                  MBEDTLS_LMOTS_Q_LEAF_ID_LEN + MBEDTLS_LMOTS_N_HASH_LEN)
+
+#define MBEDTLS_LMOTS_SIG_TYPE_OFFSET      (0)
+#define MBEDTLS_LMOTS_SIG_C_RANDOM_OFFSET  (MBEDTLS_LMOTS_SIG_TYPE_OFFSET     + MBEDTLS_LMOTS_TYPE_LEN)
+#define MBEDTLS_LMOTS_SIG_SIGNATURE_OFFSET (MBEDTLS_LMOTS_SIG_C_RANDOM_OFFSET + MBEDTLS_LMOTS_C_RANDOM_VALUE_LEN)
+
+#define MBEDTLS_LMOTS_PUBKEY_TYPE_OFFSET      (0)
+#define MBEDTLS_LMOTS_PUBKEY_I_KEY_ID_OFFSET  (MBEDTLS_LMOTS_PUBKEY_TYPE_OFFSET      + MBEDTLS_LMOTS_TYPE_LEN)
+#define MBEDTLS_LMOTS_PUBKEY_Q_LEAF_ID_OFFSET (MBEDTLS_LMOTS_PUBKEY_I_KEY_ID_OFFSET  + MBEDTLS_LMOTS_I_KEY_ID_LEN)
+#define MBEDTLS_LMOTS_PUBKEY_KEY_HASH_OFFSET  (MBEDTLS_LMOTS_PUBKEY_Q_LEAF_ID_OFFSET + MBEDTLS_LMOTS_Q_LEAF_ID_LEN)
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* https://www.iana.org/assignments/leighton-micali-signatures/leighton-micali-signatures.xhtml
+ * We are only implementing a subset of the types, particularly n32_w8, for the sake of simplicty.
+ */
+typedef enum {
+    MBEDTLS_LMOTS_SHA256_N32_W8 = 4
+} mbedtls_lmots_algorithm_type_t;
+
+
+typedef struct {
+    unsigned char MBEDTLS_PRIVATE(have_privkey); /*!< Whether the context contains a private key.
+                                                     Boolean values only. */
+    unsigned char MBEDTLS_PRIVATE(have_pubkey); /*!< Whether the context contains a public key.
+                                                     Boolean values only. */
+    unsigned char MBEDTLS_PRIVATE(I_key_identifier[MBEDTLS_LMOTS_I_KEY_ID_LEN]); /*!< The key
+                                                     identifier. */
+    unsigned int MBEDTLS_PRIVATE(q_leaf_identifier); /*!< Which leaf of the LMS key this is.
+                                                     0 if the key is not part of an LMS key. */
+    unsigned char MBEDTLS_PRIVATE(q_leaf_identifier_bytes)[MBEDTLS_LMOTS_Q_LEAF_ID_LEN];/*!< The
+                                                     leaf identifier in network bytes form. */
+    mbedtls_lmots_algorithm_type_t MBEDTLS_PRIVATE(type); /*!< The LM-OTS key type identifier as
+                                                     per IANA. Only SHA256_N32_W8 is currently
+                                                     supported. */
+    unsigned char MBEDTLS_PRIVATE(priv_key[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN][32]); /*!< The private
+                                                     key, one hash output per byte of the encoded
+                                                     symbol string P (32 bytes of hash output +
+                                                     2 bytes of checksum). */
+    unsigned char MBEDTLS_PRIVATE(pub_key[32]); /*!< The public key, in the form of a SHA256
+                                                     output. */
+} mbedtls_lmots_context;
+
+
+/**
+ * \brief                    This function initializes an LMOTS context
+ *
+ * \param ctx                The uninitialized LMOTS context that will then be
+ *                           initialized.
+ */
+void mbedtls_lmots_init( mbedtls_lmots_context *ctx );
+
+/**
+ * \brief                    This function uninitializes an LMOTS context
+ *
+ * \param ctx                The initialized LMOTS context that will then be
+ *                           uninitialized.
+ */
+void mbedtls_lmots_free( mbedtls_lmots_context *ctx );
+
+/**
+ * \brief                    This function sets the type of an LMOTS context
+ *
+ * \note                     The parameter set in the context will then be used
+ *                           for keygen operations etc.
+ *
+ * \param ctx                The initialized LMOTS context.
+ * \param type               The type that will be set in the context.
+ */
+int mbedtls_lmots_set_algorithm_type( mbedtls_lmots_context *ctx,
+                                      mbedtls_lmots_algorithm_type_t type );
+
+/**
+ * \brief                    This function creates a candidate public key from
+ *                           an LMOTS signature. This can then be compared to
+ *                           the real public key to determine the validity of
+ *                           the signature.
+ *
+ * \note                     This function is exposed publicly to be used in LMS
+ *                           signature verification, it is expected that
+ *                           mbedtls_lmots_verify will be used for LMOTS
+ *                           signature verification.
+ *
+ * \param I_key_identifier   The key identifier of the key, as a 16 byte
+ *                           bytestring.
+ * \param q_leaf_identifier  The leaf identifier of key. If this LMOTS key is
+ *                           not being used as part of an LMS key, this should
+ *                           be set to 0.
+ * \param msg                The buffer from which the message will be read.
+ * \param msg_len            The size of the message that will be read.
+ * \param sig                The buff from which the signature will be read.
+ *                           MBEDTLS_LMOTS_SIG_LEN bytes will be read from this.
+ * \param out                The buffer where the candidate public key will be
+ *                           stored. Must be at least #MBEDTLS_LMOTS_N_HASH_LEN
+ *                           bytes in size.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lmots_generate_pub_key_candidate( const unsigned char I_key_identifier[MBEDTLS_LMOTS_I_KEY_ID_LEN],
+                                              const unsigned char q_leaf_identifier[MBEDTLS_LMOTS_Q_LEAF_ID_LEN],
+                                              const unsigned char  *msg,
+                                              size_t msg_len,
+                                              const unsigned char *sig,
+                                              unsigned char *out );
+
+/**
+ * \brief                    This function creates a LMOTS signature, using a
+ *                           LMOTS context that contains a private key.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and must contain a private
+ *                           key.
+ *
+ * \note                     LMOTS private keys can only be used once, otherwise
+ *                           attackers may be able to create forged signatures.
+ *                           If the signing operation is successful, the private
+ *                           key in the context will be erased, and no further
+ *                           signing will be possible until another private key
+ *                           is loaded
+ *
+ * \param ctx                The initialized LMOTS context from which the
+ *                           private key will be read.
+ * \param f_rng              The RNG function to be used for signature
+ *                           generation.
+ * \param p_rng              The RNG context to be passed to f_rng
+ * \param msg                The buffer from which the message will be read.
+ * \param msg_len            The size of the message that will be read.
+ * \param sig                The buf into which the signature will be stored.
+ *                           Must be at least #MBEDTLS_LMOTS_SIG_LEN in size.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lmots_sign( mbedtls_lmots_context *ctx,
+                        int (*f_rng)(void *, unsigned char *, size_t),
+                        void *p_rng, const unsigned char *msg, size_t msg_len,
+                        unsigned char *sig );
+
+/**
+ * \brief                    This function verifies a LMOTS signature, using a
+ *                           LMOTS context that contains a public key.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and must contain a public key
+ *                           (either by import or generation).
+ *
+ * \param ctx                The initialized LMOTS context from which the public
+ *                           key will be read.
+ * \param msg                The buffer from which the message will be read.
+ * \param msg_len            The size of the message that will be read.
+ * \param sig                The buf from which the signature will be read.
+ *                           #MBEDTLS_LMOTS_SIG_LEN bytes will be read from
+ *                           this.
+ *
+ * \return         \c 0 on successful verification.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lmots_verify( mbedtls_lmots_context *ctx, const unsigned char *msg,
+                          size_t msg_len, const unsigned char *sig );
+
+/**
+ * \brief                    This function imports an LMOTS public key into a
+ *                           LMOTS context.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized.
+ *
+ * \note                     See IETF RFC8554 for details of the encoding of
+ *                           this public key.
+ *
+ * \param ctx                The initialized LMOTS context store the key in.
+ * \param key                The buffer from which the key will be read.
+ *                           #MBEDTLS_LMOTS_PUBKEY_LEN bytes will be read from
+ *                           this.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lmots_import_pubkey( mbedtls_lmots_context *ctx,
+                                 const unsigned char *key );
+
+/**
+ * \brief                    This function exports an LMOTS public key from a
+ *                           LMOTS context that already contains a public key.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and the context must contain
+ *                           a public key.
+ *
+ * \note                     See IETF RFC8554 for details of the encoding of
+ *                           this public key.
+ *
+ * \param ctx                The initialized LMOTS context that contains the
+ *                           publc key.
+ * \param key                The buffer into which the key will be output. Must
+ *                           be at least #MBEDTLS_LMOTS_PUBKEY_LEN in size.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lmots_export_pubkey( mbedtls_lmots_context *ctx,
+                                 unsigned char *key );
+
+/**
+ * \brief                    This function generates an LMOTS public key from a
+ *                           LMOTS context that already contains a private key.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and the context must contain
+ *                           a private key.
+ *
+ * \param ctx                The initialized LMOTS context to generate the key
+ *                           from and store it into.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lmots_gen_pubkey( mbedtls_lmots_context *ctx );
+
+/**
+ * \brief                    This function generates an LMOTS private key, and
+ *                           stores in into an LMOTS context.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and the type of the LMOTS
+ *                           context set using mbedtls_lmots_set_algorithm_type
+ *
+ * \note                     The seed must have at least 256 bits of entropy.
+ *
+ * \param ctx                The initialized LMOTS context to generate the key
+ *                           into.
+ * \param I_key_identifier   The key identifier of the key, as a 16 byte
+ *                           bytestring.
+ * \param q_leaf_identifier  The leaf identifier of key. If this LMOTS key is
+ *                           not being used as part of an LMS key, this should
+ *                           be set to 0.
+ * \param seed               The seed used to deterministically generate the
+ *                           key.
+ * \param seed_len           The length of the seed.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lmots_gen_privkey( mbedtls_lmots_context *ctx,
+                               const unsigned char I_key_identifier[MBEDTLS_LMOTS_I_KEY_ID_LEN],
+                               unsigned int q_leaf_identifier,
+                               const unsigned char *seed,
+                               size_t seed_len );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MBEDTLS_LMOTS_H */
diff --git a/include/mbedtls/lms.h b/include/mbedtls/lms.h
new file mode 100644
index 00000000..77559e24
--- /dev/null
+++ b/include/mbedtls/lms.h
@@ -0,0 +1,271 @@
+/**
+ * \file lms.h
+ *
+ * \brief This file provides an API for the LMS post-quantum-safe stateful-hash
+ *        public-key signature scheme.
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+#ifndef MBEDTLS_LMS_H
+#define MBEDTLS_LMS_H
+
+#include <stdint.h>
+#include <stddef.h>
+
+#include "mbedtls/private_access.h"
+#include "mbedtls/lmots.h"
+
+#define MBEDTLS_ERR_LMS_BAD_INPUT_DATA   -0x0011 /**< Bad data has been input to an LMS function */
+#define MBEDTLS_ERR_LMS_OUT_OF_PRIV_KEYS -0x0013 /**< Specified LMS key has utilised all of its private keys */
+#define MBEDTLS_ERR_LMS_VERIFY_FAILED    -0x0015 /**< LMS signature verification failed */
+#define MBEDTLS_ERR_LMS_ALLOC_FAILED     -0x0017 /**< LMS failed to allocate space for a private key */
+
+#define MBEDTLS_LMS_TYPE_LEN            (4)
+#define MBEDTLS_LMS_H_TREE_HEIGHT       (10)
+#define MBEDTLS_LMS_M_NODE_BYTES        (32)
+
+#define MBEDTLS_LMS_SIG_LEN (MBEDTLS_LMOTS_Q_LEAF_ID_LEN + MBEDTLS_LMOTS_SIG_LEN + \
+                             MBEDTLS_LMS_TYPE_LEN + MBEDTLS_LMS_H_TREE_HEIGHT * MBEDTLS_LMS_M_NODE_BYTES)
+
+#define MBEDTLS_LMS_PUBKEY_LEN (MBEDTLS_LMS_TYPE_LEN + MBEDTLS_LMOTS_TYPE_LEN + \
+                                MBEDTLS_LMOTS_I_KEY_ID_LEN + MBEDTLS_LMS_M_NODE_BYTES)
+
+#define MBEDTLS_LMS_SIG_Q_LEAF_ID_OFFSET    (0)
+#define MBEDTLS_LMS_SIG_OTS_SIG_OFFSET      (MBEDTLS_LMS_SIG_Q_LEAF_ID_OFFSET + MBEDTLS_LMOTS_Q_LEAF_ID_LEN)
+#define MBEDTLS_LMS_SIG_TYPE_OFFSET         (MBEDTLS_LMS_SIG_OTS_SIG_OFFSET   + MBEDTLS_LMOTS_SIG_LEN)
+#define MBEDTLS_LMS_SIG_PATH_OFFSET         (MBEDTLS_LMS_SIG_TYPE_OFFSET      + MBEDTLS_LMS_TYPE_LEN)
+
+#define MBEDTLS_LMS_PUBKEY_TYPE_OFFSET      (0)
+#define MBEDTLS_LMS_PUBKEY_OTSTYPE_OFFSET   (MBEDTLS_LMS_PUBKEY_TYPE_OFFSET     + MBEDTLS_LMS_TYPE_LEN)
+#define MBEDTLS_LMS_PUBKEY_I_KEY_ID_OFFSET  (MBEDTLS_LMS_PUBKEY_OTSTYPE_OFFSET  + MBEDTLS_LMOTS_TYPE_LEN)
+#define MBEDTLS_LMS_PUBKEY_ROOT_NODE_OFFSET (MBEDTLS_LMS_PUBKEY_I_KEY_ID_OFFSET + MBEDTLS_LMOTS_I_KEY_ID_LEN)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* https://www.iana.org/assignments/leighton-micali-signatures/leighton-micali-signatures.xhtml
+ * We are only implementing a subset of the types, particularly H10, for the sake of simplicty.
+ */
+typedef enum {
+    MBEDTLS_LMS_SHA256_M32_H10 = 0x6,
+} mbedtls_lms_algorithm_type_t;
+
+
+typedef struct {
+    unsigned char MBEDTLS_PRIVATE(have_privkey); /*!< Whether the context contains a private key.
+                                                     Boolean values only. */
+    unsigned char MBEDTLS_PRIVATE(have_pubkey); /*!< Whether the context contains a public key.
+                                                     Boolean values only. */
+    unsigned char MBEDTLS_PRIVATE(I_key_identifier)[MBEDTLS_LMOTS_I_KEY_ID_LEN]; /*!< The key
+                                                     identifier. */
+    mbedtls_lms_algorithm_type_t MBEDTLS_PRIVATE(type); /*!< The LMS key type identifier as per
+                                                     IANA. Only SHA256_M32_H10 is currently
+                                                     supported. */
+    mbedtls_lmots_algorithm_type_t MBEDTLS_PRIVATE(otstype); /*!< The LM-OTS key type identifier as
+                                                     per IANA. Only SHA256_N32_W8 is currently
+                                                     supported. */
+    unsigned int MBEDTLS_PRIVATE(q_next_usable_key); /*!< The index of the next OTS key that has not
+                                                     been used. */
+    mbedtls_lmots_context *MBEDTLS_PRIVATE(priv_keys); /*!< The private key material. One OTS key
+                                                     for each leaf node in the merkle tree. */
+    unsigned char MBEDTLS_PRIVATE(T_1_pub_key)[MBEDTLS_LMS_M_NODE_BYTES]; /*!< The public key, in
+                                                     the form of the merkle tree root node. */
+} mbedtls_lms_context;
+
+
+/**
+ * \brief                    This function initializes an LMS context
+ *
+ * \param ctx                The uninitialized LMS context that will then be
+ *                           initialized.
+ */
+void mbedtls_lms_init( mbedtls_lms_context *ctx );
+
+/**
+ * \brief                    This function uninitializes an LMS context
+ *
+ * \param ctx                The initialized LMS context that will then be
+ *                           uninitialized.
+ */
+void mbedtls_lms_free( mbedtls_lms_context *ctx );
+
+/**
+ * \brief                    This function sets the type of an LMS context
+ *
+ * \note                     The parameter set in the context will then be used
+ *                           for keygen operations etc.
+ *
+ * \param ctx                The initialized LMS context.
+ * \param type               The type that will be set in the context.
+ * \param otstype            The type of the LMOTS implementation used by this
+ *                           context.
+ */
+int mbedtls_lms_set_algorithm_type( mbedtls_lms_context *ctx,
+                                    mbedtls_lms_algorithm_type_t type,
+                                    mbedtls_lmots_algorithm_type_t otstype);
+
+/**
+ * \brief                    This function creates a LMS signature, using a
+ *                           LMOTS context that contains a private key.
+ *
+ * \note                     This function is intended for _testing purposes
+ *                           only_, due to complexities around updating stateful
+ *                           keys.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and must contain a private
+ *                           key.
+ *
+ * \note                     Each of the LMOTS private keys inside a LMS private
+ *                           key can only be used once. If they are reused, then
+ *                           attackers may be able to forge signatures with that
+ *                           key. This is all handled transparently, but it is
+ *                           important to not perform copy operations on LMS
+ *                           contexts that contain private key material.
+ *
+ * \param ctx                The initialized LMS context from which the
+ *                           private key will be read.
+ * \param f_rng              The RNG function to be used for signature
+ *                           generation.
+ * \param p_rng              The RNG context to be passed to f_rng
+ * \param msg                The buffer from which the message will be read.
+ * \param msg_len            The size of the message that will be read.
+ * \param sig                The buf into which the signature will be stored.
+ *                           Must be at least #MBEDTLS_LMOTS_SIG_LEN in size.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lms_sign( mbedtls_lms_context *ctx,
+                      int (*f_rng)(void *, unsigned char *, size_t),
+                      void* p_rng, unsigned char *msg, unsigned int msg_len,
+                      unsigned char *sig);
+
+/**
+ * \brief                    This function verifies a LMS signature, using a
+ *                           LMS context that contains a public key.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and must contain a public key
+ *                           (either by import or generation).
+ *
+ * \param ctx                The initialized LMS context from which the public
+ *                           key will be read.
+ * \param msg                The buffer from which the message will be read.
+ * \param msg_len            The size of the message that will be read.
+ * \param sig                The buf from which the signature will be read.
+ *                           #MBEDTLS_LMS_SIG_LEN bytes will be read from
+ *                           this.
+ *
+ * \return         \c 0 on successful verification.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lms_verify( const mbedtls_lms_context *ctx,
+                        const unsigned char *msg, unsigned int msg_len,
+                        const unsigned char *sig );
+
+/**
+ * \brief                    This function imports an LMOTS public key into a
+ *                           LMS context.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized.
+ *
+ * \note                     See IETF RFC8554 for details of the encoding of
+ *                           this public key.
+ *
+ * \param ctx                The initialized LMS context store the key in.
+ * \param key                The buffer from which the key will be read.
+ *                           #MBEDTLS_LMS_PUBKEY_LEN bytes will be read from
+ *                           this.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lms_import_pubkey( mbedtls_lms_context *ctx,
+                               const unsigned char *key );
+
+/**
+ * \brief                    This function exports an LMOTS public key from a
+ *                           LMS context that already contains a public key.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and the context must contain
+ *                           a public key.
+ *
+ * \note                     See IETF RFC8554 for details of the encoding of
+ *                           this public key.
+ *
+ * \param ctx                The initialized LMS context that contains the
+ *                           publc key.
+ * \param key                The buffer into which the key will be output. Must
+ *                           be at least #MBEDTLS_LMS_PUBKEY_LEN in size.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lms_export_pubkey( mbedtls_lms_context *ctx,
+                               unsigned char *key );
+
+/**
+ * \brief                    This function generates an LMS public key from a
+ *                           LMS context that already contains a private key.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and the context must contain
+ *                           a private key.
+ *
+ * \param ctx                The initialized LMS context to generate the key
+ *                           from and store it into.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lms_gen_pubkey( mbedtls_lms_context *ctx );
+
+/**
+ * \brief                    This function generates an LMS private key, and
+ *                           stores in into an LMS context.
+ *
+ * \note                     Before this function is called, the context must
+ *                           have been initialized and the type of the LMS
+ *                           context set using mbedtls_lmots_set_algorithm_type
+ *
+ * \note                     The seed must have at least 256 bits of entropy.
+ *
+ * \param ctx                The initialized LMOTS context to generate the key
+ *                           into.
+ * \param f_rng              The RNG function to be used to generate the key ID.
+ * \param p_rng              The RNG context to be passed to f_rng
+ * \param seed               The seed used to deterministically generate the
+ *                           key.
+ * \param seed_len           The length of the seed.
+ *
+ * \return         \c 0 on success.
+ * \return         A non-zero error code on failure.
+ */
+int mbedtls_lms_gen_privkey( mbedtls_lms_context *ctx,
+                             int (*f_rng)(void *, unsigned char *, size_t),
+                             void* p_rng, unsigned char *seed,
+                             size_t seed_len );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* MBEDTLS_LMS_H */
diff --git a/include/mbedtls/mbedtls_config.h b/include/mbedtls/mbedtls_config.h
index 1c60ec8e..ced381ff 100644
--- a/include/mbedtls/mbedtls_config.h
+++ b/include/mbedtls/mbedtls_config.h
@@ -662,6 +662,7 @@
 /* Montgomery curves (supporting ECP) */
 #define MBEDTLS_ECP_DP_CURVE25519_ENABLED
 #define MBEDTLS_ECP_DP_CURVE448_ENABLED
+#define MBEDTLS_ECP_DP_CURVE_SM2_ENABLED
 
 /**
  * \def MBEDTLS_ECP_NIST_OPTIM
@@ -1778,7 +1779,7 @@
  *
  * Uncomment this to enable internal use of PSA Crypto and new associated APIs.
  */
-//#define MBEDTLS_USE_PSA_CRYPTO
+#define MBEDTLS_USE_PSA_CRYPTO
 
 /**
  * \def MBEDTLS_PSA_CRYPTO_CONFIG
@@ -1967,6 +1968,8 @@
  *          library/pkcs5.c
  *          library/pkparse.c
  */
+#define MBEDTLS_SM4_C
+
 #define MBEDTLS_ASN1_PARSE_C
 
 /**
@@ -2405,6 +2408,34 @@
  */
 #define MBEDTLS_HMAC_DRBG_C
 
+/**
+ * \def MBEDTLS_LMOTS_C
+ *
+ * Enable the LMOTS one-time asymmetric hash signature algorithm.
+ *
+ * Module:  library/lm_ots.c
+ * Caller:
+ *
+ * Requires: MBEDTLS_SHA256_C
+ *
+ * Uncomment to enable the LMOTS signature algorithm.
+ */
+#define MBEDTLS_LMOTS_C
+
+/**
+ * \def MBEDTLS_LMS_C
+ *
+ * Enable the LMS stateful-hash asymmetric signature algorithm.
+ *
+ * Module:  library/lms.c
+ * Caller:
+ *
+ * Requires: MBEDTLS_LMS_C
+ *
+ * Uncomment to enable the LMS signature algorithm.
+ */
+#define MBEDTLS_LMS_C
+
 /**
  * \def MBEDTLS_NIST_KW_C
  *
@@ -2785,6 +2816,11 @@
  */
 #define MBEDTLS_SHA1_C
 
+#define MBEDTLS_SM3_C
+
+#define MBEDTLS_SM2_C
+
+#define MBEDTLS_SM4_C
 /**
  * \def MBEDTLS_SHA224_C
  *
diff --git a/include/mbedtls/md.h b/include/mbedtls/md.h
index 612061d1..1b96fb3b 100644
--- a/include/mbedtls/md.h
+++ b/include/mbedtls/md.h
@@ -61,6 +61,7 @@ typedef enum {
     MBEDTLS_MD_SHA384,    /**< The SHA-384 message digest. */
     MBEDTLS_MD_SHA512,    /**< The SHA-512 message digest. */
     MBEDTLS_MD_RIPEMD160, /**< The RIPEMD-160 message digest. */
+    MBEDTLS_MD_SM3
 } mbedtls_md_type_t;
 
 #if defined(MBEDTLS_SHA512_C)
@@ -92,6 +93,17 @@ typedef struct mbedtls_md_info_t mbedtls_md_info_t;
  */
 typedef struct mbedtls_md_context_t
 {
+#ifdef PLATFORM_RISCV
+    /** Information about the associated message digest. */
+    const mbedtls_md_info_t *md_info;
+
+    /** The digest-specific context. */
+    void *md_ctx;
+
+    /** The HMAC part of the context. */
+    void *hmac_ctx;
+#else
+
     /** Information about the associated message digest. */
     const mbedtls_md_info_t *MBEDTLS_PRIVATE(md_info);
 
@@ -100,6 +112,7 @@ typedef struct mbedtls_md_context_t
 
     /** The HMAC part of the context. */
     void *MBEDTLS_PRIVATE(hmac_ctx);
+#endif    
 } mbedtls_md_context_t;
 
 /**
diff --git a/include/mbedtls/pk.h b/include/mbedtls/pk.h
index 867961d3..fc6102d3 100644
--- a/include/mbedtls/pk.h
+++ b/include/mbedtls/pk.h
@@ -96,6 +96,7 @@ typedef enum {
     MBEDTLS_PK_RSA_ALT,
     MBEDTLS_PK_RSASSA_PSS,
     MBEDTLS_PK_OPAQUE,
+    MBEDTLS_PK_SM2,
 } mbedtls_pk_type_t;
 
 /**
diff --git a/include/mbedtls/sm2.h b/include/mbedtls/sm2.h
new file mode 100644
index 00000000..f935eab5
--- /dev/null
+++ b/include/mbedtls/sm2.h
@@ -0,0 +1,211 @@
+#ifndef MBEDTLS_SM2_H
+#define MBEDTLS_SM2_H
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "mbedtls_config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+
+#include <string.h>
+
+#include "ecp.h"
+#include "md.h"
+
+#define MBEDTLS_ALLOW_PRIVATE_ACCESS
+
+#define MBEDTLS_ERR_SM2_BAD_INPUT_DATA      -0x4800 /*!< Bad input parameters to function. */
+#define MBEDTLS_ERR_SM2_ALLOC_FAILED        -0x4880 /*!< Memory allocation failed. */
+#define MBEDTLS_ERR_SM2_KDF_FAILED          -0x4900 /*!< KDF got empty result. */
+#define MBEDTLS_ERR_SM2_DECRYPT_BAD_HASH    -0x4980 /*!< Bad C3 in SM2 decrypt */
+#define MBEDTLS_ERR_SM2_RANDOM_FAILED       -0x4A00 /*!< Generation of random value, such as (ephemeral) key, failed. */
+#define MBEDTLS_ERR_SM2_BAD_SIGNATURE       -0x4A80 /*!< Invalid signature */
+
+#define MBEDTLS_SM2_SPECIFIC_MD_ALGORITHM   MBEDTLS_MD_SM3
+#define MBEDTLS_SM2_GMT09_DEFAULT_ID        "1234567812345678"
+
+/**
+ *  Enum for the point conversion form as defined in X9.62 (ECDSA)
+ *  for the encoding of a elliptic curve point (x,y) */
+typedef enum {
+    /** the point is encoded as z||x, where the octet z specifies
+     *          *  which solution of the quadratic equation y is  */
+    MBEDTLS_ECP_POINT_CONVERSION_COMPRESSED = 2,
+    /** the point is encoded as z||x||y, where z is the octet 0x02  */
+    MBEDTLS_ECP_POINT_CONVERSION_UNCOMPRESSED = 4,
+    /** the point is encoded as z||x||y, where the octet z specifies
+     *          *  which solution of the quadratic equation y is  */
+    MBEDTLS_ECP_POINT_CONVERSION_HYBRID = 6
+} mbedtls_ecp_point_conversion_form_t;
+
+#if !defined(MBEDTLS_SM2_ALT)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief          SM2 context structure
+ */
+typedef mbedtls_ecp_keypair mbedtls_sm2_context;
+
+
+/**
+ * \brief           Perform SM2 encryption
+ *
+ * \param ctx       SM2 context
+ * \param md_alg    Algorithm that was used to hash the message
+ * \param input     the plaintext to be encrypted
+ * \param ilen      the plaintext length
+ * \param output    buffer that will hold the plaintext
+ * \param olen      will contain the plaintext length
+ * \param f_rng     RNG function
+ * \param p_rng     RNG parameter
+ *
+ * \return          0 if successful, or a error code
+ */
+int mbedtls_sm2_encrypt(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const unsigned char *input, size_t ilen,
+        unsigned char *output, size_t *olen,
+        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
+
+/**
+ * \brief           Perform SM2 decryption
+ *
+ * \param ctx       SM2 context
+ * \param md_alg    Algorithm that was used to hash the message
+ * \param input     encrypted data
+ * \param ilen      the encrypted data length
+ * \param output    buffer that will hold the plaintext
+ * \param olen      will contain the plaintext length
+ *
+ * \return          0 if successful, or a error code
+ */
+int mbedtls_sm2_decrypt(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const unsigned char *input, size_t ilen,
+        unsigned char *output, size_t *olen);
+
+/**
+ * \brief           Compute SM2 signature of a previously hashed message
+ *
+ * \param ctx       SM2 context
+ * \param md_alg    Algorithm that was used to hash the message
+ * \param hash      Message digest
+ * \param sig       Buffer holding the signature data
+ * \param f_rng     RNG function
+ * \param p_rng     RNG parameter
+ *
+ * \return          0 if successful, or a error code
+ */
+int mbedtls_sm2_sign(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const unsigned char *hash, unsigned char *sig,
+        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
+
+/**
+ * \brief           Verify SM2 signature of a previously hashed message
+ *
+ * \param ctx       SM2 context
+ * \param md_alg    Algorithm that was used to hash the message
+ * \param hash      Message digest
+ * \param sig       Signature to verify
+ *
+ * \return          0 if successful, or a error code
+ */
+int mbedtls_sm2_verify(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const unsigned char *hash, const unsigned char *sig);
+
+/**
+ * \brief           Hash Z with ID and public key
+ *
+ * \param ctx       SM2 context
+ * \param md_alg    Algorithm that was used to hash the message
+ * \param id        User ID, character string.
+ *                  GM/T 0009-2012 Public Key Infrastructure Application
+ *                      Technology SM2 Cryptography Specification: Section 10:
+ *                      In the case Without specific agreement, the default ID
+ *                      value is: "1234567812345678" (16 byte)
+ * \param idlen     User ID string length
+ * \param z         Buffer that will hold the Z
+ *
+ * \return          0 if successful, or a error code
+ */
+int mbedtls_sm2_hash_z(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const char *id, size_t idlen, unsigned char *z);
+
+/**
+ * \brief           Hash E with Z and message
+ *
+ * \param md_alg    Algorithm that was used to hash the message
+ * \param z         Z computed by mbedtls_sm2_hash_z
+ * \param input     buffer holding the data
+ * \param ilen      length of the input data
+ * \param e         Buffer that will hold the E
+ *
+ * \return          0 if successful, or a error code
+ */
+int mbedtls_sm2_hash_e(mbedtls_md_type_t md_alg, const unsigned char *z,
+        const unsigned char *input, size_t ilen, unsigned char *e);
+
+/**
+ * \brief           Generate an SM2 keypair on the given curve
+ *
+ * \param ctx       SM2 context
+ * \param gid       Group (elliptic curve) to use. One of the various
+ *                  MBEDTLS_ECP_DP_XXX macros depending on configuration.
+ * \param f_rng     RNG function
+ * \param p_rng     RNG parameter
+ *
+ * \return          0 if successful, or a error code.
+ */
+int mbedtls_sm2_genkey(mbedtls_sm2_context *ctx, mbedtls_ecp_group_id gid,
+        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng);
+
+/**
+ * \brief           Set an SM2 context from an EC key pair
+ *
+ * \param ctx       SM2 context to set
+ * \param key       EC key to use
+ *
+ * \return          0 on success, or a MBEDTLS_ERR_ECP_XXX code.
+ */
+int mbedtls_sm2_from_keypair(mbedtls_sm2_context *ctx,
+        const mbedtls_ecp_keypair *key);
+
+/**
+ * \brief           Initialize context
+ *
+ * \param ctx       Context to be initialized
+ */
+void mbedtls_sm2_init(mbedtls_sm2_context *ctx);
+
+/**
+ * \brief           Free context
+ *
+ * \param ctx       Context to free
+ */
+void mbedtls_sm2_free(mbedtls_sm2_context *ctx);
+
+#ifdef __cplusplus
+}
+#endif
+
+#else  /* MBEDTLS_SM2_ALT */
+#include "sm2_alt.h"
+#endif /* MBEDTLS_SM2_ALT */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief           Checkup routine
+ *
+ * \return          0 if successful, or 1 if the test failed
+ */
+int mbedtls_sm2_self_test(int verbose);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sm2.h */
diff --git a/include/mbedtls/sm3.h b/include/mbedtls/sm3.h
new file mode 100644
index 00000000..1377b84c
--- /dev/null
+++ b/include/mbedtls/sm3.h
@@ -0,0 +1,120 @@
+#ifndef MBEDTLS_SM3_H
+#define MBEDTLS_SM3_H
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "mbedtls_config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+#include "mbedtls/private_access.h"
+
+#include "mbedtls/build_info.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+typedef struct mbedtls_sm3_context
+{
+    uint32_t total[2];          /*!< The number of Bytes processed.  */
+    uint32_t state[8];          /*!< The intermediate digest state.  */
+    unsigned char buffer[64];   /*!< The data block being processed. */
+    unsigned char ipad[64];   /*!< The data block being processed. */
+    unsigned char opad[64];   /*!< The data block being processed. */
+}
+mbedtls_sm3_context;
+
+// void mbedtls_sm3_init(mbedtls_sm3_context *ctx);
+// void mbedtls_sm3_starts(mbedtls_sm3_context *ctx);
+// void mbedtls_sm3_update(mbedtls_sm3_context *ctx, const uint8_t *input, size_t ilen);
+// void mbedtls_sm3_finish(mbedtls_sm3_context *ctx, uint8_t output[32]);
+// void mbedtls_sm3_free( mbedtls_sm3_context *ctx );
+// void mbedtls_sm3_clone( mbedtls_sm3_context *dst,
+//                         const mbedtls_sm3_context *src );
+//#endif
+
+/**
+ * \brief          Initialize SM3 context
+ *
+ * \param ctx      SM3 context to be initialized
+ */
+void mbedtls_sm3_init(mbedtls_sm3_context *ctx);
+
+/**
+ * \brief          Clear SM3 context
+ *
+ * \param ctx      SM3 context to be cleared
+ */
+void mbedtls_sm3_free(mbedtls_sm3_context *ctx);
+
+/**
+ * \brief          Clone (the state of) a SM3 context
+ *
+ * \param dst      The destination context
+ * \param src      The context to be cloned
+ */
+void mbedtls_sm3_clone(mbedtls_sm3_context *dst,
+        const mbedtls_sm3_context *src);
+
+/**
+ * \brief          SM3 context setup
+ *
+ * \param ctx      context to be initialized
+ */
+int mbedtls_sm3_starts(mbedtls_sm3_context *ctx);
+
+/**
+ * \brief          SM3 process buffer
+ *
+ * \param ctx      SM3 context
+ * \param input    buffer holding the data
+ * \param ilen     length of the input data
+ */
+int mbedtls_sm3_update(mbedtls_sm3_context *ctx,
+        const unsigned char *input, int ilen);
+
+/**
+ * \brief          SM3 final digest
+ *
+ * \param ctx      SM3 context
+ * \param output   SM3 checksum result
+ */
+int mbedtls_sm3_finish(mbedtls_sm3_context *ctx, unsigned char output[32]);
+
+/* Internal use */
+int mbedtls_sm3_process(mbedtls_sm3_context *ctx,
+        const unsigned char data[64]);
+
+/**
+ * \brief          Output = SM3( input buffer )
+ *
+ * \param input    buffer holding the data
+ * \param ilen     length of the input data
+ * \param output   SM3 checksum result
+ */
+int mbedtls_sm3(const unsigned char *input, int ilen,
+        unsigned char output[32]);
+
+// #ifdef __cplusplus
+// }
+// #endif
+
+// #else  /* MBEDTLS_SM3_ALT */
+// #include "sm3_alt.h"
+// #endif /* MBEDTLS_SM3_ALT */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief          Checkup routine
+ *
+ * \return         0 if successful, or 1 if the test failed
+ */
+int mbedtls_sm3_self_test(int verbose);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sm3.h */
\ No newline at end of file
diff --git a/include/mbedtls/sm4.h b/include/mbedtls/sm4.h
new file mode 100644
index 00000000..7badcf6c
--- /dev/null
+++ b/include/mbedtls/sm4.h
@@ -0,0 +1,129 @@
+#ifndef MBEDTLS_SM4_H
+#define MBEDTLS_SM4_H
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+
+#include <stdint.h>
+#include <string.h>
+
+#define MBEDTLS_SM4_ENCRYPT 1
+#define MBEDTLS_SM4_DECRYPT 0
+
+#define MBEDTLS_ERR_SM4_INVALID_INPUT_LENGTH        -0x0054
+
+#define MBEDTLS_SM4_KEY_SIZE 16
+
+#if !defined(MBEDTLS_SM4_ALT)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief           SM4 context structure
+ */
+typedef struct
+{
+    uint32_t sk[32];            /*!<  SM4 subkeys       */
+}
+mbedtls_sm4_context;
+
+/**
+ * \brief          Initialize SM4 context
+ *
+ * \param ctx      SM4 context to be initialized
+ */
+void mbedtls_sm4_init(mbedtls_sm4_context *ctx);
+/**
+ * \brief          Clear SM4 context
+ *
+ * \param ctx      SM4 context to be cleared
+ */
+void mbedtls_sm4_free(mbedtls_sm4_context *ctx);
+/**
+ * \brief          SM4 key schedule (encryption)
+ *
+ * \param ctx      SM4 context to be initialized
+ * \param key      <MBEDTLS_SM4_KEY_SIZE> byte secret key
+ *
+ * \return         0
+ */
+int mbedtls_sm4_setkey_enc(mbedtls_sm4_context *ctx,
+        const unsigned char key[MBEDTLS_SM4_KEY_SIZE]);
+/**
+ * \brief          SM4 key schedule (decryption)
+ *
+ * \param ctx      SM4 context to be initialized
+ * \param key      <MBEDTLS_SM4_KEY_SIZE> byte secret key
+ *
+ * \return         0
+ */
+int mbedtls_sm4_setkey_dec(mbedtls_sm4_context *ctx,
+        const unsigned char key[MBEDTLS_SM4_KEY_SIZE]);
+
+/**
+ * \brief          SM4-ECB block encryption/decryption
+ *
+ * \param ctx      SM4 context
+ * \param input    <MBEDTLS_SM4_KEY_SIZE> byte input block
+ * \param output   <MBEDTLS_SM4_KEY_SIZE> byte output block
+ *
+ * \return         0 if successful
+ */
+int mbedtls_sm4_crypt_ecb(mbedtls_sm4_context *ctx, int mode,
+        const unsigned char input[MBEDTLS_SM4_KEY_SIZE],
+        unsigned char output[MBEDTLS_SM4_KEY_SIZE]);
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+/**
+ * \brief          SM4-CBC buffer encryption/decryption
+ *
+ * \param ctx      SM4 context
+ * \param mode     MBEDTLS_SM4_ENCRYPT or MBEDTLS_SM4_DECRYPT
+ * \param length   length of the input data
+ * \param iv       initialization vector (updated after use)
+ * \param input    buffer holding the input data
+ * \param output   buffer holding the output data
+ *
+ * \return         0 if successful, or MBEDTLS_ERR_SM4_INVALID_INPUT_LENGTH
+ */
+int mbedtls_sm4_crypt_cbc(mbedtls_sm4_context *ctx, int mode, size_t length,
+        unsigned char iv[MBEDTLS_SM4_KEY_SIZE],
+        const unsigned char *input, unsigned char *output);
+#endif /* MBEDTLS_CIPHER_MODE_CBC */
+
+int mbedtls_sm4_crypt_ctr( mbedtls_sm4_context *ctx,
+                           size_t length,
+                           size_t *nc_off,
+                           unsigned char nonce_counter[16],
+                           unsigned char stream_block[16],
+                           const unsigned char *input,
+                           unsigned char *output );
+
+#ifdef __cplusplus
+}
+#endif
+
+#else  /* MBEDTLS_SM4_ALT */
+#include "sm4_alt.h"
+#endif /* MBEDTLS_SM4_ALT */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief          Checkup routine
+ *
+ * \return         0 if successful, or 1 if the test failed
+ */
+int mbedtls_sm4_self_test(int verbose);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* sm4.h */
diff --git a/include/psa/cm32m4xxr_aes.h b/include/psa/cm32m4xxr_aes.h
new file mode 100644
index 00000000..4cb0b064
--- /dev/null
+++ b/include/psa/cm32m4xxr_aes.h
@@ -0,0 +1,131 @@
+/*******************************************************************************
+*
+* COPYRIGHT(c) 2020, China Mobile IOT
+*
+* Redistribution and use in source and binary forms, with or without modification,
+* are permitted provided that the following conditions are met:
+*	1. Redistributions of source code must retain the above copyright notice,
+*	   this list of conditions and the following disclaimer.
+*	2. Redistributions in binary form must reproduce the above copyright notice,
+*	   this list of conditions and the following disclaimer in the documentation
+*	   and/or other materials provided with the distribution.
+*	3. Neither the name of China Mobile IOT nor the names of its contributors
+*	   may be used to endorse or promote products derived from this software
+*	   without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*******************************************************************************/
+
+/**
+ * @file cm32m4xxr_aes.h
+ * @author CMIOT Firmware Team
+ * @version v1.0.0
+ *
+ * @copyright Copyright (c) 2020, CMIOT. All rights reserved.
+ */
+#ifndef __CM32M4xxR_AES_H__
+#define __CM32M4xxR_AES_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup CM32M4xxR_Algorithm_Library
+ * @{
+ */
+
+/** @addtogroup AES
+ * @brief AES symmetrical cipher algorithm
+ * @{
+ */
+ 
+#define AES_ECB	(0x11111111)
+#define AES_CBC (0x22222222)
+#define AES_CTR (0x33333333)
+
+#define AES_ENC	(0x44444444)
+#define AES_DEC	(0x55555555)
+
+enum
+{
+	AES_Crypto_OK        = 0x0,			/* AES opreation success */
+	AES_Init_OK          = 0x0,			/* AES Init opreation success */
+	AES_Crypto_ModeError = 0x5a5a5a5a,	/* Working mode error(Neither ECB nor CBC nor CTR) */
+	AES_Crypto_EnOrDeError,				/* En&De error(Neither encryption nor decryption) */
+	AES_Crypto_ParaNull,				/* The part of input(output/iv) Null */
+	AES_Crypto_LengthError,				/* If Working mode is ECB or CBC,the length of input message must be 4 times and cannot be zero;
+										   if Working mode is CTR,the length of input message cannot be zero; othets: return AES_Crypto_LengthError */
+	AES_Crypto_KeyLengthError,			/* The keyWordLen must be 4 or 6 or 8; othets: return AES_Crypto_KeyLengthError */
+	AES_Crypto_UnInitError,				/* AES uninitialized */
+};
+
+typedef struct
+{
+	uint32_t *in;			/* The part of input to be encrypted or decrypted */
+	uint32_t *iv;			/* The part of initial vector */
+	uint32_t *out;			/* The part of out */
+	uint32_t *key;			/* The part of key */
+	uint32_t keyWordLen;	/* The length(by word) of key */
+	uint32_t inWordLen;		/* The length(by word) of plaintext or cipher */
+	uint32_t En_De;			/* 0x44444444 - encrypt, 0x55555555 - decrypt */
+	uint32_t Mode;			/* 0x11111111 - ECB, 0x22222222 - CBC, 0x33333333 - CTR */
+}AES_PARM;
+
+ /**
+ * @brief AES_Init
+ * @return AES_Init_OK, AES Init success; othets: AES Init fail
+ * @note    
+ */
+uint32_t  AES_Init(AES_PARM *parm);
+
+/**
+ * @brief AES crypto
+ * @param[in] parm pointer to AES context and the detail please refer to struct AES_PARM in AES.h
+ * @return AES_Crypto_OK, AES crypto success; othets: AES crypto fail(reference to the definition by enum variation) 
+ * @note  1.Please refer to the demo in user guidance before using this function  
+ *        2.Input and output can be the same buffer
+ *        3. IV can be NULL when ECB mode
+ *        4. If Working mode is ECB or CBC,the length of input message must be 4 times and cannot be zero;
+ *	         if Working mode is CTR,the length of input message cannot be zero;
+ *        5. If the input is in byte, make sure align by word.
+ */
+uint32_t AES_Crypto(AES_PARM *parm);
+
+/**
+ * @brief AES close
+ * @return none
+ * @note if you want to close AES algorithm, this function can be recalled.
+ */
+void AES_Close(void);
+
+/**
+ * @brief Get AES lib version
+ * @param[out] type pointer one byte type information represents the type of the lib, like Commercial version.\
+ * @Bits 0~4 stands for Commercial (C), Security (S), Normal (N), Evaluation (E), Test (T), Bits 5~7 are reserved. e.g. 0x09 stands for CE version.
+ * @param[out] customer pointer one byte customer information represents customer ID. for example, 0x00 stands for standard version, 0x01 is for Tianyu customized version...
+ * @param[out] date pointer array which include three bytes date information. If the returned bytes are 18,9,13,this denotes September 13,2018 
+ * @param[out] version pointer one byte version information represents develop version of the lib. e.g. 0x12 denotes version 1.2.
+ * @return none
+ * @1.You can recall this function to get AES lib information
+ */
+void AES_Version(uint8_t *type, uint8_t *customer, uint8_t date[3], uint8_t *version);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
diff --git a/include/psa/cm32m4xxr_algo_common.h b/include/psa/cm32m4xxr_algo_common.h
new file mode 100644
index 00000000..380d6ab9
--- /dev/null
+++ b/include/psa/cm32m4xxr_algo_common.h
@@ -0,0 +1,163 @@
+/*******************************************************************************
+*
+* COPYRIGHT(c) 2020, China Mobile IOT
+*
+* Redistribution and use in source and binary forms, with or without modification,
+* are permitted provided that the following conditions are met:
+*	1. Redistributions of source code must retain the above copyright notice,
+*	   this list of conditions and the following disclaimer.
+*	2. Redistributions in binary form must reproduce the above copyright notice,
+*	   this list of conditions and the following disclaimer in the documentation
+*	   and/or other materials provided with the distribution.
+*	3. Neither the name of China Mobile IOT nor the names of its contributors
+*	   may be used to endorse or promote products derived from this software
+*	   without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*******************************************************************************/
+
+/**
+ * @file cm32m4xxr_algo_common.h
+ * @author CMIOT Firmware Team
+ * @version v1.0.0
+ *
+ * @copyright Copyright (c) 2020, CMIOT. All rights reserved.
+ */
+#ifndef __CM32M4xxR_ALGO_COMMON_H__
+#define __CM32M4xxR_ALGO_COMMON_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup CM32M4xxR_Algorithm_Library
+ * @{
+ */
+ 
+enum{
+	Cpy_OK		= 0,	/* Copy success */
+	SetZero_OK  = 0,	/* Set zero success */
+	XOR_OK		= 0,	/* XOR success */
+	Reverse_OK	= 0,	/* Reverse success */
+	Cmp_EQUAL	= 0,	/* Two big number are equal */
+	Cmp_UNEQUAL	= 1,	/* Two big number are not equal */
+
+};
+
+/**
+ * @brief disturb the sequence order
+ * @param[in] order pointer to the sequence to be disturbed
+ * @param[in] rand pointer to random number
+ * @param[in] the length of order
+ * @return RandomSort_OK:  disturb order success;  Others: disturb order fail;
+ * @note 
+ */
+uint32_t RandomSort(uint8_t *order, const uint8_t *rand, uint32_t len);
+
+/**
+ * @brief Copy data by byte
+ * @param[in]  dst pointer to destination data
+ * @param[in]  src pointer to source data
+ * @param[in]  byte length 
+ * @return Cpy_OK: success; others: fail.
+ * @note 1. dst and  src cannot be same
+ */
+uint32_t Cpy_U8(uint8_t *dst, uint8_t *src, uint32_t byteLen);
+
+/**
+ * @brief Copy data by word
+ * @param[in]  dst pointer to destination data
+ * @param[in]  src pointer to source data
+ * @param[in]  word length 
+ * @return Cpy_OK: success; others: fail.
+ * @note 1. dst and  src must be aligned by word
+ */
+uint32_t Cpy_U32(uint32_t *dst, const uint32_t *src, uint32_t wordLen);
+
+ /**
+ * @brief XOR
+ * @param[in] a pointer to one data to be XORed
+ * @param[in] b pointer to another data to be XORed
+ * @param[in] the length of order
+ * @return XOR_OK:  operation success;  Others: operation fail;
+ * @note 
+ */
+uint32_t XOR_U8(uint8_t *a, uint8_t *b, uint8_t *c, uint32_t byteLen);
+
+ /**
+ * @brief XORed two u32 arrays
+ * @param[in] a pointer to one data to be XORed
+ * @param[in] b pointer to another data to be XORed
+ * @param[in] the length of order
+ * @return XOR_OK:  operation success;  Others: operation fail;
+ * @note 
+ */
+uint32_t XOR_U32(uint32_t *a,uint32_t *b,uint32_t *c,uint32_t wordLen);
+
+/**
+ * @brief set zero by byte
+ * @param[in] dst pointer to the address to be set zero 
+ * @param[in]  byte length 
+ * @return SetZero_OK: success; others: fail.
+ * @note 
+ */
+uint32_t SetZero_U8(uint8_t *dst, uint32_t byteLen);
+
+/**
+ * @brief set zero by word
+ * @param[in] dst pointer to the address to be set zero 
+ * @param[in]  word length 
+ * @return SetZero_OK: success; others: fail.
+ * @note 
+ */
+uint32_t SetZero_U32(uint32_t *dst, uint32_t wordLen);
+
+/**
+ * @brief reverse byte order of every word, the words stay the same
+ * @param[in]  dst pointer to the destination address
+ * @param[in]  src pointer to the source address 
+ * @param[in]  word length 
+ * @return Reverse_OK: success; others: fail.
+ * @note 1.dst and src can be same
+ */
+uint32_t ReverseBytesInWord_U32(uint32_t *dst, const uint32_t *src, uint32_t wordLen);
+
+/**
+ * @brief compare two big number
+ * @param[in] a pointer to one big number
+ * @param[in] word length of a
+ * @param[in] b pointer to another big number
+ * @param[in]  word length of b
+ * @return Cmp_UNEQUAL:a!=b;Cmp_EQUAL: a==b.
+ * 
+ */
+int32_t Cmp_U32(const uint32_t *a, uint32_t aWordLen, const uint32_t *b, uint32_t bWordLen);
+
+/**
+ * @brief compare two big number
+ * @param[in] a pointer to one big number
+ * @param[in] word length of a
+ * @param[in] b pointer to another big number
+ * @param[in]  word length of b
+ * @return Cmp_UNEQUAL:a!=b;Cmp_EQUAL: a==b.
+ * 
+ */
+int32_t Cmp_U8(const uint8_t *a, uint32_t aByteLen, const uint8_t *b, uint32_t bByteLen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/include/psa/cm32m4xxr_des.h b/include/psa/cm32m4xxr_des.h
new file mode 100644
index 00000000..a6d86b77
--- /dev/null
+++ b/include/psa/cm32m4xxr_des.h
@@ -0,0 +1,130 @@
+/*******************************************************************************
+*
+* COPYRIGHT(c) 2020, China Mobile IOT
+*
+* Redistribution and use in source and binary forms, with or without modification,
+* are permitted provided that the following conditions are met:
+*	1. Redistributions of source code must retain the above copyright notice,
+*	   this list of conditions and the following disclaimer.
+*	2. Redistributions in binary form must reproduce the above copyright notice,
+*	   this list of conditions and the following disclaimer in the documentation
+*	   and/or other materials provided with the distribution.
+*	3. Neither the name of China Mobile IOT nor the names of its contributors
+*	   may be used to endorse or promote products derived from this software
+*	   without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*******************************************************************************/
+
+/**
+ * @file cm32m4xxr_des.h
+ * @author CMIOT Firmware Team
+ * @version v1.0.0
+ *
+ * @copyright Copyright (c) 2020, CMIOT. All rights reserved.
+ */
+#ifndef __CM32M4xxR_DES_H__
+#define __CM32M4xxR_DES_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup CM32M4xxR_Algorithm_Library
+ * @{
+ */
+
+/** @addtogroup DES
+ * @brief DES symmetrical cipher algorithm
+ * @{
+ */
+#define DES_ECB		(0x11111111)
+#define DES_CBC		(0x22222222)
+
+
+#define DES_ENC		(0x33333333)
+#define DES_DEC		(0x44444444)
+
+#define DES_KEY		(0x55555555)
+#define TDES_2KEY	(0x66666666)
+#define TDES_3KEY	(0x77777777)
+
+enum DES
+{
+    DES_Crypto_OK        = 0x0,        /* DES/TDES opreation success */
+    DES_Init_OK          = 0x0,        /* DES/TDES Init opreation success */
+    DES_Crypto_ModeError = 0x5a5a5a5a, /* Working mode error(Neither ECB nor CBC) */
+    DES_Crypto_EnOrDeError,            /* En&De error(Neither encryption nor decryption) */
+    DES_Crypto_ParaNull,               /* The part of input(output/iv) Null */
+    DES_Crypto_LengthError,            /* The length of input message must be 2 times and cannot be zero */
+    DES_Crypto_KeyError,               /* KeyMode error(Neither DES_KEY nor TDES_2KEY nor TDES_3KEY) */
+    DES_Crypto_UnInitError,            /* DES/TDES uninitialized */
+};
+
+typedef struct
+{
+    uint32_t* in;         /* The part of input to be encrypted or decrypted */
+    uint32_t* iv;         /* The part of initial vector */
+    uint32_t* out;        /* The part of out */
+    uint32_t* key;        /* The part of key */
+    uint32_t  inWordLen;  /* The length(by word) of plaintext or cipher */
+    uint32_t  En_De;      /* 0x33333333- encrypt, 0x44444444 - decrypt */
+    uint32_t  Mode;       /* 0x11111111 - ECB, 0x22222222 - CBC */
+    uint32_t  keyMode;    /* TDES key mode: 0x55555555-key, 0x66666666-2key, 0x77777777-3key */
+} DES_PARM;
+
+ /**
+ * @brief DES_Init
+ * @return DES_Init_OK, DES/TDES Init success; othets: DES/TDES Init fail
+ * @note    
+ */
+uint32_t DES_Init(DES_PARM* parm);
+
+/**
+ * @brief DES crypto
+ * @param[in] parm pointer to DES/TDES context and the detail please refer to struct DES_PARM in DES.h
+ * @return DES_Crypto_OK, DES/TDES crypto success; othets: DES/TDES crypto fail(reference to the definition by enum variation) 
+ * @note  1.Please refer to the demo in user guidance before using this function  
+ *        2.Input and output can be the same buffer
+ *        3. IV can be NULL when ECB mode
+ *        4. The word lengrh of message must be as times as 2.
+ *        5. If the input is in byte, make sure align by word.
+ */
+uint32_t DES_Crypto(DES_PARM* parm);
+
+/**
+ * @brief DES close
+ * @return none
+ * @note  if you want to close DES algorithm, this function can be recalled.
+ */
+void DES_Close(void);
+
+/**
+ * @brief Get DES/TDES lib version
+ * @param[out] type pointer one byte type information represents the type of the lib, like Commercial version.\
+ * @Bits 0~4 stands for Commercial (C), Security (S), Normal (N), Evaluation (E), Test (T), Bits 5~7 are reserved. e.g. 0x09 stands for CE version.
+ * @param[out] customer pointer one byte customer information represents customer ID. for example, 0x00 stands for standard version, 0x01 is for Tianyu customized version...
+ * @param[out] date pointer array which include three bytes date information. If the returned bytes are 18,9,13,this denotes September 13,2018 
+ * @param[out] version pointer one byte version information represents develop version of the lib. e.g. 0x12 denotes version 1.2.
+ * @return none
+ * @1.You can recall this function to get DES/TDES lib information
+ */
+void DES_Version(uint8_t* type, uint8_t* customer, uint8_t date[3], uint8_t* version);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/include/psa/cm32m4xxr_hash.h b/include/psa/cm32m4xxr_hash.h
new file mode 100644
index 00000000..6e8b584d
--- /dev/null
+++ b/include/psa/cm32m4xxr_hash.h
@@ -0,0 +1,227 @@
+/*******************************************************************************
+*
+* COPYRIGHT(c) 2020, China Mobile IOT
+*
+* Redistribution and use in source and binary forms, with or without modification,
+* are permitted provided that the following conditions are met:
+*	1. Redistributions of source code must retain the above copyright notice,
+*	   this list of conditions and the following disclaimer.
+*	2. Redistributions in binary form must reproduce the above copyright notice,
+*	   this list of conditions and the following disclaimer in the documentation
+*	   and/or other materials provided with the distribution.
+*	3. Neither the name of China Mobile IOT nor the names of its contributors
+*	   may be used to endorse or promote products derived from this software
+*	   without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*******************************************************************************/
+
+/**
+ * @file cm32m4xxr_hash.h
+ * @author CMIOT Firmware Team
+ * @version v1.0.0
+ *
+ * @copyright Copyright (c) 2020, CMIOT. All rights reserved.
+ */
+#ifndef __CM32M4xxR_HASH_H__
+#define __CM32M4xxR_HASH_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup CM32M4xxR_Algorithm_Library
+ * @{
+ */
+
+/** @addtogroup HASH
+ * @brief Message digest algorithms
+ * @{
+ */
+#define  ALG_SHA1		((uint16_t) 0x0004)
+#define  ALG_SHA224		((uint16_t) 0x000A)
+#define  ALG_SHA256		((uint16_t) 0x000B)
+#define  ALG_MD5		((uint16_t) 0x000C)
+#define  ALG_SM3	    ((uint16_t) 0x0012)
+
+enum
+{
+	HASH_SEQUENCE_TRUE	= 0x0105A5A5,	/* Save IV */
+	HASH_SEQUENCE_FALSE = 0x010A5A5A,	/* Not save IV */ 
+	HASH_Init_OK		= 0,			/* Hash init success */
+	HASH_Start_OK		= 0,			/* Hash update success */
+	HASH_Update_OK		= 0,			/* Hash update success */
+	HASH_Complete_OK	= 0,			/* Hash complete success */
+	HASH_Close_OK		= 0,			/* Hash close success */
+	HASH_ByteLenPlus_OK = 0,			/* Byte length plus success */
+	HASH_PadMsg_OK		= 0,			/* Message padding success */
+	HASH_ProcMsgBuf_OK	= 0,			/* Message processing success */
+	SHA1_Hash_OK		= 0,			/* Sha1 operation success */
+	SM3_Hash_OK			= 0,			/* Sm3 operation success */
+	SHA224_Hash_OK		= 0,			/* Sha224 operation success */
+	SHA256_Hash_OK		= 0,			/* Sha256 operation success */
+	MD5_Hash_OK			= 0,			/* MD5 operation success */
+	
+	HASH_Init_ERROR		= 0x01044400,	/* Hash init error */
+	HASH_Start_ERROR,					/* Hash start error */
+	HASH_Update_ERROR,					/* Hash update error */
+	HASH_ByteLenPlus_ERROR,				/* Hash byte plus error */
+};
+
+struct _HASH_CTX_;
+
+typedef struct
+{
+	const uint16_t HashAlgID;								/* Choice hash algorithm */
+	const uint32_t * const K, KLen;							/* K and word length of K */
+	const uint32_t * const IV, IVLen;						/* IV and word length of IV */
+	const uint32_t HASH_SACCR, HASH_HASHCTRL;				/* Relate registers */
+	const uint32_t BlockByteLen, BlockWordLen; 				/* Byte length of block, word length of block */
+	const uint32_t DigestByteLen, DigestWordLen;			/* Byte length of digest,word length of digest */
+	const uint32_t Cycle;									/* Interation times */
+	uint32_t (* const ByteLenPlus)(uint32_t *, uint32_t);	/* Function pointer */
+	uint32_t (* const PadMsg)(struct _HASH_CTX_ *);					/* Function pointer */
+}HASH_ALG;
+
+typedef struct _HASH_CTX_
+{
+	const HASH_ALG	*hashAlg;		/* Pointer to HASH_ALG */
+	uint32_t		sequence;		/* TRUE if the IV should be saved */
+	uint32_t		IV[16]; 
+	uint32_t		msgByteLen[4];
+	uint8_t			msgBuf[128 + 4];
+	uint32_t		msgIdx;
+}HASH_CTX;
+
+extern const HASH_ALG HASH_ALG_SHA1[1];
+extern const HASH_ALG HASH_ALG_SHA224[1];
+extern const HASH_ALG HASH_ALG_SHA256[1];
+extern const HASH_ALG HASH_ALG_MD5[1];
+extern const HASH_ALG HASH_ALG_SM3[1];
+
+/**
+ * @brief  Hash init
+ * @param[in] ctx pointer to HASH_CTX struct
+ * @return HASH_Init_OK,  Hash init success; othets:  Hash init fail
+ * @note   1.Please refer to the demo in user guidance before using this function 
+ */
+uint32_t HASH_Init(HASH_CTX *ctx);
+
+/**
+ * @brief  Hash start
+ * @param[in] ctx pointer to HASH_CTX struct
+ * @return HASH_Start_OK,  Hash start success; othets:  Hash start fail
+ * @note   1.Please refer to the demo in user guidance before using this function 
+ *         2.HASH_Init() should be recalled before use this function 
+ */
+uint32_t HASH_Start(HASH_CTX *ctx);
+
+/**
+ * @brief  Hash update
+ * @param[in] ctx pointer to HASH_CTX struct
+ * @param[in] in pointer to message
+ * @param[out] out pointer tohash result,digest
+ * @return HASH_Update_OK,  Hash update success; othets:  Hash update fail
+ * @note   1.Please refer to the demo in user guidance before using this function 
+ *         2.HASH_Init() and HASH_Start() should be recalled before use this function 
+ */
+uint32_t HASH_Update(HASH_CTX *ctx, uint8_t *in, uint32_t byteLen);
+
+/**
+ * @brief  Hash complete
+ * @param[in] ctx pointer to HASH_CTX struct
+ * @param[out] out pointer tohash result,digest
+ * @return HASH_Complete_OK,  Hash complete success; othets:  Hash complete fail
+ * @note   1.Please refer to the demo in user guidance before using this function 
+ *         2.HASH_Init(), HASH_Start() and HASH_Update() should be recalled before use this function 
+ */
+uint32_t HASH_Complete(HASH_CTX *ctx, uint8_t *out);
+
+/**
+ * @brief  Hash close
+ * @return HASH_Close_OK, Hash close success; othets: Hash close fail
+ * @note   1.Please refer to the demo in user guidance before using this function  
+ */
+uint32_t HASH_Close(void);
+
+/**
+ * @brief  SM3 Hash for 256bits digest
+ * @param[in] in pointer to message
+ * @param[in] byte length of in
+ * @param[out] out pointer tohash result,digest
+ * @return SM3_Hash_OK, SM3 hash success; othets: SM3 hash fail
+ * @note   1.Please refer to the demo in user guidance before using this function  
+ */
+uint32_t SM3_Hash(uint8_t* in,uint32_t byteLen, uint8_t* out);
+
+
+/**
+ * @brief  SHA1 Hash
+ * @param[in] in pointer to message
+ * @param[in] byte length of in
+ * @param[out] out pointer tohash result,digest
+ * @return SHA1_Hash_OK, SHA1 hash success; othets: SHA1 hash fail
+ * @note   1.Please refer to the demo in user guidance before using this function  
+ */
+uint32_t SHA1_Hash(uint8_t* in,uint32_t byteLen, uint8_t* out);
+
+/**
+ * @brief  SHA224 Hash
+ * @param[in] in pointer to message
+ * @param[in] byte length of in
+ * @param[out] out pointer tohash result,digest
+ * @return SHA224_Hash_OK, SHA224 hash success; othets: SHA224 hash fail
+ * @note   1.Please refer to the demo in user guidance before using this function  
+ */
+uint32_t SHA224_Hash(uint8_t* in,uint32_t byteLen, uint8_t* out);
+
+
+/**
+ * @brief  SHA256 Hash
+ * @param[in] in pointer to message
+ * @param[in] byte length of in
+ * @param[out] out pointer tohash result,digest
+ * @return SHA256_Hash_OK, SHA256 hash success; othets: SHA256 hash fail
+ * @note   1.Please refer to the demo in user guidance before using this function  
+ */
+uint32_t SHA256_Hash(uint8_t* in,uint32_t byteLen, uint8_t* out);
+
+/**
+ * @brief  MD5 Hash
+ * @param[in] in pointer to message
+ * @param[in] byte length of in
+ * @param[in] out pointer tohash result,digest
+ * @return MD5_Hash_OK, MD5 hash success; othets: MD5 hash fail
+ * @note   1.Please refer to the demo in user guidance before using this function  
+ */
+uint32_t MD5_Hash(uint8_t* in,uint32_t byteLen, uint8_t* out);
+
+/**
+ * @brief Get HASH lib version
+ * @param[out] type pointer one byte type information represents the type of the lib, like Commercial version.\
+ * @Bits 0~4 stands for Commercial (C), Security (S), Normal (N), Evaluation (E), Test (T), Bits 5~7 are reserved. e.g. 0x09 stands for CE version.
+ * @param[out] customer pointer one byte customer information represents customer ID. for example, 0x00 stands for standard version, 0x01 is for Tianyu customized version...
+ * @param[out] date pointer array which include three bytes date information. If the returned bytes are 18,9,13,this denotes September 13,2018 
+ * @param[out] version pointer one byte version information represents develop version of the lib. e.g. 0x12 denotes version 1.2.
+ * @return none
+ * @1.You can recall this function to get RSA lib information
+ */
+void HASH_Version(uint8_t *type, uint8_t *customer, uint8_t date[3], uint8_t *version);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/include/psa/cm32m4xxr_sm4.h b/include/psa/cm32m4xxr_sm4.h
new file mode 100644
index 00000000..7e8f02d0
--- /dev/null
+++ b/include/psa/cm32m4xxr_sm4.h
@@ -0,0 +1,120 @@
+/*******************************************************************************
+*
+* COPYRIGHT(c) 2020, China Mobile IOT
+*
+* Redistribution and use in source and binary forms, with or without modification,
+* are permitted provided that the following conditions are met:
+*	1. Redistributions of source code must retain the above copyright notice,
+*	   this list of conditions and the following disclaimer.
+*	2. Redistributions in binary form must reproduce the above copyright notice,
+*	   this list of conditions and the following disclaimer in the documentation
+*	   and/or other materials provided with the distribution.
+*	3. Neither the name of China Mobile IOT nor the names of its contributors
+*	   may be used to endorse or promote products derived from this software
+*	   without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*
+*******************************************************************************/
+
+/**
+ * @file cm32m4xxr_sm4.h
+ * @author CMIOT Firmware Team
+ * @version v1.0.0
+ *
+ * @copyright Copyright (c) 2020, CMIOT. All rights reserved.
+ */
+#ifndef __CM32M4xxR_SM4_H__
+#define __CM32M4xxR_SM4_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @addtogroup CM32M4xxR_Algorithm_Library
+ * @{
+ */
+
+/** @addtogroup SM4
+ * @brief SM4 symmetrical cipher algorithm
+ * @{
+ */
+#define SM4_ECB (0x11111111)
+#define SM4_CBC (0x22222222)
+#define SM4_ENC	(0x33333333)
+#define SM4_DEC	(0x44444444)
+enum{
+	SM4_Crypto_OK=0,			/* SM4 opreation success */
+	SM4_Init_OK=0,				/* SM4 Init opreation success */
+	SM4_ADRNULL =0x27A90E35,	/* the address is NULL */
+	SM4_ModeErr,				/* working mode error(Neither ECB nor CBC) */
+	SM4_EnDeErr,				/* En&De error(Neither encryption nor decryption) */
+	SM4_LengthErr,				/* the word length of input error(the word length is 0 or is not as times as 4) */
+	SM4_UnInitError,			/* SM4 uninitialized */
+};
+
+typedef struct{
+	uint32_t *in;			/* the first part of input to be encrypted or decrypted */
+	uint32_t *iv;			/* the first part of initial vector */
+	uint32_t *out;			/* the first part of out */
+	uint32_t *key;			/* the first part of key */
+	uint32_t inWordLen;		/* the word length of input or output */
+	uint32_t EnDeMode;		/* encrypt/decrypt */
+	uint32_t workingMode;	/* ECB/CBC */
+}SM4_PARM;
+
+ /**
+ * @brief SM4_Init
+ * @return SM4_Init_OK, SM4 Init success; othets: SM4 Init fail
+ * @note    
+ */
+uint32_t SM4_Init(SM4_PARM *parm);
+/**
+ * @brief SM4 crypto
+ * @param[in] parm pointer to SM4 context and the detail please refer to struct SM4_PARM in SM4.h
+ * @return SM4_Crypto_OK, SM4 crypto success; othets: SM4 crypto fail(reference to the definition by enum variation) 
+ * @note  1.Please refer to the demo in user guidance before using this function  
+ *        2.Input and output can be the same buffer
+ *        3. IV can be NULL when ECB mode
+ *        4. The word lengrh of message must be as times as 4.
+ *        5. If the input is in byte, make sure align by word.
+ */
+uint32_t SM4_Crypto(SM4_PARM *parm);
+
+
+/**
+ * @brief Close SM4 algorithm
+ * @return none
+ * @note if you want to close SM4 algorithm, this function can be recalled.  
+ */
+void SM4_Close(void);
+
+
+/**
+ * @brief Get SM4 lib version
+ * @param[out] type pointer one byte type information represents the type of the lib, like Commercial version.\
+ * @Bits 0~4 stands for Commercial (C), Security (S), Normal (N), Evaluation (E), Test (T), Bits 5~7 are reserved. e.g. 0x09 stands for CE version.
+ * @param[out] customer pointer one byte customer information represents customer ID. for example, 0x00 stands for standard version, 0x01 is for Tianyu customized version...
+ * @param[out] date pointer array which include three bytes date information. If the returned bytes are 18,9,13,this denotes September 13,2018 
+ * @param[out] version pointer one byte version information represents develop version of the lib. e.g. 0x12 denotes version 1.2.
+ * @return none
+ * @1.You can recall this function to get SM4 lib information
+ */
+void SM4_Version(uint8_t *type, uint8_t *customer, uint8_t date[3], uint8_t *version);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/include/psa/crypto_builtin_primitives.h b/include/psa/crypto_builtin_primitives.h
index 35f3a8b3..752a2db6 100644
--- a/include/psa/crypto_builtin_primitives.h
+++ b/include/psa/crypto_builtin_primitives.h
@@ -45,6 +45,8 @@
 #include "mbedtls/sha1.h"
 #include "mbedtls/sha256.h"
 #include "mbedtls/sha512.h"
+#include "mbedtls/sm3.h"
+
 
 #if defined(MBEDTLS_PSA_BUILTIN_ALG_MD5) || \
     defined(MBEDTLS_PSA_BUILTIN_ALG_RIPEMD160) || \
@@ -52,7 +54,9 @@
     defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224) || \
     defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256) || \
     defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_384) || \
-    defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_512)
+    defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_512) || \
+    defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)
+    
 #define MBEDTLS_PSA_BUILTIN_HASH
 #endif
 
@@ -71,6 +75,9 @@ typedef struct
 #if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_1)
         mbedtls_sha1_context sha1;
 #endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)
+        mbedtls_sm3_context sm3;
+#endif
 #if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256) || \
     defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)
         mbedtls_sha256_context sha256;
diff --git a/include/psa/crypto_driver_contexts_composites.h b/include/psa/crypto_driver_contexts_composites.h
index 3f1c8af4..2fdf9561 100644
--- a/include/psa/crypto_driver_contexts_composites.h
+++ b/include/psa/crypto_driver_contexts_composites.h
@@ -41,6 +41,9 @@
 
 /* Include the context structure definitions for those drivers that were
  * declared during the autogeneration process. */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+#include "cc3xx_crypto_primitives_private.h"
+#endif
 
 #if defined(MBEDTLS_TEST_LIBTESTDRIVER1)
 #include <libtestdriver1/include/psa/crypto.h>
@@ -104,6 +107,9 @@ typedef union {
     mbedtls_transparent_test_driver_mac_operation_t transparent_test_driver_ctx;
     mbedtls_opaque_test_driver_mac_operation_t opaque_test_driver_ctx;
 #endif
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+    cc3xx_mac_operation_t cc3xx_driver_ctx;
+#endif
 } psa_driver_mac_context_t;
 
 typedef union {
@@ -112,6 +118,9 @@ typedef union {
 #if defined(PSA_CRYPTO_DRIVER_TEST)
     mbedtls_transparent_test_driver_aead_operation_t transparent_test_driver_ctx;
 #endif
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+    cc3xx_aead_operation_t cc3xx_driver_ctx;
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 } psa_driver_aead_context_t;
 
 #endif /* PSA_CRYPTO_DRIVER_CONTEXTS_COMPOSITES_H */
diff --git a/include/psa/crypto_driver_contexts_primitives.h b/include/psa/crypto_driver_contexts_primitives.h
index 2bb01ed4..43138ce3 100644
--- a/include/psa/crypto_driver_contexts_primitives.h
+++ b/include/psa/crypto_driver_contexts_primitives.h
@@ -40,6 +40,16 @@
 
 /* Include the context structure definitions for those drivers that were
  * declared during the autogeneration process. */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+#include "cc3xx_crypto_primitives_private.h"
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+#include "cm32m4xxr_hash.h"
+#include "cm32m4xxr_aes.h"
+#include "cm32m4xxr_des.h"
+#include "cm32m4xxr_sm4.h"
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 
 #if defined(MBEDTLS_TEST_LIBTESTDRIVER1)
 #include <libtestdriver1/include/psa/crypto.h>
@@ -102,8 +112,28 @@ typedef union {
 #if defined(PSA_CRYPTO_DRIVER_TEST)
     mbedtls_transparent_test_driver_hash_operation_t test_driver_ctx;
 #endif
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+    cc3xx_hash_operation_t cc3xx_driver_ctx;
+#endif
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+    HASH_CTX riscv_cm32_driver_ctx;
+#endif
 } psa_driver_hash_context_t;
 
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+typedef struct {
+    psa_algorithm_t alg;
+    psa_key_type_t  key_type;
+    size_t          unhandled_data_length;
+    uint32_t        unhandled_data[4];
+    union {
+        AES_PARM aes_ctx;
+        DES_PARM des_ctx;
+        SM4_PARM sm4_ctx;
+    } param;
+}risv_cm32_driver_cipher_context_t;
+#endif
+
 typedef union {
     unsigned dummy; /* Make sure this union is always non-empty */
     mbedtls_psa_cipher_operation_t mbedtls_ctx;
@@ -111,6 +141,12 @@ typedef union {
     mbedtls_transparent_test_driver_cipher_operation_t transparent_test_driver_ctx;
     mbedtls_opaque_test_driver_cipher_operation_t opaque_test_driver_ctx;
 #endif
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+    cc3xx_cipher_operation_t cc3xx_driver_ctx;
+#endif
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+    risv_cm32_driver_cipher_context_t riscv_cm32_driver_ctx;
+#endif
 } psa_driver_cipher_context_t;
 
 #endif /* PSA_CRYPTO_DRIVER_CONTEXTS_PRIMITIVES_H */
diff --git a/include/psa/crypto_extra.h b/include/psa/crypto_extra.h
index 73da364b..9dbda1f2 100644
--- a/include/psa/crypto_extra.h
+++ b/include/psa/crypto_extra.h
@@ -631,6 +631,9 @@ static inline psa_ecc_family_t mbedtls_ecc_group_to_psa( mbedtls_ecp_group_id gr
         case MBEDTLS_ECP_DP_CURVE448:
             *bits = 448;
             return( PSA_ECC_FAMILY_MONTGOMERY );
+        case MBEDTLS_ECP_DP_CURVE_SM2:
+            *bits = 256;
+            return (PSA_ECC_FAMILY_CURVE_SM2);            
         default:
             *bits = 0;
             return( 0 );
diff --git a/include/psa/crypto_sizes.h b/include/psa/crypto_sizes.h
index 1024d6b9..93d5f8a1 100644
--- a/include/psa/crypto_sizes.h
+++ b/include/psa/crypto_sizes.h
@@ -77,6 +77,7 @@
         PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_SHA3_256 ? 32 :       \
         PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_SHA3_384 ? 48 :       \
         PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_SHA3_512 ? 64 :       \
+        PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_SM3      ? 32 :       \
         0)
 
 /** The input block size of a hash algorithm, in bytes.
@@ -109,6 +110,7 @@
         PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_SHA3_256 ? 136 :      \
         PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_SHA3_384 ? 104 :      \
         PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_SHA3_512 ? 72 :       \
+        PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_SM3      ? 64 :       \
         0)
 
 /** \def PSA_HASH_MAX_SIZE
diff --git a/include/psa/crypto_values.h b/include/psa/crypto_values.h
index b3526aef..29180a72 100644
--- a/include/psa/crypto_values.h
+++ b/include/psa/crypto_values.h
@@ -489,6 +489,8 @@
  */
 #define PSA_KEY_TYPE_AES                            ((psa_key_type_t)0x2400)
 
+#define PSA_KEY_TYPE_SM4                            ((psa_key_type_t)0x2405)
+
 /** Key for a cipher, AEAD or MAC algorithm based on the
  * ARIA block cipher. */
 #define PSA_KEY_TYPE_ARIA                           ((psa_key_type_t)0x2406)
@@ -615,6 +617,8 @@
  */
 #define PSA_ECC_FAMILY_SECT_K1           ((psa_ecc_family_t) 0x27)
 
+#define PSA_ECC_FAMILY_CURVE_SM2         ((psa_ecc_family_t) 0x29)
+
 /** SEC random curves over binary fields.
  *
  * This family comprises the following curves:
@@ -918,6 +922,9 @@
  * scenarios where a hash function based on SHA3/SHAKE is desired, SHA3-512
  * has the same output size and a (theoretically) higher security strength.
  */
+/** SM3 */
+#define PSA_ALG_SM3                             ((psa_algorithm_t)0x02000014)
+
 #define PSA_ALG_SHAKE256_512                    ((psa_algorithm_t)0x02000015)
 
 /** In a hash-and-sign algorithm policy, allow any hash algorithm.
diff --git a/library/CMakeLists.txt b/library/CMakeLists.txt
index 0884f57a..345bf474 100644
--- a/library/CMakeLists.txt
+++ b/library/CMakeLists.txt
@@ -40,6 +40,8 @@ set(src_crypto
     gcm.c
     hkdf.c
     hmac_drbg.c
+    lmots.c
+    lms.c
     md.c
     md5.c
     memory_buffer_alloc.c
@@ -82,6 +84,11 @@ set(src_crypto
     timing.c
     version.c
     version_features.c
+    sm2.c
+    sm3.c
+    sm4.c
+    riscv_cm32_psa_hash.c
+    riscv_cm32_psa_cipher.c
 )
 
 set(src_x509
diff --git a/library/Makefile b/library/Makefile
index f5ff474e..dfe76c13 100644
--- a/library/Makefile
+++ b/library/Makefile
@@ -105,6 +105,8 @@ OBJS_CRYPTO= \
 	     gcm.o \
 	     hkdf.o \
 	     hmac_drbg.o \
+	     lmots.o \
+	     lms.o \
 	     md.o \
 	     md5.o \
 	     memory_buffer_alloc.o \
diff --git a/library/bn_mul.h b/library/bn_mul.h
index 962d7a97..20e0e53d 100644
--- a/library/bn_mul.h
+++ b/library/bn_mul.h
@@ -717,10 +717,10 @@
 
 #define MULADDC_X1_CORE                                         \
            ".p2align  2                                 \n\t"   \
-            "ldr.w    %[a], [%[in]], #4                 \n\t"   \
-            "ldr.w    %[b], [%[acc]]                    \n\t"   \
+            "ldr      %[a], [%[in]], #4                 \n\t"   \
+            "ldr      %[b], [%[acc]]                    \n\t"   \
             "umaal    %[b], %[carry], %[scalar], %[a]   \n\t"   \
-            "str.w    %[b], [%[acc]], #4                \n\t"
+            "str      %[b], [%[acc]], #4                \n\t"
 
 #define MULADDC_X1_STOP                                      \
             : [a]      "=&r" (tmp_a),                        \
@@ -751,14 +751,14 @@
              *   2 cycles, while subsequent loads/stores are single-cycle. */
 #define MULADDC_X2_CORE                                           \
            ".p2align  2                                   \n\t"   \
-            "ldr.w    %[a0], [%[in]],  #+8                \n\t"   \
-            "ldr.w    %[b0], [%[acc]], #+8                \n\t"   \
-            "ldr.w    %[a1], [%[in],  #-4]                \n\t"   \
-            "ldr.w    %[b1], [%[acc], #-4]                \n\t"   \
+            "ldr      %[a0], [%[in]],  #+8                \n\t"   \
+            "ldr      %[b0], [%[acc]], #+8                \n\t"   \
+            "ldr      %[a1], [%[in],  #-4]                \n\t"   \
+            "ldr      %[b1], [%[acc], #-4]                \n\t"   \
             "umaal    %[b0], %[carry], %[scalar], %[a0]   \n\t"   \
             "umaal    %[b1], %[carry], %[scalar], %[a1]   \n\t"   \
-            "str.w    %[b0], [%[acc], #-8]                \n\t"   \
-            "str.w    %[b1], [%[acc], #-4]                \n\t"
+            "str      %[b0], [%[acc], #-8]                \n\t"   \
+            "str      %[b1], [%[acc], #-4]                \n\t"
 
 #define MULADDC_X2_STOP                                      \
             : [a0]     "=&r" (tmp_a0),                       \
diff --git a/library/cipher_wrap.c b/library/cipher_wrap.c
index 7da7d9d5..2d00aa99 100644
--- a/library/cipher_wrap.c
+++ b/library/cipher_wrap.c
@@ -36,6 +36,10 @@
 #include "mbedtls/aes.h"
 #endif
 
+#if defined(MBEDTLS_SM4_C)
+#include "mbedtls/sm4.h"
+#endif
+
 #if defined(MBEDTLS_CAMELLIA_C)
 #include "mbedtls/camellia.h"
 #endif
@@ -150,6 +154,128 @@ static int aes_crypt_ofb_wrap( void *ctx, size_t length, size_t *iv_off,
 }
 #endif /* MBEDTLS_CIPHER_MODE_OFB */
 
+#if defined(MBEDTLS_SM4_C)
+static void *sm4_ctx_alloc( void )
+{
+    mbedtls_sm4_context *sm4 = mbedtls_calloc( 1, sizeof( mbedtls_sm4_context ) );
+
+    if( sm4 == NULL )
+        return( NULL );
+
+    mbedtls_sm4_init( sm4 );
+
+    return( sm4 );
+}
+
+static void sm4_ctx_free( void *ctx )
+{
+    mbedtls_sm4_free( (mbedtls_sm4_context *) ctx );
+    mbedtls_free( ctx );
+}
+
+static int sm4_setkey_enc_wrap( void *ctx, const unsigned char *key,
+                                unsigned int key_bitlen )
+{
+    if (key_bitlen) { };
+    return mbedtls_sm4_setkey_enc( (mbedtls_sm4_context *) ctx, key );
+}
+
+static int sm4_setkey_dec_wrap( void *ctx, const unsigned char *key,
+                                unsigned int key_bitlen )
+{
+    if (key_bitlen) { };
+    return mbedtls_sm4_setkey_dec( (mbedtls_sm4_context *) ctx, key );
+}
+
+static int sm4_crypt_ecb_wrap( void *ctx, mbedtls_operation_t operation,
+        const unsigned char *input, unsigned char *output )
+{
+    return mbedtls_sm4_crypt_ecb( (mbedtls_sm4_context *) ctx, operation,
+            input, output );
+}
+
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+static int sm4_crypt_cbc_wrap( void *ctx, mbedtls_operation_t operation,
+        size_t length, unsigned char *iv,
+        const unsigned char *input, unsigned char *output )
+{
+    return mbedtls_sm4_crypt_cbc( (mbedtls_sm4_context *) ctx, operation,
+            length, iv, input, output );
+}
+#endif
+
+#if defined(MBEDTLS_CIPHER_MODE_CTR)
+static int sm4_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,
+        unsigned char *nonce_counter, unsigned char *stream_block,
+        const unsigned char *input, unsigned char *output )
+{
+    return mbedtls_sm4_crypt_ctr( (mbedtls_sm4_context *) ctx, length, nc_off, nonce_counter,
+                          stream_block, input, output );
+}
+#endif
+
+static const mbedtls_cipher_base_t sm4_base_info = {
+    MBEDTLS_CIPHER_ID_SM4,
+    sm4_crypt_ecb_wrap,
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+    sm4_crypt_cbc_wrap,
+#endif
+#if defined(MBEDTLS_CIPHER_MODE_CFB)
+    NULL,
+#endif
+#if defined(MBEDTLS_CIPHER_MODE_OFB)
+    NULL,
+#endif
+#if defined(MBEDTLS_CIPHER_MODE_CTR)
+    sm4_crypt_ctr_wrap,
+#endif
+#if defined(MBEDTLS_CIPHER_MODE_XTS)
+    NULL,
+#endif
+#if defined(MBEDTLS_CIPHER_MODE_STREAM)
+    NULL,
+#endif
+    sm4_setkey_enc_wrap,
+    sm4_setkey_dec_wrap,
+    sm4_ctx_alloc,
+    sm4_ctx_free,
+};
+
+static const mbedtls_cipher_info_t sm4_ecb_info = {
+    MBEDTLS_CIPHER_SM4_ECB,
+    MBEDTLS_MODE_ECB,
+    128,
+    "SM4-ECB",
+    16,
+    0,
+    16,
+    &sm4_base_info,
+};
+
+static const mbedtls_cipher_info_t sm4_cbc_info = {
+    MBEDTLS_CIPHER_SM4_CBC,
+    MBEDTLS_MODE_CBC,
+    128,
+    "SM4-CBC",
+    16,
+    0,
+    16,
+    &sm4_base_info,
+};
+
+static const mbedtls_cipher_info_t sm4_ctr_info = {
+    MBEDTLS_CIPHER_SM4_CTR,
+    MBEDTLS_MODE_CTR,
+    128,
+    "SM4-CTR",
+    16,
+    0,
+    16,
+    &sm4_base_info,
+};
+
+#endif
+
 #if defined(MBEDTLS_CIPHER_MODE_CTR)
 static int aes_crypt_ctr_wrap( void *ctx, size_t length, size_t *nc_off,
         unsigned char *nonce_counter, unsigned char *stream_block,
@@ -211,6 +337,7 @@ static void * aes_ctx_alloc( void )
     return( aes );
 }
 
+
 static void aes_ctx_free( void *ctx )
 {
     mbedtls_aes_free( (mbedtls_aes_context *) ctx );
@@ -1751,6 +1878,18 @@ static const mbedtls_cipher_info_t des_ede3_ecb_info = {
     8,
     &des_ede3_info
 };
+
+static const mbedtls_cipher_info_t des_ede3_ctr_info = {
+    MBEDTLS_CIPHER_DES_EDE3_CTR,
+    MBEDTLS_MODE_CTR,
+    MBEDTLS_KEY_LENGTH_DES_EDE3,
+    "DES-EDE3-CTR",
+    16,
+    0,
+    16,
+    &des_ede3_info
+};
+
 #if defined(MBEDTLS_CIPHER_MODE_CBC)
 static const mbedtls_cipher_info_t des_ede3_cbc_info = {
     MBEDTLS_CIPHER_DES_EDE3_CBC,
@@ -2237,6 +2376,9 @@ const mbedtls_cipher_definition_t mbedtls_cipher_definitions[] =
     { MBEDTLS_CIPHER_DES_EDE_CBC,          &des_ede_cbc_info },
     { MBEDTLS_CIPHER_DES_EDE3_CBC,         &des_ede3_cbc_info },
 #endif
+#if defined(MBEDTLS_CIPHER_MODE_CTR)
+    { MBEDTLS_CIPHER_DES_EDE3_CTR,         &des_ede3_ctr_info },
+#endif
 #endif /* MBEDTLS_DES_C */
 
 #if defined(MBEDTLS_CHACHA20_C)
@@ -2256,6 +2398,16 @@ const mbedtls_cipher_definition_t mbedtls_cipher_definitions[] =
     { MBEDTLS_CIPHER_AES_256_KWP,         &aes_256_nist_kwp_info },
 #endif
 
+#if defined(MBEDTLS_SM4_C)
+    { MBEDTLS_CIPHER_SM4_ECB,              &sm4_ecb_info, },
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+    { MBEDTLS_CIPHER_SM4_CBC,              &sm4_cbc_info, },
+#endif
+#if defined(MBEDTLS_CIPHER_MODE_CTR)
+    { MBEDTLS_CIPHER_SM4_CTR,              &sm4_ctr_info, },
+#endif    
+#endif /* MBEDTLS_SM4_C */
+
 #if defined(MBEDTLS_CIPHER_NULL_CIPHER)
     { MBEDTLS_CIPHER_NULL,                 &null_cipher_info },
 #endif /* MBEDTLS_CIPHER_NULL_CIPHER */
diff --git a/library/code_share.c b/library/code_share.c
new file mode 100644
index 00000000..2bf67fb4
--- /dev/null
+++ b/library/code_share.c
@@ -0,0 +1,3 @@
+/* This is a deliberately empty file just to check whether the patch for enabling
+ * extensive crypto code sharing was already applied on the mbedtls library.
+ */
diff --git a/library/ecp.c b/library/ecp.c
index 67c46f2c..de60ef07 100644
--- a/library/ecp.c
+++ b/library/ecp.c
@@ -406,6 +406,9 @@ static const mbedtls_ecp_curve_info ecp_supported_curves[] =
 #endif
 #if defined(MBEDTLS_ECP_DP_CURVE448_ENABLED)
     { MBEDTLS_ECP_DP_CURVE448,     30,     448,    "x448"              },
+#endif    
+#if defined(MBEDTLS_ECP_DP_CURVE_SM2_ENABLED)
+    {MBEDTLS_ECP_DP_CURVE_SM2,     41,     256,     "curve_SM2"        },    
 #endif
     { MBEDTLS_ECP_DP_NONE,          0,     0,      NULL                },
 };
diff --git a/library/ecp_curves.c b/library/ecp_curves.c
index 51956cd5..410c090a 100644
--- a/library/ecp_curves.c
+++ b/library/ecp_curves.c
@@ -64,6 +64,7 @@
     defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)   ||   \
     defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) ||   \
     defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) ||   \
+    defined(MBEDTLS_ECP_DP_CURVE_SM2_ENABLED) ||   \
     defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
 /* For these curves, we build the group parameters dynamically. */
 #define ECP_LOAD_GROUP
@@ -2189,6 +2190,46 @@ static const mbedtls_ecp_point secp521r1_T[32] = {
 #endif
 #endif /* MBEDTLS_ECP_DP_SECP521R1_ENABLED */
 
+#if defined(MBEDTLS_ECP_DP_CURVE_SM2_ENABLED)
+static const mbedtls_mpi_uint curve_sm2_p[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8(0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF),
+    MBEDTLS_BYTES_TO_T_UINT_8(0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF),
+    MBEDTLS_BYTES_TO_T_UINT_8(0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF),
+};
+static const mbedtls_mpi_uint curve_sm2_a[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8(0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF),
+    MBEDTLS_BYTES_TO_T_UINT_8(0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF),
+    MBEDTLS_BYTES_TO_T_UINT_8(0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF),
+};
+static const mbedtls_mpi_uint curve_sm2_b[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8(0x93, 0x0E, 0x94, 0x4D, 0x41, 0xBD, 0xBC, 0xDD),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x92, 0x8F, 0xAB, 0x15, 0xF5, 0x89, 0x97, 0xF3),
+    MBEDTLS_BYTES_TO_T_UINT_8(0xA7, 0x09, 0x65, 0xCF, 0x4B, 0x9E, 0x5A, 0x4D),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x34, 0x5E, 0x9F, 0x9D, 0x9E, 0xFA, 0xE9, 0x28),
+};
+static const mbedtls_mpi_uint curve_sm2_gx[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8(0xC7, 0x74, 0x4C, 0x33, 0x89, 0x45, 0x5A, 0x71),
+    MBEDTLS_BYTES_TO_T_UINT_8(0xE1, 0x0B, 0x66, 0xF2, 0xBF, 0x0B, 0xE3, 0x8F),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x94, 0xC9, 0x39, 0x6A, 0x46, 0x04, 0x99, 0x5F),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x19, 0x81, 0x19, 0x1F, 0x2C, 0xAE, 0xC4, 0x32),
+};
+static const mbedtls_mpi_uint curve_sm2_gy[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8(0xA0, 0xF0, 0x39, 0x21, 0xE5, 0x32, 0xDF, 0x02),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x40, 0x47, 0x2A, 0xC6, 0x7C, 0x87, 0xA9, 0xD0),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x53, 0x21, 0x69, 0x6B, 0xE3, 0xCE, 0xBD, 0x59),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x9C, 0x77, 0xF6, 0xF4, 0xA2, 0x36, 0x37, 0xBC),
+};
+static const mbedtls_mpi_uint curve_sm2_n[] = {
+    MBEDTLS_BYTES_TO_T_UINT_8(0x23, 0x41, 0xD5, 0x39, 0x09, 0xF4, 0xBB, 0x53),
+    MBEDTLS_BYTES_TO_T_UINT_8(0x2B, 0x05, 0xC6, 0x21, 0x6B, 0xDF, 0x03, 0x72),
+    MBEDTLS_BYTES_TO_T_UINT_8(0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF),
+    MBEDTLS_BYTES_TO_T_UINT_8(0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF),
+};
+#define curve_sm2_T NULL
+#endif /* MBEDTLS_ECP_DP_CURVE_SM2_ENABLED */
+
 #if defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED)
 static const mbedtls_mpi_uint secp192k1_p[] = {
     MBEDTLS_BYTES_TO_T_UINT_8( 0x37, 0xEE, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF ),
@@ -4818,6 +4859,11 @@ int mbedtls_ecp_group_load( mbedtls_ecp_group *grp, mbedtls_ecp_group_id id )
             return( ecp_use_curve448( grp ) );
 #endif /* MBEDTLS_ECP_DP_CURVE448_ENABLED */
 
+#if defined(MBEDTLS_ECP_DP_CURVE_SM2_ENABLED)
+    case MBEDTLS_ECP_DP_CURVE_SM2:
+        return (LOAD_GROUP(curve_sm2));
+#endif /* MBEDTLS_ECP_DP_CURVE_SM2_ENABLED */
+
         default:
             grp->id = MBEDTLS_ECP_DP_NONE;
             return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
diff --git a/library/lmots.c b/library/lmots.c
new file mode 100644
index 00000000..7319d29b
--- /dev/null
+++ b/library/lmots.c
@@ -0,0 +1,684 @@
+/*
+ * The LM-OTS one-time public-key signature scheme
+ *
+ * Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+/*
+ *  The following sources were referenced in the design of this implementation
+ *  of the LM-OTS algorithm:
+ *
+ *  [1] IETF RFC8554
+ *      D. McGrew, M. Curcio, S.Fluhrer
+ *      https://datatracker.ietf.org/doc/html/rfc8554
+ *
+ *  [2] NIST Special Publication 800-208
+ *      David A. Cooper et. al.
+ *      https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-208.pdf
+ */
+
+#include "common.h"
+
+#ifdef MBEDTLS_LMOTS_C
+
+#include <string.h>
+
+#include "mbedtls/lmots.h"
+#include "mbedtls/md.h"
+#include "mbedtls/platform_util.h"
+#include "mbedtls/error.h"
+
+#define W_SYMBOL_BIT_LEN      (8)
+#define CHECKSUM_LEN          (2)
+#define I_SYMBOL_IDX_LEN      (2)
+#define J_HASH_IDX_LEN        (1)
+#define D_CONST_LEN           (2)
+
+#define SYMBOL_MAX_VAL        ((1 << W_SYMBOL_BIT_LEN) - 1)
+
+#define D_PBLC_CONSTANT       (0x8080)
+#define D_MESG_CONSTANT       (0x8181)
+
+static void val_to_network_bytes(unsigned int val, size_t len, unsigned char *bytes)
+{
+    size_t idx;
+
+    for (idx = 0; idx < len; idx++) {
+        bytes[idx] = (val >> ((len - 1 - idx) * 8)) & 0xFF;
+    }
+}
+
+static unsigned int network_bytes_to_val(size_t len, const unsigned char *bytes)
+{
+    size_t idx;
+    unsigned int val = 0;
+
+    for (idx = 0; idx < len; idx++) {
+        val |= ((unsigned int)bytes[idx]) << (8 * (len - 1 - idx));
+    }
+
+    return val;
+}
+
+static unsigned short lmots_checksum_generate( const unsigned char* digest )
+{
+    size_t idx;
+    unsigned short sum = 0;
+
+    for ( idx = 0; idx < MBEDTLS_LMOTS_N_HASH_LEN; idx++ )
+    {
+        sum += ( 1 << W_SYMBOL_BIT_LEN ) - 1 - digest[idx];
+    }
+
+    return sum;
+}
+
+static int create_symbol_array( const unsigned char I_key_identifier[MBEDTLS_LMOTS_I_KEY_ID_LEN],
+                                const unsigned char q_leaf_identifier[MBEDTLS_LMOTS_Q_LEAF_ID_LEN],
+                                const unsigned char *msg,
+                                size_t msg_len,
+                                const unsigned char C_random_value[MBEDTLS_LMOTS_C_RANDOM_VALUE_LEN],
+                                unsigned char out[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN] )
+{
+    mbedtls_md_context_t hash_ctx;
+    unsigned char D_MESG_BYTES[D_CONST_LEN];
+    unsigned short checksum;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    mbedtls_md_init( &hash_ctx );
+    ret = mbedtls_md_setup( &hash_ctx, mbedtls_md_info_from_type( MBEDTLS_MD_SHA256 ), 0 );
+    if( ret )
+    {
+        goto out;
+    }
+    ret = mbedtls_md_starts( &hash_ctx );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, I_key_identifier, MBEDTLS_LMOTS_I_KEY_ID_LEN );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, q_leaf_identifier, MBEDTLS_LMOTS_Q_LEAF_ID_LEN );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    val_to_network_bytes( D_MESG_CONSTANT, D_CONST_LEN, D_MESG_BYTES );
+    ret = mbedtls_md_update( &hash_ctx, D_MESG_BYTES, sizeof( D_MESG_BYTES ) );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, C_random_value, MBEDTLS_LMOTS_C_RANDOM_VALUE_LEN );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, msg, msg_len );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_finish( &hash_ctx, out );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    checksum = lmots_checksum_generate( out );
+    val_to_network_bytes( checksum, CHECKSUM_LEN, out + MBEDTLS_LMOTS_N_HASH_LEN );
+
+out:
+    mbedtls_md_free( &hash_ctx );
+
+    return( ret );
+}
+
+static int hash_symbol_array( const unsigned char I_key_identifier[MBEDTLS_LMOTS_I_KEY_ID_LEN],
+                              const unsigned char q_leaf_identifier[MBEDTLS_LMOTS_Q_LEAF_ID_LEN],
+                              const unsigned char x_symbol_array[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN][32],
+                              const unsigned char hash_idx_min_values[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN],
+                              const unsigned char hash_idx_max_values[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN],
+                              unsigned char output[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN][32] )
+{
+    unsigned char i_symbol_idx;
+    unsigned char j_hash_idx;
+    unsigned char i_symbol_idx_bytes[I_SYMBOL_IDX_LEN];
+    unsigned char j_hash_idx_bytes[1];
+    unsigned short j_hash_idx_min;
+    unsigned short j_hash_idx_max;
+    mbedtls_md_context_t hash_ctx;
+    unsigned char tmp_hash[32];
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    for ( i_symbol_idx = 0; i_symbol_idx < MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN; i_symbol_idx++ )
+    {
+
+        memcpy( tmp_hash, &x_symbol_array[i_symbol_idx], MBEDTLS_LMOTS_N_HASH_LEN );
+
+        j_hash_idx_min = hash_idx_min_values != NULL ? hash_idx_min_values[i_symbol_idx] : 0;
+        j_hash_idx_max = hash_idx_max_values != NULL ? hash_idx_max_values[i_symbol_idx] : SYMBOL_MAX_VAL;
+
+        for ( j_hash_idx = (unsigned char)j_hash_idx_min; j_hash_idx < j_hash_idx_max; j_hash_idx++ )
+        {
+            mbedtls_md_init( &hash_ctx );
+            ret = mbedtls_md_setup( &hash_ctx, mbedtls_md_info_from_type( MBEDTLS_MD_SHA256 ), 0 );
+            if( ret )
+            {
+                goto out;
+            }
+            ret = mbedtls_md_starts( &hash_ctx );
+            if ( ret )
+            {
+                goto out;
+            }
+
+            ret = mbedtls_md_update( &hash_ctx, I_key_identifier, MBEDTLS_LMOTS_I_KEY_ID_LEN );
+            if ( ret )
+            {
+                goto out;
+            }
+
+            ret = mbedtls_md_update( &hash_ctx, q_leaf_identifier, MBEDTLS_LMOTS_Q_LEAF_ID_LEN );
+            if ( ret )
+            {
+                goto out;
+            }
+
+            val_to_network_bytes( i_symbol_idx, I_SYMBOL_IDX_LEN, i_symbol_idx_bytes );
+            ret = mbedtls_md_update( &hash_ctx, i_symbol_idx_bytes, I_SYMBOL_IDX_LEN );
+            if ( ret )
+            {
+                goto out;
+            }
+
+            val_to_network_bytes( j_hash_idx, J_HASH_IDX_LEN, j_hash_idx_bytes );
+            ret = mbedtls_md_update( &hash_ctx, j_hash_idx_bytes, J_HASH_IDX_LEN );
+            if ( ret )
+            {
+                goto out;
+            }
+
+            ret = mbedtls_md_update( &hash_ctx, tmp_hash, MBEDTLS_LMOTS_N_HASH_LEN );
+            if ( ret )
+            {
+                goto out;
+            }
+
+            ret = mbedtls_md_finish( &hash_ctx, tmp_hash );
+            if ( ret )
+            {
+                goto out;
+            }
+
+            mbedtls_md_free( &hash_ctx );
+        }
+
+        memcpy( &output[i_symbol_idx], tmp_hash, MBEDTLS_LMOTS_N_HASH_LEN );
+    }
+
+out:
+    if( ret )
+    {
+        mbedtls_md_free( &hash_ctx );
+        return( ret );
+    }
+
+    return ret;
+}
+
+static int public_key_from_hashed_symbol_array( const unsigned char I_key_identifier[MBEDTLS_LMOTS_I_KEY_ID_LEN],
+                                                const unsigned char q_leaf_identifier[MBEDTLS_LMOTS_Q_LEAF_ID_LEN],
+                                                const unsigned char  y_hashed_symbols[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN][32],
+                                                unsigned char *pub_key )
+{
+    unsigned char D_PBLC_bytes[D_CONST_LEN];
+    mbedtls_md_context_t hash_ctx;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    mbedtls_md_init( &hash_ctx );
+    ret = mbedtls_md_setup( &hash_ctx, mbedtls_md_info_from_type( MBEDTLS_MD_SHA256 ), 0 );
+    if( ret )
+    {
+        goto out;
+    }
+    ret = mbedtls_md_starts( &hash_ctx );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, I_key_identifier,
+                             MBEDTLS_LMOTS_I_KEY_ID_LEN );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, q_leaf_identifier,
+                             MBEDTLS_LMOTS_Q_LEAF_ID_LEN );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    val_to_network_bytes( D_PBLC_CONSTANT, D_CONST_LEN, D_PBLC_bytes );
+    ret = mbedtls_md_update( &hash_ctx, D_PBLC_bytes, D_CONST_LEN );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, ( unsigned char * )y_hashed_symbols,
+                             MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN * MBEDTLS_LMOTS_N_HASH_LEN );
+    if ( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_finish( &hash_ctx, pub_key );
+
+out:
+    mbedtls_md_free( &hash_ctx );
+    return( ret );
+}
+
+void mbedtls_lmots_init( mbedtls_lmots_context *ctx )
+{
+    if( ctx == NULL ) {
+        return;
+    }
+
+    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_lmots_context  ) ) ;
+}
+
+void mbedtls_lmots_free( mbedtls_lmots_context *ctx )
+{
+    if( ctx == NULL )
+    {
+        return;
+    }
+
+    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_lmots_context  ) ) ;
+}
+
+int mbedtls_lmots_set_algorithm_type( mbedtls_lmots_context *ctx,
+                                      mbedtls_lmots_algorithm_type_t type )
+{
+    if( ctx == NULL )
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    ctx->MBEDTLS_PRIVATE(type) = type;
+
+    return( 0 );
+}
+
+int mbedtls_lmots_generate_pub_key_candidate( const unsigned char I_key_identifier[MBEDTLS_LMOTS_I_KEY_ID_LEN],
+                                              const unsigned char q_leaf_identifier[MBEDTLS_LMOTS_Q_LEAF_ID_LEN],
+                                              const unsigned char  *msg,
+                                              size_t msg_len,
+                                              const unsigned char *sig,
+                                              unsigned char *out )
+{
+    unsigned char tmp_symbol_array[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN];
+    unsigned char y_hashed_symbols[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN][32];
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if (I_key_identifier == NULL || msg == NULL || sig == NULL || out == NULL)
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    ret = create_symbol_array( I_key_identifier, q_leaf_identifier, msg, msg_len,
+                               sig + MBEDTLS_LMOTS_SIG_C_RANDOM_OFFSET, tmp_symbol_array );
+    if ( ret )
+    {
+        return ( ret );
+    }
+
+    ret = hash_symbol_array( I_key_identifier, q_leaf_identifier,
+                             ( const unsigned char( *)[32] )(sig + MBEDTLS_LMOTS_SIG_SIGNATURE_OFFSET),
+                             tmp_symbol_array, NULL, y_hashed_symbols );
+    if ( ret )
+    {
+        return ( ret );
+    }
+
+    ret = public_key_from_hashed_symbol_array( I_key_identifier, q_leaf_identifier,
+                                               ( const unsigned char( *)[32] )y_hashed_symbols,
+                                               out );
+    if ( ret )
+    {
+        return ( ret );
+    }
+
+    return( 0 );
+}
+
+int mbedtls_lmots_sign( mbedtls_lmots_context *ctx,
+                        int (*f_rng)(void *, unsigned char *, size_t),
+                        void *p_rng, const unsigned char *msg, size_t msg_len,
+                        unsigned char *sig )
+{
+    unsigned char tmp_symbol_array[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN];
+    unsigned char tmp_sig[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN][MBEDTLS_LMOTS_N_HASH_LEN];
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( ctx == NULL || f_rng == NULL || p_rng == NULL || msg == NULL || sig == NULL)
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    /* Check that a private key is loaded */
+    if ( !ctx->MBEDTLS_PRIVATE(have_privkey) )
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    ret = f_rng( p_rng, sig + MBEDTLS_LMOTS_SIG_C_RANDOM_OFFSET, MBEDTLS_LMOTS_N_HASH_LEN );
+    if ( ret )
+    {
+        return( ret );
+    }
+
+    ret = create_symbol_array( ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                               ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes),
+                               msg, msg_len, sig + MBEDTLS_LMOTS_SIG_C_RANDOM_OFFSET,
+                               tmp_symbol_array );
+    if ( ret )
+    {
+        return( ret );
+    }
+
+    ret = hash_symbol_array( ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                             ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes),
+                             ( const unsigned char( *)[32] )(ctx->MBEDTLS_PRIVATE(priv_key)),
+                             NULL, tmp_symbol_array, tmp_sig );
+    if ( ret )
+    {
+        return( ret );
+    }
+
+    val_to_network_bytes( ctx->MBEDTLS_PRIVATE(type), MBEDTLS_LMOTS_TYPE_LEN,
+                          sig + MBEDTLS_LMOTS_SIG_TYPE_OFFSET );
+
+    /* We've got a valid signature now, so it's time to make sure the private
+     * key can't be reused.
+     */
+    ctx->MBEDTLS_PRIVATE(have_privkey) = 0;
+    mbedtls_platform_zeroize(ctx->MBEDTLS_PRIVATE(priv_key),
+                             sizeof(ctx->MBEDTLS_PRIVATE(priv_key)));
+
+    memcpy(sig + MBEDTLS_LMOTS_SIG_SIGNATURE_OFFSET, tmp_sig,
+           MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN * MBEDTLS_LMOTS_N_HASH_LEN);
+
+    return( 0 );
+}
+
+int mbedtls_lmots_verify( mbedtls_lmots_context *ctx, const unsigned char *msg,
+                          size_t msg_len, const unsigned char *sig )
+{
+    unsigned char Kc_public_key_candidate[32];
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( ctx == NULL || msg == NULL || sig == NULL)
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    if ( !ctx->MBEDTLS_PRIVATE(have_pubkey) )
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(type ) != MBEDTLS_LMOTS_SHA256_N32_W8 )
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    if ( network_bytes_to_val( MBEDTLS_LMOTS_TYPE_LEN,
+                               sig + MBEDTLS_LMOTS_SIG_TYPE_OFFSET ) != MBEDTLS_LMOTS_SHA256_N32_W8 )
+    {
+        return( MBEDTLS_ERR_LMOTS_VERIFY_FAILED );
+    }
+
+    ret = mbedtls_lmots_generate_pub_key_candidate( ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                                                    ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes),
+                                                    msg, msg_len, sig,
+                                                    Kc_public_key_candidate );
+    if ( ret )
+    {
+        return( ret );
+    }
+
+    if ( memcmp( &Kc_public_key_candidate, ctx->MBEDTLS_PRIVATE(pub_key),
+                 sizeof( ctx->MBEDTLS_PRIVATE(pub_key) ) ) )
+    {
+        return( MBEDTLS_ERR_LMOTS_VERIFY_FAILED );
+    }
+
+    return( 0 );
+}
+
+int mbedtls_lmots_import_pubkey( mbedtls_lmots_context *ctx,
+                                 const unsigned char *key )
+{
+    if ( ctx == NULL || key == NULL)
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    ctx->MBEDTLS_PRIVATE(type) = network_bytes_to_val( MBEDTLS_LMOTS_TYPE_LEN,
+                                                       key + MBEDTLS_LMOTS_SIG_TYPE_OFFSET );
+
+    memcpy( ctx->MBEDTLS_PRIVATE(I_key_identifier), key + MBEDTLS_LMOTS_PUBKEY_I_KEY_ID_OFFSET,
+            MBEDTLS_LMOTS_I_KEY_ID_LEN );
+
+    memcpy( ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes), key + MBEDTLS_LMOTS_PUBKEY_Q_LEAF_ID_OFFSET,
+            MBEDTLS_LMOTS_Q_LEAF_ID_LEN );
+    ctx->MBEDTLS_PRIVATE(q_leaf_identifier) = network_bytes_to_val( MBEDTLS_LMOTS_Q_LEAF_ID_LEN,
+                                                                    ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes) );
+
+    memcpy( ctx->MBEDTLS_PRIVATE(pub_key), key + MBEDTLS_LMOTS_PUBKEY_KEY_HASH_OFFSET, MBEDTLS_LMOTS_N_HASH_LEN );
+
+    ctx->MBEDTLS_PRIVATE(have_pubkey) = 1;
+
+    return( 0 );
+}
+
+int mbedtls_lmots_export_pubkey( mbedtls_lmots_context *ctx,
+                                 unsigned char *key )
+{
+    if ( ctx == NULL || key == NULL)
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    if ( ! ctx->MBEDTLS_PRIVATE(have_pubkey) )
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    val_to_network_bytes( ctx->MBEDTLS_PRIVATE(type), MBEDTLS_LMOTS_TYPE_LEN,
+                          key + MBEDTLS_LMOTS_SIG_TYPE_OFFSET );
+
+    memcpy( key + MBEDTLS_LMOTS_PUBKEY_I_KEY_ID_OFFSET, ctx->MBEDTLS_PRIVATE(I_key_identifier),
+            MBEDTLS_LMOTS_I_KEY_ID_LEN );
+
+    memcpy( key + MBEDTLS_LMOTS_PUBKEY_Q_LEAF_ID_OFFSET, ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes),
+            MBEDTLS_LMOTS_Q_LEAF_ID_LEN );
+
+    memcpy( key + MBEDTLS_LMOTS_PUBKEY_KEY_HASH_OFFSET, ctx->MBEDTLS_PRIVATE(pub_key),
+            MBEDTLS_LMOTS_N_HASH_LEN );
+
+    return( 0 );
+}
+
+
+int mbedtls_lmots_gen_pubkey( mbedtls_lmots_context *ctx )
+{
+    unsigned char y_hashed_symbols[MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN][32];
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( ctx == NULL )
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    /* Check that a private key is loaded */
+    if ( !ctx->MBEDTLS_PRIVATE(have_privkey) )
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    ret = hash_symbol_array( ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                             ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes),
+                             ( const unsigned char( *)[32] )(ctx->MBEDTLS_PRIVATE(priv_key)),
+                             NULL, NULL, y_hashed_symbols );
+    if ( ret )
+    {
+        return( ret );
+    }
+
+    ret = public_key_from_hashed_symbol_array( ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                                               ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes),
+                                               ( const unsigned char( *)[32] )y_hashed_symbols,
+                                               ctx->MBEDTLS_PRIVATE(pub_key) );
+    if ( ret )
+    {
+        return( ret );
+    }
+
+    ctx->MBEDTLS_PRIVATE(have_pubkey = 1);
+
+    return( ret );
+}
+
+int mbedtls_lmots_gen_privkey( mbedtls_lmots_context *ctx,
+                               const unsigned char I_key_identifier[MBEDTLS_LMOTS_I_KEY_ID_LEN],
+                               unsigned int q_leaf_identifier,
+                               const unsigned char *seed,
+                               size_t seed_len )
+{
+    mbedtls_md_context_t hash_ctx;
+    unsigned int i_symbol_idx;
+    unsigned char i_symbol_idx_bytes[2];
+    unsigned char const_bytes[1];
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( ctx == NULL || I_key_identifier == NULL || seed == NULL)
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    if ( ctx->MBEDTLS_PRIVATE(have_privkey) )
+    {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    if ( ctx->MBEDTLS_PRIVATE(type) != MBEDTLS_LMOTS_SHA256_N32_W8 ) {
+        return( MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA );
+    }
+
+    memcpy( ctx->MBEDTLS_PRIVATE(I_key_identifier), I_key_identifier,
+            sizeof( ctx->MBEDTLS_PRIVATE(I_key_identifier) ) );
+
+    ctx->MBEDTLS_PRIVATE(q_leaf_identifier) = q_leaf_identifier;
+
+    val_to_network_bytes( ctx->MBEDTLS_PRIVATE(q_leaf_identifier), MBEDTLS_LMOTS_Q_LEAF_ID_LEN,
+                          ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes) );
+
+    val_to_network_bytes( 0xFF, sizeof( const_bytes ), const_bytes );
+
+    for ( i_symbol_idx = 0; i_symbol_idx < MBEDTLS_LMOTS_P_SIG_SYMBOL_LEN; i_symbol_idx++ )
+    {
+        mbedtls_md_init( &hash_ctx );
+        ret = mbedtls_md_setup( &hash_ctx, mbedtls_md_info_from_type( MBEDTLS_MD_SHA256 ), 0 );
+        if( ret )
+        {
+            goto out;
+        }
+        ret = mbedtls_md_starts( &hash_ctx );
+        if ( ret )
+        {
+            goto out;
+        }
+
+        ret = mbedtls_md_update( &hash_ctx, ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                                 sizeof( ctx->MBEDTLS_PRIVATE(I_key_identifier) ) );
+        if ( ret ) {
+            goto out;
+        }
+
+        ret = mbedtls_md_update( &hash_ctx, ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes),
+                                 sizeof( ctx->MBEDTLS_PRIVATE(q_leaf_identifier_bytes) ) );
+        if ( ret )
+        {
+            goto out;
+        }
+
+        val_to_network_bytes( i_symbol_idx, I_SYMBOL_IDX_LEN, i_symbol_idx_bytes );
+        ret = mbedtls_md_update( &hash_ctx, i_symbol_idx_bytes, I_SYMBOL_IDX_LEN );
+        if ( ret )
+        {
+            goto out;
+        }
+
+        ret = mbedtls_md_update( &hash_ctx, const_bytes, sizeof( const_bytes) );
+        if ( ret )
+        {
+            goto out;
+        }
+
+        ret = mbedtls_md_update( &hash_ctx, seed, seed_len );
+        if ( ret )
+        {
+            goto out;
+        }
+
+        ret = mbedtls_md_finish( &hash_ctx, ctx->MBEDTLS_PRIVATE(priv_key)[i_symbol_idx] );
+        if ( ret )
+        {
+            goto out;
+        }
+
+        mbedtls_md_free( &hash_ctx);
+    }
+
+    ctx->MBEDTLS_PRIVATE(have_privkey) = 1;
+
+out:
+    if( ret )
+    {
+        mbedtls_md_free( &hash_ctx );
+        return( ret );
+    }
+
+    return ret;
+}
+
+#endif /* MBEDTLS_LMOTS_C */
diff --git a/library/lms.c b/library/lms.c
new file mode 100644
index 00000000..e1ac7b93
--- /dev/null
+++ b/library/lms.c
@@ -0,0 +1,718 @@
+/*
+ *  The LMS stateful-hash public-key signature scheme
+ *
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+/*
+ *  The following sources were referenced in the design of this implementation
+ *  of the LMS algorithm:
+ *
+ *  [1] IETF RFC8554
+ *      D. McGrew, M. Curcio, S.Fluhrer
+ *      https://datatracker.ietf.org/doc/html/rfc8554
+ *
+ *  [2] NIST Special Publication 800-208
+ *      David A. Cooper et. al.
+ *      https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-208.pdf
+ */
+
+#include "common.h"
+
+#ifdef MBEDTLS_LMS_C
+
+#include <string.h>
+
+#include "mbedtls/lms.h"
+#include "mbedtls/lmots.h"
+#include "mbedtls/md.h"
+#include "mbedtls/error.h"
+#include "mbedtls/platform_util.h"
+
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
+#include <stdlib.h>
+#include <stdio.h>
+#define mbedtls_printf printf
+#define mbedtls_calloc calloc
+#define mbedtls_free   free
+#endif
+
+#define MERKLE_TREE_NODE_AM (1 << (MBEDTLS_LMS_H_TREE_HEIGHT + 1))
+#define MERKLE_TREE_LEAF_AM (1 << MBEDTLS_LMS_H_TREE_HEIGHT)
+#define MERKLE_TREE_INTR_AM (1 << MBEDTLS_LMS_H_TREE_HEIGHT)
+
+#define D_CONST_LEN           (2)
+
+#define D_LEAF_CONSTANT     (0x8282)
+#define D_INTR_CONSTANT     (0x8383)
+
+static void val_to_network_bytes(unsigned int val, size_t len, unsigned char *bytes)
+{
+    size_t idx;
+
+    for (idx = 0; idx < len; idx++) {
+        bytes[idx] = (val >> ((len - 1 - idx) * 8)) & 0xFF;
+    }
+}
+
+static unsigned int network_bytes_to_val(size_t len, const unsigned char *bytes)
+{
+    size_t idx;
+    unsigned int val = 0;
+
+    for (idx = 0; idx < len; idx++) {
+        val |= ((unsigned int)bytes[idx]) << (8 * (len - 1 - idx));
+    }
+
+    return val;
+}
+
+static int create_merkle_leaf_node( const mbedtls_lms_context *ctx,
+                                    unsigned char pub_key[MBEDTLS_LMOTS_N_HASH_LEN],
+                                    unsigned int r_node_idx,
+                                    unsigned char out[32] )
+{
+    mbedtls_md_context_t hash_ctx;
+    unsigned char D_LEAF_bytes[D_CONST_LEN];
+    unsigned char r_node_idx_bytes[4];
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    mbedtls_md_init( &hash_ctx );
+    ret = mbedtls_md_setup( &hash_ctx, mbedtls_md_info_from_type( MBEDTLS_MD_SHA256 ), 0 );
+    if( ret )
+    {
+        goto out;
+    }
+    ret = mbedtls_md_starts( &hash_ctx );
+    if( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx,
+                             ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                             MBEDTLS_LMOTS_I_KEY_ID_LEN );
+    if( ret )
+    {
+        goto out;
+    }
+
+    val_to_network_bytes( r_node_idx, 4, r_node_idx_bytes );
+    ret = mbedtls_md_update( &hash_ctx, r_node_idx_bytes, 4 );
+    if( ret )
+    {
+        goto out;
+    }
+
+    val_to_network_bytes( D_LEAF_CONSTANT, D_CONST_LEN, D_LEAF_bytes );
+    ret = mbedtls_md_update( &hash_ctx, D_LEAF_bytes, D_CONST_LEN );
+    if( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, pub_key, MBEDTLS_LMOTS_N_HASH_LEN );
+    if( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_finish( &hash_ctx, out );
+    if( ret )
+    {
+        goto out;
+    }
+
+out:
+    mbedtls_md_free( &hash_ctx );
+
+    return( ret );
+}
+
+static int create_merkle_intr_node( const mbedtls_lms_context *ctx,
+                                    const unsigned char left_node[32],
+                                    const unsigned char rght_node[32],
+                                    unsigned int r_node_idx,
+                                    unsigned char out[32] )
+{
+    mbedtls_md_context_t hash_ctx;
+    unsigned char D_INTR_bytes[D_CONST_LEN];
+    unsigned char r_node_idx_bytes[4];
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    mbedtls_md_init( &hash_ctx );
+    ret = mbedtls_md_setup( &hash_ctx, mbedtls_md_info_from_type( MBEDTLS_MD_SHA256 ), 0 );
+    if( ret )
+    {
+        goto out;
+    }
+    ret = mbedtls_md_starts( &hash_ctx );
+    if( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                             MBEDTLS_LMOTS_I_KEY_ID_LEN );
+    if( ret )
+    {
+        goto out;
+    }
+
+    val_to_network_bytes( r_node_idx, 4, r_node_idx_bytes );
+    ret = mbedtls_md_update( &hash_ctx, r_node_idx_bytes, 4 );
+    if( ret )
+    {
+        goto out;
+    }
+
+    val_to_network_bytes( D_INTR_CONSTANT, D_CONST_LEN, D_INTR_bytes );
+    ret = mbedtls_md_update( &hash_ctx, D_INTR_bytes, D_CONST_LEN );
+    if( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, left_node, MBEDTLS_LMOTS_N_HASH_LEN );
+    if( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_update( &hash_ctx, rght_node, MBEDTLS_LMOTS_N_HASH_LEN );
+    if( ret )
+    {
+        goto out;
+    }
+
+    ret = mbedtls_md_finish( &hash_ctx, out );
+    if( ret )
+    {
+        goto out;
+    }
+
+out:
+    mbedtls_md_free( &hash_ctx );
+
+    return ret;
+}
+
+static int generate_merkle_tree( mbedtls_lms_context *ctx,
+                                 unsigned char tree[MERKLE_TREE_NODE_AM][32] )
+{
+    unsigned int priv_key_idx;
+    unsigned int r_node_idx;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    /* First create the leaf nodes, in ascending order */
+    for( priv_key_idx = 0; priv_key_idx < MERKLE_TREE_INTR_AM; priv_key_idx++ )
+    {
+        r_node_idx = MERKLE_TREE_INTR_AM + priv_key_idx;
+
+        ret = create_merkle_leaf_node( ctx, ctx->MBEDTLS_PRIVATE(priv_keys)[priv_key_idx].pub_key,
+                                       r_node_idx, tree[r_node_idx] );
+        if( ret )
+        {
+            return( ret );
+        }
+    }
+
+    /* Then the internal nodes, in reverse order so that we can guarantee the
+     * parent has been created */
+    for( r_node_idx = MERKLE_TREE_INTR_AM - 1; r_node_idx > 0; r_node_idx-- )
+    {
+        ret = create_merkle_intr_node( ctx, tree[(r_node_idx * 2)],
+                                       tree[(r_node_idx * 2 + 1)],
+                                       r_node_idx, tree[r_node_idx] );
+        if( ret )
+        {
+            return( ret );
+        }
+    }
+
+    return( 0 );
+}
+
+static int get_merkle_path( mbedtls_lms_context *ctx,
+                            unsigned int leaf_node_id, unsigned char path[MBEDTLS_LMS_H_TREE_HEIGHT][32] )
+{
+    unsigned char tree[MERKLE_TREE_NODE_AM][32];
+    unsigned int curr_node_id = leaf_node_id;
+    unsigned int parent_node_id;
+    unsigned char sibling_relative_id;
+    unsigned int adjacent_node_id;
+    unsigned int height;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    ret = generate_merkle_tree( ctx, tree);
+    if( ret )
+    {
+        return( ret );
+    }
+
+    for( height = 0; height < MBEDTLS_LMS_H_TREE_HEIGHT; height++ )
+    {
+        parent_node_id = ( curr_node_id / 2 );
+
+        /* 0 if the node is a left child, 1 if the node is a right child */
+        sibling_relative_id = curr_node_id & 1;
+
+        adjacent_node_id = ( parent_node_id * 2 ) + ( 1 - sibling_relative_id );
+
+        memcpy( &path[height], &tree[adjacent_node_id], MBEDTLS_LMOTS_N_HASH_LEN );
+
+        curr_node_id = parent_node_id;
+    }
+
+    return( 0 );
+}
+
+void mbedtls_lms_init( mbedtls_lms_context *ctx )
+{
+    if( ctx == NULL )
+    {
+        return;
+    }
+
+    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_lms_context ) ) ;
+}
+
+void mbedtls_lms_free( mbedtls_lms_context *ctx )
+{
+    unsigned int idx;
+
+    if( ctx == NULL )
+    {
+        return;
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(have_privkey) )
+    {
+        for( idx = 0; idx < MERKLE_TREE_LEAF_AM; idx++ )
+        {
+            mbedtls_lmots_free( &ctx->MBEDTLS_PRIVATE(priv_keys)[idx] );
+        }
+
+        mbedtls_free( ctx->MBEDTLS_PRIVATE(priv_keys) );
+    }
+
+    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_lms_context ) );
+}
+
+int mbedtls_lms_set_algorithm_type( mbedtls_lms_context *ctx,
+                                    mbedtls_lms_algorithm_type_t type,
+                                    mbedtls_lmots_algorithm_type_t otstype )
+{
+    if( ctx == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    ctx->MBEDTLS_PRIVATE(type) = type;
+    ctx->MBEDTLS_PRIVATE(otstype) = otstype;
+
+    return( 0 );
+}
+
+int mbedtls_lms_sign( mbedtls_lms_context *ctx,
+                      int ( *f_rng)(void *, unsigned char *, size_t),
+                      void* p_rng, unsigned char *msg, unsigned int msg_len,
+                      unsigned char *sig )
+{
+    unsigned int q_leaf_identifier;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( ctx == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ! ctx->MBEDTLS_PRIVATE(have_privkey) )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( msg == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( sig == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+
+    if( ctx->MBEDTLS_PRIVATE(type) != MBEDTLS_LMS_SHA256_M32_H10 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(otstype) != MBEDTLS_LMOTS_SHA256_N32_W8 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+
+    if( ctx->MBEDTLS_PRIVATE(q_next_usable_key) >= MERKLE_TREE_LEAF_AM )
+    {
+        return( MBEDTLS_ERR_LMS_OUT_OF_PRIV_KEYS );
+    }
+
+
+    q_leaf_identifier = ctx->MBEDTLS_PRIVATE(q_next_usable_key);
+    /* This new value must _always_ be written back to the disk before the
+     * signature is returned.
+     */
+    ctx->MBEDTLS_PRIVATE(q_next_usable_key) += 1;
+
+    ret = mbedtls_lmots_sign( &ctx->MBEDTLS_PRIVATE(priv_keys)[q_leaf_identifier],
+                              f_rng, p_rng, msg, msg_len,
+                              sig + MBEDTLS_LMS_SIG_OTS_SIG_OFFSET );
+    if( ret )
+    {
+        return( ret );
+    }
+
+    val_to_network_bytes( ctx->MBEDTLS_PRIVATE(type), MBEDTLS_LMS_TYPE_LEN,
+                          sig + MBEDTLS_LMS_SIG_TYPE_OFFSET );
+    val_to_network_bytes( q_leaf_identifier, MBEDTLS_LMOTS_Q_LEAF_ID_LEN,
+                          sig + MBEDTLS_LMS_SIG_Q_LEAF_ID_OFFSET);
+
+    ret = get_merkle_path( ctx, MERKLE_TREE_INTR_AM + q_leaf_identifier,
+                           ( unsigned char( * )[32] )( sig + MBEDTLS_LMS_SIG_PATH_OFFSET ) );
+    if( ret )
+    {
+        return( ret );
+    }
+
+    return( 0 );
+}
+
+int mbedtls_lms_verify( const mbedtls_lms_context *ctx,
+                        const unsigned char *msg, unsigned int msg_len,
+                        const unsigned char *sig )
+{
+    unsigned int q_leaf_identifier;
+    unsigned char Kc_candidate_ots_pub_key[MBEDTLS_LMOTS_N_HASH_LEN];
+    unsigned char Tc_candidate_root_node[32];
+    unsigned int height;
+    unsigned int curr_node_id;
+    unsigned int parent_node_id;
+    const unsigned char* left_node;
+    const unsigned char* rght_node;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( ctx == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ! ctx->MBEDTLS_PRIVATE(have_pubkey) )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( msg == NULL)
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( sig == NULL)
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(type) != MBEDTLS_LMS_SHA256_M32_H10 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(otstype) != MBEDTLS_LMOTS_SHA256_N32_W8 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+
+    if( network_bytes_to_val( MBEDTLS_LMS_TYPE_LEN,
+                              sig + MBEDTLS_LMS_SIG_TYPE_OFFSET) != MBEDTLS_LMS_SHA256_M32_H10 )
+    {
+        return( MBEDTLS_ERR_LMS_VERIFY_FAILED );
+    }
+
+    if( network_bytes_to_val( MBEDTLS_LMOTS_TYPE_LEN,
+                              sig + MBEDTLS_LMS_SIG_OTS_SIG_OFFSET + MBEDTLS_LMOTS_SIG_TYPE_OFFSET)
+        != MBEDTLS_LMOTS_SHA256_N32_W8 )
+    {
+        return( MBEDTLS_ERR_LMS_VERIFY_FAILED );
+    }
+
+
+    q_leaf_identifier = network_bytes_to_val( MBEDTLS_LMOTS_Q_LEAF_ID_LEN,
+                                              sig + MBEDTLS_LMS_SIG_Q_LEAF_ID_OFFSET );
+
+    if( q_leaf_identifier >= MERKLE_TREE_LEAF_AM )
+    {
+        return( MBEDTLS_ERR_LMS_VERIFY_FAILED );
+    }
+
+    ret = mbedtls_lmots_generate_pub_key_candidate( ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                                                    sig + MBEDTLS_LMS_SIG_Q_LEAF_ID_OFFSET,
+                                                    msg, msg_len,
+                                                    sig + MBEDTLS_LMS_SIG_OTS_SIG_OFFSET,
+                                                    Kc_candidate_ots_pub_key );
+    if( ret )
+    {
+        return( ret );
+    }
+
+    create_merkle_leaf_node( ctx, Kc_candidate_ots_pub_key,
+                             MERKLE_TREE_INTR_AM + q_leaf_identifier,
+                             Tc_candidate_root_node );
+
+    curr_node_id = MERKLE_TREE_INTR_AM + q_leaf_identifier;
+
+    for( height = 0; height < MBEDTLS_LMS_H_TREE_HEIGHT; height++ )
+    {
+        parent_node_id = curr_node_id / 2;
+
+        /* Left/right node ordering matters for the hash */
+        if( curr_node_id & 1 )
+        {
+            left_node = ( ( const unsigned char( * )[32] )( sig + MBEDTLS_LMS_SIG_PATH_OFFSET ) )[height];
+            rght_node = Tc_candidate_root_node;
+        }
+        else
+        {
+            left_node = Tc_candidate_root_node;
+            rght_node = ( ( const unsigned char( * )[32] )( sig + MBEDTLS_LMS_SIG_PATH_OFFSET ) )[height];
+        }
+
+        create_merkle_intr_node( ctx, left_node, rght_node, parent_node_id,
+                                 Tc_candidate_root_node);
+
+        curr_node_id /= 2;
+    }
+
+    if( memcmp( Tc_candidate_root_node, ctx->MBEDTLS_PRIVATE(T_1_pub_key),
+                MBEDTLS_LMOTS_N_HASH_LEN) )
+    {
+        return( MBEDTLS_ERR_LMS_VERIFY_FAILED );
+    }
+
+    return( 0 );
+}
+
+int mbedtls_lms_import_pubkey( mbedtls_lms_context *ctx,
+                               const unsigned char *key )
+{
+    mbedtls_lms_algorithm_type_t type;
+    mbedtls_lmots_algorithm_type_t otstype;
+
+    if( ctx == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( key == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    type = network_bytes_to_val( MBEDTLS_LMS_TYPE_LEN, key + MBEDTLS_LMS_PUBKEY_TYPE_OFFSET );
+    if( type != MBEDTLS_LMS_SHA256_M32_H10 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+    ctx->MBEDTLS_PRIVATE(type) = type;
+
+    otstype = network_bytes_to_val( MBEDTLS_LMOTS_TYPE_LEN,
+                                    key + MBEDTLS_LMS_PUBKEY_OTSTYPE_OFFSET );
+    if( otstype != MBEDTLS_LMOTS_SHA256_N32_W8 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+    ctx->MBEDTLS_PRIVATE(otstype) = otstype;
+
+    memcpy( ctx->MBEDTLS_PRIVATE(I_key_identifier), key + MBEDTLS_LMS_PUBKEY_I_KEY_ID_OFFSET,
+            MBEDTLS_LMOTS_I_KEY_ID_LEN );
+    memcpy( ctx->MBEDTLS_PRIVATE(T_1_pub_key), key + MBEDTLS_LMS_PUBKEY_ROOT_NODE_OFFSET,
+            MBEDTLS_LMOTS_N_HASH_LEN );
+
+    ctx->MBEDTLS_PRIVATE(have_pubkey) = 1;
+
+    return( 0 );
+}
+
+int mbedtls_lms_export_pubkey( mbedtls_lms_context *ctx,
+                               unsigned char *key )
+{
+    if( ctx == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( key == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ! ctx->MBEDTLS_PRIVATE(have_pubkey) )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    val_to_network_bytes( ctx->MBEDTLS_PRIVATE(type),
+                          MBEDTLS_LMS_TYPE_LEN, key + MBEDTLS_LMS_PUBKEY_TYPE_OFFSET );
+    val_to_network_bytes( ctx->MBEDTLS_PRIVATE(otstype),
+                          MBEDTLS_LMOTS_TYPE_LEN, key + MBEDTLS_LMS_PUBKEY_OTSTYPE_OFFSET );
+    memcpy( key + MBEDTLS_LMS_PUBKEY_I_KEY_ID_OFFSET,
+            ctx->MBEDTLS_PRIVATE(I_key_identifier),
+            MBEDTLS_LMOTS_I_KEY_ID_LEN );
+    memcpy( key + MBEDTLS_LMS_PUBKEY_ROOT_NODE_OFFSET,
+            ctx->MBEDTLS_PRIVATE(T_1_pub_key),
+            MBEDTLS_LMOTS_N_HASH_LEN );
+
+    return( 0 );
+}
+
+int mbedtls_lms_gen_pubkey( mbedtls_lms_context *ctx )
+{
+    unsigned char tree[MERKLE_TREE_NODE_AM][32];
+    unsigned int idx;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( ctx == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ! ctx->MBEDTLS_PRIVATE( have_privkey ) )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(type) != MBEDTLS_LMS_SHA256_M32_H10 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(otstype) != MBEDTLS_LMOTS_SHA256_N32_W8 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    for( idx = 0; idx < MERKLE_TREE_LEAF_AM; idx++ )
+    {
+        ret = mbedtls_lmots_gen_pubkey( &ctx->MBEDTLS_PRIVATE(priv_keys)[idx] );
+        if( ret )
+        {
+            return( ret );
+        }
+    }
+
+    ret = generate_merkle_tree( ctx, tree);
+    if( ret )
+    {
+        return( ret );
+    }
+
+    /* Root node is always at position 1, due to 1-based indexing */
+    memcpy( ctx->MBEDTLS_PRIVATE(T_1_pub_key), &tree[1], MBEDTLS_LMOTS_N_HASH_LEN );
+
+    ctx->MBEDTLS_PRIVATE(have_pubkey) = 1;
+
+    return( 0 );
+}
+
+int mbedtls_lms_gen_privkey( mbedtls_lms_context *ctx,
+                             int ( *f_rng)(void *, unsigned char *, size_t),
+                             void* p_rng, unsigned char *seed,
+                             size_t seed_len )
+{
+    unsigned int idx;
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
+
+    if( ctx == NULL )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(type) != MBEDTLS_LMS_SHA256_M32_H10 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(otstype) != MBEDTLS_LMOTS_SHA256_N32_W8 )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    if( ctx->MBEDTLS_PRIVATE(have_privkey) )
+    {
+        return( MBEDTLS_ERR_LMS_BAD_INPUT_DATA );
+    }
+
+    f_rng( p_rng, ctx->MBEDTLS_PRIVATE(I_key_identifier),
+           sizeof( ctx->MBEDTLS_PRIVATE(I_key_identifier) ) );
+
+    ctx->MBEDTLS_PRIVATE(priv_keys) = mbedtls_calloc( MERKLE_TREE_LEAF_AM,
+                                                      sizeof( mbedtls_lmots_context));
+    if( ctx->MBEDTLS_PRIVATE(priv_keys) == NULL )
+    {
+        ret = MBEDTLS_ERR_LMS_ALLOC_FAILED;
+        goto out;
+    }
+
+    for( idx = 0; idx < MERKLE_TREE_LEAF_AM; idx++ )
+    {
+        mbedtls_lmots_init( &ctx->MBEDTLS_PRIVATE(priv_keys)[idx] );
+        ret = mbedtls_lmots_set_algorithm_type( &ctx->MBEDTLS_PRIVATE(priv_keys)[idx],
+                                                ctx->MBEDTLS_PRIVATE(otstype) );
+        if( ret)
+        {
+            goto out;
+        }
+    }
+
+
+    for( idx = 0; idx < MERKLE_TREE_LEAF_AM; idx++ )
+    {
+        ret = mbedtls_lmots_gen_privkey( &ctx->MBEDTLS_PRIVATE(priv_keys)[idx],
+                                         ctx->MBEDTLS_PRIVATE(I_key_identifier),
+                                         idx, seed, seed_len );
+        if( ret)
+        {
+            goto out;
+        }
+    }
+
+    ctx->MBEDTLS_PRIVATE(q_next_usable_key) = 0;
+    ctx->MBEDTLS_PRIVATE(have_privkey) = 1;
+
+out:
+    if( ret )
+    {
+        mbedtls_free( ctx->MBEDTLS_PRIVATE(priv_keys) );
+        return( ret );
+    }
+
+    return( 0 );
+}
+
+#endif /* MBEDTLS_LMS_C */
diff --git a/library/md.c b/library/md.c
index a387da50..e209aece 100644
--- a/library/md.c
+++ b/library/md.c
@@ -35,6 +35,7 @@
 #include "mbedtls/sha1.h"
 #include "mbedtls/sha256.h"
 #include "mbedtls/sha512.h"
+#include "mbedtls/sm3.h"
 
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
@@ -104,6 +105,14 @@ const mbedtls_md_info_t mbedtls_sha384_info = {
 };
 #endif
 
+#if defined(MBEDTLS_SM3_C)
+const mbedtls_md_info_t mbedtls_sm3_info = {
+    "SM3",
+    MBEDTLS_MD_SM3,
+    32,
+    64,
+};
+#endif   
 #if defined(MBEDTLS_SHA512_C)
 const mbedtls_md_info_t mbedtls_sha512_info = {
     "SHA512",
@@ -111,6 +120,7 @@ const mbedtls_md_info_t mbedtls_sha512_info = {
     64,
     128,
 };
+
 #endif
 
 /*
@@ -145,6 +155,10 @@ static const int supported_digests[] = {
         MBEDTLS_MD_MD5,
 #endif
 
+#if defined(MBEDTLS_SM3_C)
+        MBEDTLS_MD_SM3,
+#endif
+
         MBEDTLS_MD_NONE
 };
 
@@ -186,6 +200,10 @@ const mbedtls_md_info_t *mbedtls_md_info_from_string( const char *md_name )
 #if defined(MBEDTLS_SHA512_C)
     if( !strcmp( "SHA512", md_name ) )
         return mbedtls_md_info_from_type( MBEDTLS_MD_SHA512 );
+#endif
+#if defined(MBEDTLS_SM3_C)
+    if( !strcmp( "SM3", md_name ) )
+        return mbedtls_md_info_from_type( MBEDTLS_MD_SM3 );
 #endif
     return( NULL );
 }
@@ -221,6 +239,10 @@ const mbedtls_md_info_t *mbedtls_md_info_from_type( mbedtls_md_type_t md_type )
 #if defined(MBEDTLS_SHA512_C)
         case MBEDTLS_MD_SHA512:
             return( &mbedtls_sha512_info );
+#endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return( &mbedtls_sm3_info );
 #endif
         default:
             return( NULL );
@@ -284,6 +306,11 @@ void mbedtls_md_free( mbedtls_md_context_t *ctx )
             case MBEDTLS_MD_SHA512:
                 mbedtls_sha512_free( ctx->md_ctx );
                 break;
+#endif                
+#if defined(MBEDTLS_SM3_C)
+            case MBEDTLS_MD_SM3:
+                mbedtls_sm3_free( ctx->md_ctx );
+                break;                
 #endif
             default:
                 /* Shouldn't happen */
@@ -348,6 +375,11 @@ int mbedtls_md_clone( mbedtls_md_context_t *dst,
         case MBEDTLS_MD_SHA512:
             mbedtls_sha512_clone( dst->md_ctx, src->md_ctx );
             break;
+#endif            
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            mbedtls_sm3_clone( dst->md_ctx, src->md_ctx );
+            break;            
 #endif
         default:
             return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
@@ -410,6 +442,11 @@ int mbedtls_md_setup( mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_inf
         case MBEDTLS_MD_SHA512:
             ALLOC( sha512 );
             break;
+#endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            ALLOC( sm3 );
+            break;
 #endif
         default:
             return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
@@ -463,6 +500,10 @@ int mbedtls_md_starts( mbedtls_md_context_t *ctx )
 #if defined(MBEDTLS_SHA512_C)
         case MBEDTLS_MD_SHA512:
             return( mbedtls_sha512_starts( ctx->md_ctx, 0 ) );
+#endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return( mbedtls_sm3_starts( ctx->md_ctx ) );
 #endif
         default:
             return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
@@ -503,6 +544,10 @@ int mbedtls_md_update( mbedtls_md_context_t *ctx, const unsigned char *input, si
 #if defined(MBEDTLS_SHA512_C)
         case MBEDTLS_MD_SHA512:
             return( mbedtls_sha512_update( ctx->md_ctx, input, ilen ) );
+#endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return( mbedtls_sm3_update( ctx->md_ctx, input, ilen ) );
 #endif
         default:
             return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
@@ -543,6 +588,10 @@ int mbedtls_md_finish( mbedtls_md_context_t *ctx, unsigned char *output )
 #if defined(MBEDTLS_SHA512_C)
         case MBEDTLS_MD_SHA512:
             return( mbedtls_sha512_finish( ctx->md_ctx, output ) );
+#endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return( mbedtls_sm3_finish( ctx->md_ctx, output ) );
 #endif
         default:
             return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
@@ -584,6 +633,10 @@ int mbedtls_md( const mbedtls_md_info_t *md_info, const unsigned char *input, si
 #if defined(MBEDTLS_SHA512_C)
         case MBEDTLS_MD_SHA512:
             return( mbedtls_sha512( input, ilen, output, 0 ) );
+#endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return( mbedtls_sm3( input, ilen, output) );
 #endif
         default:
             return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
@@ -791,6 +844,10 @@ int mbedtls_md_process( mbedtls_md_context_t *ctx, const unsigned char *data )
 #if defined(MBEDTLS_SHA512_C)
         case MBEDTLS_MD_SHA512:
             return( mbedtls_internal_sha512_process( ctx->md_ctx, data ) );
+#endif
+#if defined(MBEDTLS_SM3_C)
+        case MBEDTLS_MD_SM3:
+            return( mbedtls_sm3_process( ctx->md_ctx, data ) );
 #endif
         default:
             return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
@@ -822,3 +879,4 @@ const char *mbedtls_md_get_name( const mbedtls_md_info_t *md_info )
 }
 
 #endif /* MBEDTLS_MD_C */
+
diff --git a/library/md5.c b/library/md5.c
index a9bbcb48..47d3dd42 100644
--- a/library/md5.c
+++ b/library/md5.c
@@ -213,7 +213,6 @@ int mbedtls_internal_md5_process( mbedtls_md5_context *ctx,
 
     return( 0 );
 }
-
 #endif /* !MBEDTLS_MD5_PROCESS_ALT */
 
 /*
diff --git a/library/md_wrap.h b/library/md_wrap.h
index 90c79573..11ac12e6 100644
--- a/library/md_wrap.h
+++ b/library/md_wrap.h
@@ -74,6 +74,9 @@ extern const mbedtls_md_info_t mbedtls_sha384_info;
 #if defined(MBEDTLS_SHA512_C)
 extern const mbedtls_md_info_t mbedtls_sha512_info;
 #endif
+#if defined(MBEDTLS_SM3_C)
+extern const mbedtls_md_info_t mbedtls_sm3_info;
+#endif
 
 #ifdef __cplusplus
 }
diff --git a/library/pk_wrap.c b/library/pk_wrap.c
index e234a8de..44cd48ba 100644
--- a/library/pk_wrap.c
+++ b/library/pk_wrap.c
@@ -40,6 +40,10 @@
 #include "mbedtls/ecdsa.h"
 #endif
 
+#if defined(MBEDTLS_SM2_C)
+#include "mbedtls/sm2.h"
+#endif
+
 #if defined(MBEDTLS_USE_PSA_CRYPTO)
 #include "mbedtls/asn1write.h"
 #endif
@@ -165,6 +169,8 @@ static size_t rsa_get_bitlen( const void *ctx )
     return( 8 * mbedtls_rsa_get_len( rsa ) );
 }
 
+
+
 #if defined(MBEDTLS_USE_PSA_CRYPTO)
 static int rsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
                    const unsigned char *hash, size_t hash_len,
@@ -858,6 +864,116 @@ const mbedtls_pk_info_t mbedtls_eckeydh_info = {
 };
 #endif /* MBEDTLS_ECP_C */
 
+#if defined(MBEDTLS_SM2_C)
+
+static int sm2_can_do( mbedtls_pk_type_t type )
+{
+    return( type == MBEDTLS_PK_SM2 );
+}
+
+static int sm2_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
+                       const unsigned char *hash, size_t hash_len,
+                       const unsigned char *sig, size_t sig_len )
+{
+    if( hash_len != mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) )
+            || sig_len <= 0 )
+        return( MBEDTLS_ERR_ECP_VERIFY_FAILED );
+
+    return mbedtls_sm2_verify( (mbedtls_sm2_context *) ctx, md_alg, hash, sig );
+}
+
+static int sm2_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
+                   const unsigned char *hash, size_t hash_len,
+                   unsigned char *sig, size_t sig_size, size_t *sig_len,
+                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
+{
+    int ret;
+
+    if( hash_len != mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) )
+            || sig_len == NULL )
+        return( MBEDTLS_ERR_SM2_BAD_INPUT_DATA );
+    ret = mbedtls_sm2_sign( (mbedtls_sm2_context *) ctx, md_alg, hash, sig,
+            f_rng, p_rng );
+    if( ret == 0 )
+        *sig_len = ( ((mbedtls_sm2_context *) ctx)->grp.nbits + 7 ) / 8 * 2;
+
+    return( ret );
+}
+
+static int sm2_decrypt_wrap( void *ctx,
+                    const unsigned char *input, size_t ilen,
+                    unsigned char *output, size_t *olen, size_t osize,
+                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
+{
+    mbedtls_md_type_t md_type = MBEDTLS_SM2_SPECIFIC_MD_ALGORITHM;
+    size_t addlen = 1 +
+        ( ((mbedtls_sm2_context *) ctx)->grp.nbits + 7 ) / 8 * 2 +
+        mbedtls_md_get_size( mbedtls_md_info_from_type( md_type ) );
+    ((void) f_rng);
+    ((void) p_rng);
+
+    if( ilen < addlen || osize < (ilen - addlen) )
+        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
+    return mbedtls_sm2_decrypt( (mbedtls_sm2_context *) ctx, md_type,
+            input, ilen, output, olen );
+}
+
+static int sm2_encrypt_wrap( void *ctx,
+                    const unsigned char *input, size_t ilen,
+                    unsigned char *output, size_t *olen, size_t osize,
+                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
+{
+    mbedtls_md_type_t md_type = MBEDTLS_SM2_SPECIFIC_MD_ALGORITHM;
+    size_t addlen = 1 +
+        ( ((mbedtls_sm2_context *) ctx)->grp.nbits + 7 ) / 8 * 2 +
+        mbedtls_md_get_size( mbedtls_md_info_from_type( md_type ) );
+
+    if( osize < (ilen + addlen) )
+        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
+    return mbedtls_sm2_encrypt( (mbedtls_sm2_context *) ctx, md_type,
+            input, ilen, output, olen, f_rng, p_rng );
+}
+
+static void *sm2_alloc_wrap( void )
+{
+    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_sm2_context ) );
+
+    if( ctx != NULL )
+        mbedtls_sm2_init( (mbedtls_sm2_context *) ctx );
+
+    return( ctx );
+}
+
+static void sm2_free_wrap( void *ctx )
+{
+    mbedtls_sm2_free( (mbedtls_sm2_context *) ctx );
+    mbedtls_free( ctx );
+}
+
+const mbedtls_pk_info_t mbedtls_sm2_info = {
+    MBEDTLS_PK_SM2,
+    "SM2",
+    eckey_get_bitlen,   /* Compatible key structures */
+    sm2_can_do,
+    sm2_verify_wrap,
+    sm2_sign_wrap,
+#if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
+    NULL,
+    NULL,
+#endif    
+    sm2_decrypt_wrap,
+    sm2_encrypt_wrap,
+    eckey_check_pair,   /* Compatible key structures */
+    sm2_alloc_wrap,
+    sm2_free_wrap,
+#if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECP_RESTARTABLE)
+    NULL,
+    NULL,
+#endif    
+    eckey_debug,        /* Compatible key structures */
+};
+#endif /* MBEDTLS_SM2_C */
+
 #if defined(MBEDTLS_ECDSA_C)
 static int ecdsa_can_do( mbedtls_pk_type_t type )
 {
diff --git a/library/platform.c b/library/platform.c
index 6151e6c4..074ecbb7 100644
--- a/library/platform.c
+++ b/library/platform.c
@@ -53,8 +53,8 @@ static void platform_free_uninit( void *ptr )
 #define MBEDTLS_PLATFORM_STD_FREE     platform_free_uninit
 #endif /* !MBEDTLS_PLATFORM_STD_FREE */
 
-static void * (*mbedtls_calloc_func)( size_t, size_t ) = MBEDTLS_PLATFORM_STD_CALLOC;
-static void (*mbedtls_free_func)( void * ) = MBEDTLS_PLATFORM_STD_FREE;
+void * (*mbedtls_calloc_func)( size_t, size_t ) = MBEDTLS_PLATFORM_STD_CALLOC;
+void (*mbedtls_free_func)( void * ) = MBEDTLS_PLATFORM_STD_FREE;
 
 void * mbedtls_calloc( size_t nmemb, size_t size )
 {
diff --git a/library/platform_util.c b/library/platform_util.c
index 916a7f44..8936a9d7 100644
--- a/library/platform_util.c
+++ b/library/platform_util.c
@@ -62,7 +62,7 @@
  * mbedtls_platform_zeroize() to use a suitable implementation for their
  * platform and needs.
  */
-static void * (* const volatile memset_func)( void *, int, size_t ) = memset;
+void * (* const volatile memset_func)( void *, int, size_t ) = memset;
 
 void mbedtls_platform_zeroize( void *buf, size_t len )
 {
diff --git a/library/psa_crypto.c b/library/psa_crypto.c
index b0116ddf..8909b526 100644
--- a/library/psa_crypto.c
+++ b/library/psa_crypto.c
@@ -86,6 +86,11 @@
 #include "mbedtls/sha256.h"
 #include "mbedtls/sha512.h"
 
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+#include "tfm_crypto_defs.h"
+#include "tfm_builtin_key_loader.h"
+#endif /* PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER */
+
 #define ARRAY_LENGTH( array ) ( sizeof( array ) / sizeof( *( array ) ) )
 
 #if defined(MBEDTLS_PSA_BUILTIN_ALG_HKDF) ||          \
@@ -425,6 +430,15 @@ mbedtls_ecp_group_id mbedtls_ecc_group_of_psa( psa_ecc_family_t curve,
 #endif
             }
             break;
+        case PSA_ECC_FAMILY_CURVE_SM2:
+            switch( bits )
+            {
+                case  256:
+                    return(MBEDTLS_ECP_DP_CURVE_SM2);
+                default:
+                    return(MBEDTLS_ECP_DP_NONE);
+            }          
+            break;
     }
 
     (void) bits_is_sloppy;
@@ -445,6 +459,7 @@ psa_status_t psa_validate_unstructured_key_bit_size( psa_key_type_t type,
         case PSA_KEY_TYPE_RAW_DATA:
         case PSA_KEY_TYPE_HMAC:
         case PSA_KEY_TYPE_DERIVE:
+        case PSA_KEY_TYPE_SM4:
             break;
 #if defined(PSA_WANT_KEY_TYPE_AES)
         case PSA_KEY_TYPE_AES:
@@ -962,7 +977,11 @@ static psa_status_t psa_get_and_lock_transparent_key_slot_with_policy(
     if( status != PSA_SUCCESS )
         return( status );
 
-    if( psa_key_lifetime_is_external( (*p_slot)->attr.lifetime ) )
+    if( psa_key_lifetime_is_external( (*p_slot)->attr.lifetime )
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        && PSA_KEY_LIFETIME_GET_LOCATION((*p_slot)->attr.lifetime) != TFM_BUILTIN_KEY_LOADER_KEY_LOCATION
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
+        )
     {
         psa_unlock_key_slot( *p_slot );
         *p_slot = NULL;
@@ -2170,11 +2189,11 @@ psa_status_t psa_hash_update( psa_hash_operation_t *operation,
         return( PSA_SUCCESS );
 
     status = psa_driver_wrapper_hash_update( operation, input, input_length );
-
 exit:
     if( status != PSA_SUCCESS )
+    {
         psa_hash_abort( operation );
-
+    } 
     return( status );
 }
 
@@ -3470,7 +3489,7 @@ psa_status_t psa_cipher_encrypt( mbedtls_svc_key_id_t key,
         &attributes, slot->key.data, slot->key.bytes,
         alg, local_iv, default_iv_length, input, input_length,
         output + default_iv_length, output_size - default_iv_length,
-        output_length );
+        output_length );  
 
 exit:
     unlock_status = psa_unlock_key_slot( slot );
@@ -3500,13 +3519,11 @@ psa_status_t psa_cipher_decrypt( mbedtls_svc_key_id_t key,
     psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
     psa_status_t unlock_status = PSA_ERROR_CORRUPTION_DETECTED;
     psa_key_slot_t *slot = NULL;
-
     if( ! PSA_ALG_IS_CIPHER( alg ) )
     {
         status = PSA_ERROR_INVALID_ARGUMENT;
         goto exit;
     }
-
     status = psa_get_and_lock_key_slot_with_policy( key, &slot,
                                                     PSA_KEY_USAGE_DECRYPT,
                                                     alg );
@@ -3527,7 +3544,6 @@ psa_status_t psa_cipher_decrypt( mbedtls_svc_key_id_t key,
         status = PSA_ERROR_INVALID_ARGUMENT;
         goto exit;
     }
-
     status = psa_driver_wrapper_cipher_decrypt(
         &attributes, slot->key.data, slot->key.bytes,
         alg, input, input_length,
@@ -5862,11 +5878,24 @@ psa_status_t psa_raw_key_agreement( psa_algorithm_t alg,
         goto exit;
     }
 
-    status = psa_key_agreement_raw_internal( alg, slot,
-                                             peer_key, peer_key_length,
-                                             output, output_size,
-                                             output_length );
+    psa_key_attributes_t attributes = {
+      .core = slot->attr
+    };
+
+    status = psa_driver_wrapper_key_agreement( alg, &attributes,
+                                               slot->key.data,
+                                               slot->key.bytes,
+                                               peer_key, peer_key_length,
+                                               output, output_size,
+                                               output_length );
 
+    if (status == PSA_ERROR_NOT_SUPPORTED)
+    {
+        status = psa_key_agreement_raw_internal( alg, slot,
+                                                 peer_key, peer_key_length,
+                                                 output, output_size,
+                                                 output_length );
+    }
 exit:
     if( status != PSA_SUCCESS )
     {
@@ -6284,6 +6313,11 @@ psa_status_t psa_crypto_init( void )
     if( global_data.initialized != 0 )
         return( PSA_SUCCESS );
 
+    /* Init drivers */
+    status = psa_driver_wrapper_init( );
+    if( status != PSA_SUCCESS )
+        goto exit;
+
     /* Initialize and seed the random generator. */
     mbedtls_psa_random_init( &global_data.rng );
     global_data.rng_state = RNG_INITIALIZED;
@@ -6296,11 +6330,6 @@ psa_status_t psa_crypto_init( void )
     if( status != PSA_SUCCESS )
         goto exit;
 
-    /* Init drivers */
-    status = psa_driver_wrapper_init( );
-    if( status != PSA_SUCCESS )
-        goto exit;
-
 #if defined(PSA_CRYPTO_STORAGE_HAS_TRANSACTIONS)
     status = psa_crypto_load_transaction( );
     if( status == PSA_SUCCESS )
diff --git a/library/psa_crypto_cipher.c b/library/psa_crypto_cipher.c
index fafe68b0..7d7d81bf 100644
--- a/library/psa_crypto_cipher.c
+++ b/library/psa_crypto_cipher.c
@@ -148,6 +148,9 @@ const mbedtls_cipher_info_t *mbedtls_cipher_info_from_psa(
             cipher_id_tmp = MBEDTLS_CIPHER_ID_CHACHA20;
             break;
 #endif
+        case PSA_KEY_TYPE_SM4:
+            cipher_id_tmp = MBEDTLS_CIPHER_ID_SM4;
+            break;
         default:
             return( NULL );
     }
@@ -173,7 +176,6 @@ static psa_status_t psa_cipher_setup(
     psa_key_type_t key_type = attributes->core.type;
 
     (void)key_buffer_size;
-
     mbedtls_cipher_init( &operation->ctx.cipher );
 
     operation->alg = alg;
@@ -182,7 +184,6 @@ static psa_status_t psa_cipher_setup(
                                                 key_bits, NULL );
     if( cipher_info == NULL )
         return( PSA_ERROR_NOT_SUPPORTED );
-
     ret = mbedtls_cipher_setup( &operation->ctx.cipher, cipher_info );
     if( ret != 0 )
         goto exit;
@@ -202,7 +203,7 @@ static psa_status_t psa_cipher_setup(
 #endif
     {
         ret = mbedtls_cipher_setkey( &operation->ctx.cipher, key_buffer,
-                                     (int) key_bits, cipher_operation );
+                                     (int) key_bits, cipher_operation );                           
     }
     if( ret != 0 )
         goto exit;
@@ -551,21 +552,21 @@ psa_status_t mbedtls_psa_cipher_decrypt(
 
     status = mbedtls_psa_cipher_decrypt_setup( &operation, attributes,
                                                key_buffer, key_buffer_size,
-                                               alg );
+                                               alg );                                              
     if( status != PSA_SUCCESS )
         goto exit;
 
     if( operation.iv_length > 0 )
     {
         status = mbedtls_psa_cipher_set_iv( &operation,
-                                            input, operation.iv_length );
+                                            input, operation.iv_length );                                           
         if( status != PSA_SUCCESS )
             goto exit;
     }
 
     status = mbedtls_psa_cipher_update( &operation, input + operation.iv_length,
                                         input_length - operation.iv_length,
-                                        output, output_size, &olength );
+                                        output, output_size, &olength );                                       
     if( status != PSA_SUCCESS )
         goto exit;
 
diff --git a/library/psa_crypto_driver_wrappers.c b/library/psa_crypto_driver_wrappers.c
index a5ae6a29..b242966c 100644
--- a/library/psa_crypto_driver_wrappers.c
+++ b/library/psa_crypto_driver_wrappers.c
@@ -30,6 +30,8 @@
 
 #include "mbedtls/platform.h"
 
+#include "riscv_cm32_psa_hash.h"
+#include "riscv_cm32_psa_cipher.h"
 #if defined(MBEDTLS_PSA_CRYPTO_C)
 
 #if defined(MBEDTLS_PSA_CRYPTO_DRIVERS)
@@ -45,6 +47,28 @@
 #include "test/drivers/test_driver.h"
 #endif /* PSA_CRYPTO_DRIVER_TEST */
 
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+#ifndef PSA_CRYPTO_DRIVER_PRESENT
+#define PSA_CRYPTO_DRIVER_PRESENT
+#endif
+#ifndef PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT
+#define PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT
+#endif
+#include "cc3xx.h"
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+
+/* Include TF-M builtin key driver */
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+#ifndef PSA_CRYPTO_DRIVER_PRESENT
+#define PSA_CRYPTO_DRIVER_PRESENT
+#endif
+#ifndef PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT
+#define PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT
+#endif
+#include "tfm_crypto_defs.h"
+#include "tfm_builtin_key_loader.h"
+#endif /* PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER */
+
 /* Repeat above block for each JSON-declared driver during autogeneration */
 #endif /* MBEDTLS_PSA_CRYPTO_DRIVERS */
 
@@ -58,6 +82,18 @@
 #define PSA_CRYPTO_OPAQUE_TEST_DRIVER_ID (3)
 #endif /* PSA_CRYPTO_DRIVER_TEST */
 
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+#define PSA_CRYPTO_CC3XX_DRIVER_ID (4)
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+#define PSA_CRYPTO_TFM_BUILTIN_KEY_LOADER_DRIVER_ID (5)
+#endif /* PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER */
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+#define  PSA_CRYPTO_RISCV_DRIVER_ID (6)
+#endif
+
 /* Support the 'old' SE interface when asked to */
 #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
 /* PSA_CRYPTO_DRIVER_PRESENT is defined when either a new-style or old-style
@@ -72,6 +108,12 @@ psa_status_t psa_driver_wrapper_init( void )
 {
     psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
 
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+    status = cc3xx_init();
+    if (status != PSA_SUCCESS)
+        return ( status );
+#endif
+
 #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
     status = psa_init_all_se_drivers( );
     if( status != PSA_SUCCESS )
@@ -94,6 +136,10 @@ psa_status_t psa_driver_wrapper_init( void )
 
 void psa_driver_wrapper_free( void )
 {
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+    (void)cc3xx_free();
+#endif
+
 #if defined(MBEDTLS_PSA_CRYPTO_SE_C)
     /* Unregister all secure element drivers, so that we restart from
      * a pristine state. */
@@ -125,6 +171,9 @@ psa_status_t psa_driver_wrapper_sign_message(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -143,9 +192,32 @@ psa_status_t psa_driver_wrapper_sign_message(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_sign_message(
+                        attributes,
+                        key_buffer,
+                        key_buffer_size,
+                        alg,
+                        input,
+                        input_length,
+                        signature,
+                        signature_size,
+                        signature_length );
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
-            break;
-
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
+            /* Fell through, meaning no accelerator supports this operation */
+            return( psa_sign_message_builtin( attributes,
+                                      key_buffer,
+                                      key_buffer_size,
+                                      alg,
+                                      input,
+                                      input_length,
+                                      signature,
+                                      signature_size,
+                                      signature_length ) );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
@@ -168,18 +240,9 @@ psa_status_t psa_driver_wrapper_sign_message(
         default:
             /* Key is declared with a lifetime not known to us */
             (void)status;
-            break;
+            return( PSA_ERROR_INVALID_ARGUMENT );
     }
-
-    return( psa_sign_message_builtin( attributes,
-                                      key_buffer,
-                                      key_buffer_size,
-                                      alg,
-                                      input,
-                                      input_length,
-                                      signature,
-                                      signature_size,
-                                      signature_length ) );
+    return status;
 }
 
 psa_status_t psa_driver_wrapper_verify_message(
@@ -199,6 +262,9 @@ psa_status_t psa_driver_wrapper_verify_message(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -216,9 +282,30 @@ psa_status_t psa_driver_wrapper_verify_message(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_verify_message(
+                        attributes,
+                        key_buffer,
+                        key_buffer_size,
+                        alg,
+                        input,
+                        input_length,
+                        signature,
+                        signature_length );
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
-            break;
-
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
+            /* Fell through, meaning no accelerator supports this operation */
+            return( psa_verify_message_builtin( attributes,
+                                        key_buffer,
+                                        key_buffer_size,
+                                        alg,
+                                        input,
+                                        input_length,
+                                        signature,
+                                        signature_length ) );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
@@ -240,17 +327,9 @@ psa_status_t psa_driver_wrapper_verify_message(
         default:
             /* Key is declared with a lifetime not known to us */
             (void)status;
-            break;
+            return( PSA_ERROR_INVALID_ARGUMENT );
     }
-
-    return( psa_verify_message_builtin( attributes,
-                                        key_buffer,
-                                        key_buffer_size,
-                                        alg,
-                                        input,
-                                        input_length,
-                                        signature,
-                                        signature_length ) );
+    return status;
 }
 
 psa_status_t psa_driver_wrapper_sign_hash(
@@ -286,6 +365,9 @@ psa_status_t psa_driver_wrapper_sign_hash(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -303,7 +385,20 @@ psa_status_t psa_driver_wrapper_sign_hash(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_sign_hash( attributes,
+                                      key_buffer,
+                                      key_buffer_size,
+                                      alg,
+                                      hash,
+                                      hash_length,
+                                      signature,
+                                      signature_size,
+                                      signature_length );
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             return( psa_sign_hash_builtin( attributes,
                                            key_buffer,
@@ -314,7 +409,7 @@ psa_status_t psa_driver_wrapper_sign_hash(
                                            signature,
                                            signature_size,
                                            signature_length ) );
-
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
@@ -370,9 +465,23 @@ psa_status_t psa_driver_wrapper_verify_hash(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_verify_hash( attributes,
+                                        key_buffer,
+                                        key_buffer_size,
+                                        alg,
+                                        hash,
+                                        hash_length,
+                                        signature,
+                                        signature_length );
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #if defined(PSA_CRYPTO_DRIVER_TEST)
             status = mbedtls_test_transparent_signature_verify_hash(
                          attributes,
@@ -388,7 +497,7 @@ psa_status_t psa_driver_wrapper_verify_hash(
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
-
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
             return( psa_verify_hash_builtin( attributes,
                                              key_buffer,
                                              key_buffer_size,
@@ -397,7 +506,7 @@ psa_status_t psa_driver_wrapper_verify_hash(
                                              hash_length,
                                              signature,
                                              signature_length ) );
-
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
@@ -503,7 +612,11 @@ psa_status_t psa_driver_wrapper_get_key_buffer_size(
             return( ( *key_buffer_size != 0 ) ?
                     PSA_SUCCESS : PSA_ERROR_NOT_SUPPORTED );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
-
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+            return tfm_builtin_key_loader_get_key_buffer_size(psa_get_key_id(attributes),
+                                                              key_buffer_size);
+#endif /* PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER */
         default:
             (void)key_type;
             (void)key_bits;
@@ -543,11 +656,20 @@ psa_status_t psa_driver_wrapper_generate_key(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
             /* Transparent drivers are limited to generating asymmetric keys */
             if( PSA_KEY_TYPE_IS_ASYMMETRIC( attributes->core.type ) )
             {
             /* Cycle through all known transparent accelerators */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+                status = cc3xx_generate_key(
+                    attributes, key_buffer, key_buffer_size,
+                    key_buffer_length );
+                break;
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #if defined(PSA_CRYPTO_DRIVER_TEST)
                 status = mbedtls_test_transparent_generate_key(
                     attributes, key_buffer, key_buffer_size,
@@ -628,6 +750,9 @@ psa_status_t psa_driver_wrapper_import_key(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -698,6 +823,9 @@ psa_status_t psa_driver_wrapper_export_key(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             return( psa_export_key_internal( attributes,
                                              key_buffer,
                                              key_buffer_size,
@@ -756,6 +884,9 @@ psa_status_t psa_driver_wrapper_export_public_key(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -771,7 +902,18 @@ psa_status_t psa_driver_wrapper_export_public_key(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_export_public_key(
+                         attributes,
+                         key_buffer,
+                         key_buffer_size,
+                         data,
+                         data_size,
+                         data_length );
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             return( psa_export_public_key_internal( attributes,
                                                     key_buffer,
@@ -779,7 +921,7 @@ psa_status_t psa_driver_wrapper_export_public_key(
                                                     data,
                                                     data_size,
                                                     data_length ) );
-
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
@@ -813,6 +955,13 @@ psa_status_t psa_driver_wrapper_get_builtin_key(
                         attributes,
                         key_buffer, key_buffer_size, key_buffer_length ) );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+            return( tfm_builtin_key_loader_get_key_buffer(
+                        slot_number,
+                        attributes,
+                        key_buffer, key_buffer_size, key_buffer_length ) );
+#endif /* PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER */
         default:
             (void) slot_number;
             (void) key_buffer;
@@ -889,6 +1038,9 @@ psa_status_t psa_driver_wrapper_cipher_encrypt(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -908,9 +1060,44 @@ psa_status_t psa_driver_wrapper_cipher_encrypt(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_cipher_encrypt( attributes,
+                                           key_buffer,
+                                           key_buffer_size,
+                                           alg,
+                                           iv,
+                                           iv_length,
+                                           input,
+                                           input_length,
+                                           output,
+                                           output_size,
+                                           output_length );
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
 
-#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+            status = riscv_cm32_cipher_encrypt( attributes,
+                                                key_buffer,
+                                                key_buffer_size,
+                                                alg,
+                                                iv,
+                                                iv_length,
+                                                input,
+                                                input_length,
+                                                output,
+                                                output_size,
+                                                output_length );
+            if( status == PSA_SUCCESS ) {
+                return( status );
+            }
+            
+            if ( status != PSA_ERROR_NOT_SUPPORTED ) {
+                return( status );    
+            }
+#endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_CIPHER) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
             return( mbedtls_psa_cipher_encrypt( attributes,
                                                 key_buffer,
                                                 key_buffer_size,
@@ -979,6 +1166,9 @@ psa_status_t psa_driver_wrapper_cipher_decrypt(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -996,9 +1186,40 @@ psa_status_t psa_driver_wrapper_cipher_decrypt(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_cipher_decrypt( attributes,
+                                           key_buffer,
+                                           key_buffer_size,
+                                           alg,
+                                           input,
+                                           input_length,
+                                           output,
+                                           output_size,
+                                           output_length );
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
 
-#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+            status = riscv_cm32_cipher_decrypt( attributes,
+                                                key_buffer,
+                                                key_buffer_size,
+                                                alg,
+                                                input,
+                                                input_length,
+                                                output,
+                                                output_size,
+                                                output_length );
+            if( status == PSA_SUCCESS ) {
+                return( status );
+            }
+            
+            if ( status != PSA_ERROR_NOT_SUPPORTED ) {
+                return( status );    
+            }
+#endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_CIPHER) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
             return( mbedtls_psa_cipher_decrypt( attributes,
                                                 key_buffer,
                                                 key_buffer_size,
@@ -1056,6 +1277,9 @@ psa_status_t psa_driver_wrapper_cipher_encrypt_setup(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -1073,8 +1297,35 @@ psa_status_t psa_driver_wrapper_cipher_encrypt_setup(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_cipher_encrypt_setup(
+                &operation->ctx.cc3xx_driver_ctx,
+                attributes,
+                key_buffer,
+                key_buffer_size,
+                alg );
+            operation->id = PSA_CRYPTO_CC3XX_DRIVER_ID;
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
-#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+            status = riscv_cm32_cipher_encrypt_setup( &operation->ctx.riscv_cm32_driver_ctx,
+                                            attributes,
+                                            key_buffer,
+                                            key_buffer_size,
+                                            alg );
+            if( status == PSA_SUCCESS ) {
+                operation->id = PSA_CRYPTO_RISCV_DRIVER_ID;
+                return( status );
+            }
+            
+            if ( status != PSA_ERROR_NOT_SUPPORTED ) {
+                return( status );    
+            }
+#endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_CIPHER) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             status = mbedtls_psa_cipher_encrypt_setup( &operation->ctx.mbedtls_ctx,
                                                        attributes,
@@ -1129,6 +1380,9 @@ psa_status_t psa_driver_wrapper_cipher_decrypt_setup(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -1146,8 +1400,32 @@ psa_status_t psa_driver_wrapper_cipher_decrypt_setup(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_cipher_decrypt_setup(
+                &operation->ctx.cc3xx_driver_ctx,
+                attributes,
+                key_buffer,
+                key_buffer_size,
+                alg );
+            operation->id = PSA_CRYPTO_CC3XX_DRIVER_ID;
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
-#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+            status = riscv_cm32_cipher_decrypt_setup( &operation->ctx.riscv_cm32_driver_ctx,
+                                                       attributes,
+                                                       key_buffer,
+                                                       key_buffer_size,
+                                                       alg );
+            if( status == PSA_SUCCESS )
+                operation->id = PSA_CRYPTO_RISCV_DRIVER_ID;
+            
+            if( status != PSA_ERROR_NOT_SUPPORTED )
+                return( status );
+#endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_CIPHER) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             status = mbedtls_psa_cipher_decrypt_setup( &operation->ctx.mbedtls_ctx,
                                                        attributes,
@@ -1195,7 +1473,14 @@ psa_status_t psa_driver_wrapper_cipher_set_iv(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+        case PSA_CRYPTO_RISCV_DRIVER_ID:
+            return( riscv_cm32_cipher_set_iv( &operation->ctx.riscv_cm32_driver_ctx,
+                                               iv,
+                                               iv_length ) );
+#endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_CIPHER) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_cipher_set_iv( &operation->ctx.mbedtls_ctx,
                                                iv,
@@ -1214,6 +1499,12 @@ psa_status_t psa_driver_wrapper_cipher_set_iv(
                         &operation->ctx.opaque_test_driver_ctx,
                         iv, iv_length ) );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_cipher_set_iv(
+                        &operation->ctx.cc3xx_driver_ctx,
+                        iv, iv_length ) );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1233,7 +1524,17 @@ psa_status_t psa_driver_wrapper_cipher_update(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+        case PSA_CRYPTO_RISCV_DRIVER_ID:
+            return( riscv_cm32_cipher_update( &operation->ctx.riscv_cm32_driver_ctx,
+                                        input,
+                                        input_length,
+                                        output,
+                                        output_size,
+                                        output_length ) );
+#endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_CIPHER) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_cipher_update( &operation->ctx.mbedtls_ctx,
                                                input,
@@ -1257,6 +1558,13 @@ psa_status_t psa_driver_wrapper_cipher_update(
                         input, input_length,
                         output, output_size, output_length ) );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_cipher_update(
+                        &operation->ctx.cc3xx_driver_ctx,
+                        input, input_length,
+                        output, output_size, output_length ) );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1277,7 +1585,15 @@ psa_status_t psa_driver_wrapper_cipher_finish(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+        case PSA_CRYPTO_RISCV_DRIVER_ID:
+            return( riscv_cm32_cipher_finish( &operation->ctx.riscv_cm32_driver_ctx,
+                                               output,
+                                               output_size,
+                                               output_length ) );
+#endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_CIPHER) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_cipher_finish( &operation->ctx.mbedtls_ctx,
                                                output,
@@ -1297,6 +1613,12 @@ psa_status_t psa_driver_wrapper_cipher_finish(
                         &operation->ctx.opaque_test_driver_ctx,
                         output, output_size, output_length ) );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_cipher_finish(
+                        &operation->ctx.cc3xx_driver_ctx,
+                        output, output_size, output_length ) );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX*/
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1314,7 +1636,12 @@ psa_status_t psa_driver_wrapper_cipher_abort(
 
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_CIPHER)
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+        case PSA_CRYPTO_RISCV_DRIVER_ID:
+            return( riscv_cm32_cipher_abort( &operation->ctx.riscv_cm32_driver_ctx ) );
+#endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_CIPHER) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_cipher_abort( &operation->ctx.mbedtls_ctx ) );
 #endif /* MBEDTLS_PSA_BUILTIN_CIPHER */
@@ -1337,6 +1664,15 @@ psa_status_t psa_driver_wrapper_cipher_abort(
                 sizeof( operation->ctx.opaque_test_driver_ctx ) );
             return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            status = cc3xx_cipher_abort(
+                         &operation->ctx.cc3xx_driver_ctx );
+            mbedtls_platform_zeroize(
+                &operation->ctx.cc3xx_driver_ctx,
+                sizeof( operation->ctx.cc3xx_driver_ctx ) );
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1358,15 +1694,34 @@ psa_status_t psa_driver_wrapper_hash_compute(
     psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
 
     /* Try accelerators first */
+#if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
     status = mbedtls_test_transparent_hash_compute(
                 alg, input, input_length, hash, hash_size, hash_length );
     if( status != PSA_ERROR_NOT_SUPPORTED )
         return( status );
+#endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+    status = cc3xx_hash_compute(alg, input, input_length, hash, hash_size,
+            hash_length);
+    return status;
+#endif /* defined(PSA_CRYPTO_DRIVER_CC3XX) */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+    /* If software fallback is compiled in, try fallback */
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+    status = riscv_cm32_hash_compute( alg, input, input_length,
+                                       hash, hash_size, hash_length );
+    if( status == PSA_SUCCESS ) {
+        return( status );
+    }
+    
+    if ( status != PSA_ERROR_NOT_SUPPORTED ) {
+        return( status );    
+    }
 #endif
 
-    /* If software fallback is compiled in, try fallback */
-#if defined(MBEDTLS_PSA_BUILTIN_HASH)
+#if defined(MBEDTLS_PSA_BUILTIN_HASH) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
     status = mbedtls_psa_hash_compute( alg, input, input_length,
                                        hash, hash_size, hash_length );
     if( status != PSA_ERROR_NOT_SUPPORTED )
@@ -1390,6 +1745,7 @@ psa_status_t psa_driver_wrapper_hash_setup(
     psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
 
     /* Try setup on accelerators first */
+#if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
     status = mbedtls_test_transparent_hash_setup(
                 &operation->ctx.test_driver_ctx, alg );
@@ -1398,17 +1754,35 @@ psa_status_t psa_driver_wrapper_hash_setup(
 
     if( status != PSA_ERROR_NOT_SUPPORTED )
         return( status );
+#endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+    status = cc3xx_hash_setup(&operation->ctx.cc3xx_driver_ctx, alg);
+    operation->id = PSA_CRYPTO_CC3XX_DRIVER_ID;
+    return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+    status = riscv_cm32_hash_setup( &operation->ctx.riscv_cm32_driver_ctx, alg );
+    if( status == PSA_SUCCESS ) {
+        operation->id = PSA_CRYPTO_RISCV_DRIVER_ID;
+        return( status );
+    }
+    
+    if ( status != PSA_ERROR_NOT_SUPPORTED ) {
+        return( status );    
+    }
 #endif
 
+#if defined(MBEDTLS_PSA_BUILTIN_HASH) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
     /* If software fallback is compiled in, try fallback */
-#if defined(MBEDTLS_PSA_BUILTIN_HASH)
     status = mbedtls_psa_hash_setup( &operation->ctx.mbedtls_ctx, alg );
     if( status == PSA_SUCCESS )
         operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
 
     if( status != PSA_ERROR_NOT_SUPPORTED )
         return( status );
-#endif
+#endif /* defined(MBEDTLS_PSA_BUILTIN_HASH) */
     /* Nothing left to try if we fall through here */
     (void) status;
     (void) operation;
@@ -1422,19 +1796,36 @@ psa_status_t psa_driver_wrapper_hash_clone(
 {
     switch( source_operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_HASH)
-        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
-            target_operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
-            return( mbedtls_psa_hash_clone( &source_operation->ctx.mbedtls_ctx,
-                                            &target_operation->ctx.mbedtls_ctx ) );
-#endif
+#if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
         case PSA_CRYPTO_TRANSPARENT_TEST_DRIVER_ID:
             target_operation->id = PSA_CRYPTO_TRANSPARENT_TEST_DRIVER_ID;
             return( mbedtls_test_transparent_hash_clone(
                         &source_operation->ctx.test_driver_ctx,
                         &target_operation->ctx.test_driver_ctx ) );
+#endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            target_operation->id = PSA_CRYPTO_CC3XX_DRIVER_ID;
+            return( cc3xx_hash_clone(
+                        &source_operation->ctx.cc3xx_driver_ctx,
+                        &target_operation->ctx.cc3xx_driver_ctx ) );
+
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+       case PSA_CRYPTO_RISCV_DRIVER_ID:
+            return ( riscv_cm32_hash_clone( &source_operation->ctx.riscv_cm32_driver_ctx,
+                                            &target_operation->ctx.riscv_cm32_driver_ctx ) );
 #endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_HASH) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
+            target_operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
+            return( mbedtls_psa_hash_clone( &source_operation->ctx.mbedtls_ctx,
+                                            &target_operation->ctx.mbedtls_ctx ) );
+#endif /* defined(MBEDTLS_PSA_BUILTIN_HASH) */
         default:
             (void) target_operation;
             return( PSA_ERROR_BAD_STATE );
@@ -1448,17 +1839,33 @@ psa_status_t psa_driver_wrapper_hash_update(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_HASH)
-        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
-            return( mbedtls_psa_hash_update( &operation->ctx.mbedtls_ctx,
-                                             input, input_length ) );
-#endif
+#if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
         case PSA_CRYPTO_TRANSPARENT_TEST_DRIVER_ID:
             return( mbedtls_test_transparent_hash_update(
                         &operation->ctx.test_driver_ctx,
                         input, input_length ) );
+#endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_hash_update(
+                        &operation->ctx.cc3xx_driver_ctx,
+                        input, input_length ) );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+       case PSA_CRYPTO_RISCV_DRIVER_ID:
+            return ( riscv_cm32_hash_update(
+                        &operation->ctx.riscv_cm32_driver_ctx,
+                        input, input_length ) );
 #endif
+
+#if defined(MBEDTLS_PSA_BUILTIN_HASH) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
+            return( mbedtls_psa_hash_update( &operation->ctx.mbedtls_ctx,
+                                             input, input_length ) );
+#endif /* defined(MBEDTLS_PSA_BUILTIN_HASH) */
         default:
             (void) input;
             (void) input_length;
@@ -1474,17 +1881,33 @@ psa_status_t psa_driver_wrapper_hash_finish(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_HASH)
-        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
-            return( mbedtls_psa_hash_finish( &operation->ctx.mbedtls_ctx,
-                                             hash, hash_size, hash_length ) );
-#endif
+#if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
         case PSA_CRYPTO_TRANSPARENT_TEST_DRIVER_ID:
             return( mbedtls_test_transparent_hash_finish(
                         &operation->ctx.test_driver_ctx,
                         hash, hash_size, hash_length ) );
-#endif
+#endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_hash_finish(
+                        &operation->ctx.cc3xx_driver_ctx,
+                        hash, hash_size, hash_length ) );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+       case PSA_CRYPTO_RISCV_DRIVER_ID:
+            return ( riscv_cm32_hash_finish(
+                        &operation->ctx.riscv_cm32_driver_ctx, 
+                        hash, hash_size, hash_length ) );
+#endif 
+
+#if defined(MBEDTLS_PSA_BUILTIN_HASH) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
+            return( mbedtls_psa_hash_finish( &operation->ctx.mbedtls_ctx,
+                                             hash, hash_size, hash_length ) );
+#endif /* defined(MBEDTLS_PSA_BUILTIN_HASH) */
         default:
             (void) hash;
             (void) hash_size;
@@ -1498,15 +1921,29 @@ psa_status_t psa_driver_wrapper_hash_abort(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_HASH)
-        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
-            return( mbedtls_psa_hash_abort( &operation->ctx.mbedtls_ctx ) );
-#endif
+#if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
         case PSA_CRYPTO_TRANSPARENT_TEST_DRIVER_ID:
             return( mbedtls_test_transparent_hash_abort(
                         &operation->ctx.test_driver_ctx ) );
-#endif
+#endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_hash_abort(
+                        &operation->ctx.cc3xx_driver_ctx ) );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+       case PSA_CRYPTO_RISCV_DRIVER_ID:
+            return ( riscv_cm32_hash_abort(
+                        &operation->ctx.riscv_cm32_driver_ctx ) );
+#endif 
+
+#if defined(MBEDTLS_PSA_BUILTIN_HASH) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
+            return( mbedtls_psa_hash_abort( &operation->ctx.mbedtls_ctx ) );
+#endif /* defined(MBEDTLS_PSA_BUILTIN_HASH) */
         default:
             return( PSA_ERROR_BAD_STATE );
     }
@@ -1528,6 +1965,9 @@ psa_status_t psa_driver_wrapper_aead_encrypt(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 
@@ -1544,8 +1984,19 @@ psa_status_t psa_driver_wrapper_aead_encrypt(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
-#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_aead_encrypt(
+                        attributes, key_buffer, key_buffer_size,
+                        alg,
+                        nonce, nonce_length,
+                        additional_data, additional_data_length,
+                        plaintext, plaintext_length,
+                        ciphertext, ciphertext_size, ciphertext_length );
 
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             return( mbedtls_psa_aead_encrypt(
                         attributes, key_buffer, key_buffer_size,
@@ -1554,7 +2005,7 @@ psa_status_t psa_driver_wrapper_aead_encrypt(
                         additional_data, additional_data_length,
                         plaintext, plaintext_length,
                         ciphertext, ciphertext_size, ciphertext_length ) );
-
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 
         default:
@@ -1580,6 +2031,9 @@ psa_status_t psa_driver_wrapper_aead_decrypt(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 
@@ -1596,8 +2050,19 @@ psa_status_t psa_driver_wrapper_aead_decrypt(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
-#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_aead_decrypt(
+                        attributes, key_buffer, key_buffer_size,
+                        alg,
+                        nonce, nonce_length,
+                        additional_data, additional_data_length,
+                        ciphertext, ciphertext_length,
+                        plaintext, plaintext_size, plaintext_length );
 
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             return( mbedtls_psa_aead_decrypt(
                         attributes, key_buffer, key_buffer_size,
@@ -1606,7 +2071,7 @@ psa_status_t psa_driver_wrapper_aead_decrypt(
                         additional_data, additional_data_length,
                         ciphertext, ciphertext_length,
                         plaintext, plaintext_size, plaintext_length ) );
-
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 
         default:
@@ -1622,14 +2087,30 @@ psa_status_t psa_driver_get_tag_len( psa_aead_operation_t *operation,
     if( operation == NULL || tag_len == NULL )
         return( PSA_ERROR_INVALID_ARGUMENT );
 
+    switch( operation->id )
+    {
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            *tag_len = operation->ctx.cc3xx_driver_ctx.tag_length;
+            return ( PSA_SUCCESS );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #if defined(PSA_CRYPTO_DRIVER_TEST)
-    *tag_len = operation->ctx.transparent_test_driver_ctx.tag_length;
-    return ( PSA_SUCCESS );
-#endif
-#endif
-    *tag_len = operation->ctx.mbedtls_ctx.tag_length;
-    return ( PSA_SUCCESS );
+        case PSA_CRYPTO_TRANSPARENT_TEST_DRIVER_ID:
+            *tag_len = operation->ctx.transparent_test_driver_ctx.tag_length;
+            return ( PSA_SUCCESS );
+#endif /* defined(PSA_CRYPTO_DRIVER_TEST) */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if defined(MBEDTLS_PSA_BUILTIN_AEAD) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
+            *tag_len = operation->ctx.mbedtls_ctx.tag_length;
+             return ( PSA_SUCCESS );
+#endif /* defined(MBEDTLS_PSA_BUILTIN_AEAD) */
+        default:
+            return( PSA_ERROR_INVALID_ARGUMENT );
+    }
+
+    return( PSA_ERROR_INVALID_ARGUMENT );
 }
 
 psa_status_t psa_driver_wrapper_aead_encrypt_setup(
@@ -1645,6 +2126,9 @@ psa_status_t psa_driver_wrapper_aead_encrypt_setup(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 
@@ -1660,8 +2144,17 @@ psa_status_t psa_driver_wrapper_aead_encrypt_setup(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
-#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            operation->id = PSA_CRYPTO_CC3XX_DRIVER_ID;
+            status = cc3xx_aead_encrypt_setup(
+                    &operation->ctx.cc3xx_driver_ctx,
+                    attributes, key_buffer, key_buffer_size,
+                    alg );
 
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
             status = mbedtls_psa_aead_encrypt_setup(
@@ -1670,7 +2163,7 @@ psa_status_t psa_driver_wrapper_aead_encrypt_setup(
                         alg );
 
             return( status );
-
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 
         default:
@@ -1693,6 +2186,9 @@ psa_status_t psa_driver_wrapper_aead_decrypt_setup(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 
@@ -1709,8 +2205,18 @@ psa_status_t psa_driver_wrapper_aead_decrypt_setup(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
-#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            operation->id = PSA_CRYPTO_CC3XX_DRIVER_ID;
+            status = cc3xx_aead_decrypt_setup(
+                    &operation->ctx.cc3xx_driver_ctx,
+                    attributes,
+                    key_buffer, key_buffer_size,
+                    alg );
 
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             operation->id = PSA_CRYPTO_MBED_TLS_DRIVER_ID;
             status = mbedtls_psa_aead_decrypt_setup(
@@ -1720,7 +2226,7 @@ psa_status_t psa_driver_wrapper_aead_decrypt_setup(
                         alg );
 
             return( status );
-
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 
         default:
@@ -1737,7 +2243,7 @@ psa_status_t psa_driver_wrapper_aead_set_nonce(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_AEAD)
+#if defined(MBEDTLS_PSA_BUILTIN_AEAD) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_aead_set_nonce( &operation->ctx.mbedtls_ctx,
                                                 nonce,
@@ -1755,6 +2261,13 @@ psa_status_t psa_driver_wrapper_aead_set_nonce(
         /* Add cases for opaque driver here */
 
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_aead_set_nonce(
+                    &operation->ctx.cc3xx_driver_ctx,
+                    nonce, nonce_length ) );
+
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1771,7 +2284,7 @@ psa_status_t psa_driver_wrapper_aead_set_lengths(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_AEAD)
+#if defined(MBEDTLS_PSA_BUILTIN_AEAD) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_aead_set_lengths( &operation->ctx.mbedtls_ctx,
                                                   ad_length,
@@ -1789,6 +2302,13 @@ psa_status_t psa_driver_wrapper_aead_set_lengths(
         /* Add cases for opaque driver here */
 
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_aead_set_lengths(
+                    &operation->ctx.cc3xx_driver_ctx,
+                    ad_length, plaintext_length ) );
+
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1805,7 +2325,7 @@ psa_status_t psa_driver_wrapper_aead_update_ad(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_AEAD)
+#if defined(MBEDTLS_PSA_BUILTIN_AEAD) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_aead_update_ad( &operation->ctx.mbedtls_ctx,
                                                 input,
@@ -1823,6 +2343,13 @@ psa_status_t psa_driver_wrapper_aead_update_ad(
         /* Add cases for opaque driver here */
 
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_aead_update_ad(
+                    &operation->ctx.cc3xx_driver_ctx,
+                    input, input_length ) );
+
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1842,7 +2369,7 @@ psa_status_t psa_driver_wrapper_aead_update(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_AEAD)
+#if defined(MBEDTLS_PSA_BUILTIN_AEAD) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_aead_update( &operation->ctx.mbedtls_ctx,
                                              input, input_length,
@@ -1862,6 +2389,14 @@ psa_status_t psa_driver_wrapper_aead_update(
         /* Add cases for opaque driver here */
 
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_aead_update(
+                    &operation->ctx.cc3xx_driver_ctx,
+                    input, input_length, output, output_size,
+                    output_length ) );
+
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1885,7 +2420,7 @@ psa_status_t psa_driver_wrapper_aead_finish(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_AEAD)
+#if defined(MBEDTLS_PSA_BUILTIN_AEAD) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_aead_finish( &operation->ctx.mbedtls_ctx,
                                              ciphertext,
@@ -1906,6 +2441,14 @@ psa_status_t psa_driver_wrapper_aead_finish(
         /* Add cases for opaque driver here */
 
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_aead_finish(
+                    &operation->ctx.cc3xx_driver_ctx,
+                    ciphertext, ciphertext_size,
+                    ciphertext_length, tag, tag_size, tag_length ) );
+
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1929,7 +2472,7 @@ psa_status_t psa_driver_wrapper_aead_verify(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_AEAD)
+#if defined(MBEDTLS_PSA_BUILTIN_AEAD) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             {
                 psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
@@ -1970,6 +2513,14 @@ psa_status_t psa_driver_wrapper_aead_verify(
         /* Add cases for opaque driver here */
 
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return( cc3xx_aead_verify(
+                    &operation->ctx.cc3xx_driver_ctx,
+                    plaintext, plaintext_size,
+                    plaintext_length, tag, tag_length ) );
+
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -1987,7 +2538,7 @@ psa_status_t psa_driver_wrapper_aead_abort(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_AEAD)
+#if defined(MBEDTLS_PSA_BUILTIN_AEAD) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_aead_abort( &operation->ctx.mbedtls_ctx ) );
 
@@ -2002,6 +2553,12 @@ psa_status_t psa_driver_wrapper_aead_abort(
         /* Add cases for opaque driver here */
 
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+    case PSA_CRYPTO_CC3XX_DRIVER_ID:
+        return( cc3xx_aead_abort(
+                &operation->ctx.cc3xx_driver_ctx ) );
+
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
     }
 
@@ -2029,6 +2586,9 @@ psa_status_t psa_driver_wrapper_mac_compute(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -2041,8 +2601,14 @@ psa_status_t psa_driver_wrapper_mac_compute(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_mac_compute(attributes, key_buffer, key_buffer_size, alg,
+                input, input_length,
+                mac, mac_size, mac_length);
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
-#if defined(MBEDTLS_PSA_BUILTIN_MAC)
+#if defined(MBEDTLS_PSA_BUILTIN_MAC) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             status = mbedtls_psa_mac_compute(
                 attributes, key_buffer, key_buffer_size, alg,
@@ -2093,6 +2659,9 @@ psa_status_t psa_driver_wrapper_mac_sign_setup(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -2109,8 +2678,17 @@ psa_status_t psa_driver_wrapper_mac_sign_setup(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_mac_sign_setup(
+                    &operation->ctx.cc3xx_driver_ctx,
+                    attributes,
+                    key_buffer, key_buffer_size,
+                    alg);
+            operation->id = PSA_CRYPTO_CC3XX_DRIVER_ID;
+            return status;
+#endif /* defined(PSA_CRYPTO_DRIVER_CC3XX) */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
-#if defined(MBEDTLS_PSA_BUILTIN_MAC)
+#if defined(MBEDTLS_PSA_BUILTIN_MAC) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             status = mbedtls_psa_mac_sign_setup( &operation->ctx.mbedtls_ctx,
                                                  attributes,
@@ -2165,6 +2743,9 @@ psa_status_t psa_driver_wrapper_mac_verify_setup(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
@@ -2181,8 +2762,17 @@ psa_status_t psa_driver_wrapper_mac_verify_setup(
             if( status != PSA_ERROR_NOT_SUPPORTED )
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_mac_verify_setup(
+                &operation->ctx.cc3xx_driver_ctx,
+                attributes,
+                key_buffer, key_buffer_size,
+                alg);
+            operation->id = PSA_CRYPTO_CC3XX_DRIVER_ID;
+            return status;
+#endif /* defined(PSA_CRYPTO_DRIVER_CC3XX) */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
-#if defined(MBEDTLS_PSA_BUILTIN_MAC)
+#if defined(MBEDTLS_PSA_BUILTIN_MAC) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
             /* Fell through, meaning no accelerator supports this operation */
             status = mbedtls_psa_mac_verify_setup( &operation->ctx.mbedtls_ctx,
                                                    attributes,
@@ -2230,7 +2820,7 @@ psa_status_t psa_driver_wrapper_mac_update(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_MAC)
+#if defined(MBEDTLS_PSA_BUILTIN_MAC) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_mac_update( &operation->ctx.mbedtls_ctx,
                                             input, input_length ) );
@@ -2248,6 +2838,10 @@ psa_status_t psa_driver_wrapper_mac_update(
                         &operation->ctx.opaque_test_driver_ctx,
                         input, input_length ) );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return(cc3xx_mac_update(&operation->ctx.cc3xx_driver_ctx, input, input_length));
+#endif /* defined(PSA_CRYPTO_DRIVER_CC3XX) */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
         default:
             (void) input;
@@ -2264,7 +2858,7 @@ psa_status_t psa_driver_wrapper_mac_sign_finish(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_MAC)
+#if defined(MBEDTLS_PSA_BUILTIN_MAC) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_mac_sign_finish( &operation->ctx.mbedtls_ctx,
                                                  mac, mac_size, mac_length ) );
@@ -2282,6 +2876,11 @@ psa_status_t psa_driver_wrapper_mac_sign_finish(
                         &operation->ctx.opaque_test_driver_ctx,
                         mac, mac_size, mac_length ) );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return(cc3xx_mac_sign_finish(&operation->ctx.cc3xx_driver_ctx,
+                        mac, mac_size, mac_length));
+#endif /* defined(PSA_CRYPTO_DRIVER_CC3XX) */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
         default:
             (void) mac;
@@ -2298,7 +2897,7 @@ psa_status_t psa_driver_wrapper_mac_verify_finish(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_MAC)
+#if defined(MBEDTLS_PSA_BUILTIN_MAC) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_mac_verify_finish( &operation->ctx.mbedtls_ctx,
                                                    mac, mac_length ) );
@@ -2316,6 +2915,12 @@ psa_status_t psa_driver_wrapper_mac_verify_finish(
                         &operation->ctx.opaque_test_driver_ctx,
                         mac, mac_length ) );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return(cc3xx_mac_verify_finish(
+                        &operation->ctx.cc3xx_driver_ctx,
+                        mac, mac_length));
+#endif /* defined(PSA_CRYPTO_DRIVER_CC3XX) */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
         default:
             (void) mac;
@@ -2329,7 +2934,7 @@ psa_status_t psa_driver_wrapper_mac_abort(
 {
     switch( operation->id )
     {
-#if defined(MBEDTLS_PSA_BUILTIN_MAC)
+#if defined(MBEDTLS_PSA_BUILTIN_MAC) && !defined(PSA_CRYPTO_DRIVER_CC3XX)
         case PSA_CRYPTO_MBED_TLS_DRIVER_ID:
             return( mbedtls_psa_mac_abort( &operation->ctx.mbedtls_ctx ) );
 #endif /* MBEDTLS_PSA_BUILTIN_MAC */
@@ -2343,6 +2948,10 @@ psa_status_t psa_driver_wrapper_mac_abort(
             return( mbedtls_test_opaque_mac_abort(
                         &operation->ctx.opaque_test_driver_ctx ) );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        case PSA_CRYPTO_CC3XX_DRIVER_ID:
+            return(cc3xx_mac_abort(&operation->ctx.cc3xx_driver_ctx));
+#endif /* defined(PSA_CRYPTO_DRIVER_CC3XX) */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
         default:
             return( PSA_ERROR_INVALID_ARGUMENT );
@@ -2350,7 +2959,61 @@ psa_status_t psa_driver_wrapper_mac_abort(
 }
 
 /*
- * Asymmetric cryptography
+ * Key agreement functions
+ */
+psa_status_t psa_driver_wrapper_key_agreement(
+        psa_algorithm_t alg,
+        const psa_key_attributes_t *attributes,
+        const uint8_t *priv_key, size_t priv_key_size,
+        const uint8_t *publ_key, size_t publ_key_size,
+        uint8_t *output, size_t output_size, size_t *output_length )
+{
+    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
+
+    psa_key_location_t location =
+            PSA_KEY_LIFETIME_GET_LOCATION( attributes->core.lifetime );
+
+    switch( location )
+    {
+    case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
+        /* Key is stored in the slot in export representation, so
+         * cycle through all known transparent accelerators */
+#if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+        status = cc3xx_key_agreement( attributes,
+                                      priv_key,
+                                      priv_key_size,
+                                      publ_key,
+                                      publ_key_size,
+                                      output,
+                                      output_size,
+                                      output_length,
+                                      alg );
+        return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
+#endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+        (void) status;
+        return ( PSA_ERROR_NOT_SUPPORTED );
+    default:
+        /* Key is declared with a lifetime not known to us */
+        (void) priv_key;
+        (void) priv_key_size;
+        (void) publ_key;
+        (void) publ_key_size;
+        (void) output;
+        (void) output_size;
+        (void) output_length;
+        (void) alg;
+
+        return( PSA_ERROR_INVALID_ARGUMENT );
+    }
+}
+
+/*
+ * Asymmetric operations
  */
 psa_status_t psa_driver_wrapper_asymmetric_encrypt(
     const psa_key_attributes_t *attributes, const uint8_t *key_buffer,
@@ -2365,9 +3028,26 @@ psa_status_t psa_driver_wrapper_asymmetric_encrypt(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_asymmetric_encrypt( attributes,
+                                               key_buffer,
+                                               key_buffer_size,
+                                               alg,
+                                               input,
+                                               input_length,
+                                               salt,
+                                               salt_length,
+                                               output,
+                                               output_size,
+                                               output_length );
+            return( status );
+#endif  /* PSA_CRYPTO_DRIVER_CC3XX */
 #if defined(PSA_CRYPTO_DRIVER_TEST)
             status = mbedtls_test_transparent_asymmetric_encrypt( attributes,
                         key_buffer, key_buffer_size, alg, input, input_length,
@@ -2378,10 +3058,12 @@ psa_status_t psa_driver_wrapper_asymmetric_encrypt(
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
             return( mbedtls_psa_asymmetric_encrypt( attributes,
                         key_buffer, key_buffer_size, alg, input, input_length,
                         salt, salt_length, output, output_size, output_length )
                   );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
@@ -2423,9 +3105,26 @@ psa_status_t psa_driver_wrapper_asymmetric_decrypt(
     switch( location )
     {
         case PSA_KEY_LOCATION_LOCAL_STORAGE:
+#if defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER)
+        case TFM_BUILTIN_KEY_LOADER_KEY_LOCATION:
+#endif /* defined(PSA_CRYPTO_DRIVER_TFM_BUILTIN_KEY_LOADER) */
             /* Key is stored in the slot in export representation, so
              * cycle through all known transparent accelerators */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
+#if defined(PSA_CRYPTO_DRIVER_CC3XX)
+            status = cc3xx_asymmetric_decrypt( attributes,
+                                               key_buffer,
+                                               key_buffer_size,
+                                               alg,
+                                               input,
+                                               input_length,
+                                               salt,
+                                               salt_length,
+                                               output,
+                                               output_size,
+                                               output_length );
+            return( status );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
 #if defined(PSA_CRYPTO_DRIVER_TEST)
             status = mbedtls_test_transparent_asymmetric_decrypt( attributes,
                         key_buffer, key_buffer_size, alg, input, input_length,
@@ -2436,10 +3135,12 @@ psa_status_t psa_driver_wrapper_asymmetric_decrypt(
                 return( status );
 #endif /* PSA_CRYPTO_DRIVER_TEST */
 #endif /* PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT */
+#if !defined(PSA_CRYPTO_DRIVER_CC3XX)
             return( mbedtls_psa_asymmetric_decrypt( attributes,
                         key_buffer, key_buffer_size, alg,input, input_length,
                         salt, salt_length, output, output_size,
                         output_length ) );
+#endif /* PSA_CRYPTO_DRIVER_CC3XX */
         /* Add cases for opaque driver here */
 #if defined(PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT)
 #if defined(PSA_CRYPTO_DRIVER_TEST)
diff --git a/library/psa_crypto_driver_wrappers.h b/library/psa_crypto_driver_wrappers.h
index 12c649da..ac0cd1d8 100644
--- a/library/psa_crypto_driver_wrappers.h
+++ b/library/psa_crypto_driver_wrappers.h
@@ -361,6 +361,20 @@ psa_status_t psa_driver_wrapper_asymmetric_decrypt(
     size_t output_size,
     size_t *output_length );
 
+/*
+ * Key agreement functions
+ */
+psa_status_t psa_driver_wrapper_key_agreement(
+        psa_algorithm_t alg,
+        const psa_key_attributes_t *attributes,
+        const uint8_t *priv_key,
+        size_t priv_key_size,
+        const uint8_t *publ_key,
+        size_t peer_key_size,
+        uint8_t *output,
+        size_t output_size,
+        size_t *output_length );
+
 #endif /* PSA_CRYPTO_DRIVER_WRAPPERS_H */
 
 /* End of automatically generated file. */
diff --git a/library/psa_crypto_hash.c b/library/psa_crypto_hash.c
index 536c6c11..286aa975 100644
--- a/library/psa_crypto_hash.c
+++ b/library/psa_crypto_hash.c
@@ -27,6 +27,7 @@
 #include "psa_crypto_hash.h"
 
 #include <mbedtls/error.h>
+#include <mbedtls/sm3.h>
 #include <string.h>
 
 #if defined(MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN) || \
@@ -64,6 +65,10 @@ const mbedtls_md_info_t *mbedtls_md_info_from_psa( psa_algorithm_t alg )
 #if defined(MBEDTLS_SHA512_C)
         case PSA_ALG_SHA_512:
             return( &mbedtls_sha512_info );
+#endif
+#if defined(MBEDTLS_SM3_C)
+        case PSA_ALG_SM3:
+            return( &mbedtls_sm3_info );
 #endif
         default:
             return( NULL );
@@ -119,6 +124,11 @@ psa_status_t mbedtls_psa_hash_abort(
         case PSA_ALG_SHA_512:
             mbedtls_sha512_free( &operation->ctx.sha512 );
             break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)
+        case PSA_ALG_SM3:
+            mbedtls_sm3_free( &operation->ctx.sm3 );
+            break;
 #endif
         default:
             return( PSA_ERROR_BAD_STATE );
@@ -131,8 +141,7 @@ psa_status_t mbedtls_psa_hash_setup(
     mbedtls_psa_hash_operation_t *operation,
     psa_algorithm_t alg )
 {
-    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
-
+    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED; 
     /* A context must be freshly initialized before it can be set up. */
     if( operation->alg != 0 )
     {
@@ -182,6 +191,12 @@ psa_status_t mbedtls_psa_hash_setup(
             mbedtls_sha512_init( &operation->ctx.sha512 );
             ret = mbedtls_sha512_starts( &operation->ctx.sha512, 0 );
             break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)
+        case PSA_ALG_SM3:
+            mbedtls_sm3_init( &operation->ctx.sm3 );
+            ret = mbedtls_sm3_starts( &operation->ctx.sm3);
+            break;
 #endif
         default:
             return( PSA_ALG_IS_HASH( alg ) ?
@@ -244,6 +259,12 @@ psa_status_t mbedtls_psa_hash_clone(
             mbedtls_sha512_clone( &target_operation->ctx.sha512,
                                   &source_operation->ctx.sha512 );
             break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)
+        case PSA_ALG_SM3:
+            mbedtls_sm3_clone( &target_operation->ctx.sm3,
+                                  &source_operation->ctx.sm3 );
+            break;
 #endif
         default:
             (void) source_operation;
@@ -304,7 +325,13 @@ psa_status_t mbedtls_psa_hash_update(
         case PSA_ALG_SHA_512:
             ret = mbedtls_sha512_update( &operation->ctx.sha512,
                                              input, input_length );
-            break;
+            break;            
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)
+        case PSA_ALG_SM3:
+            ret = mbedtls_sm3_update( &operation->ctx.sm3,
+                                             input, input_length );                                
+            break;            
 #endif
         default:
             (void) input;
@@ -376,6 +403,11 @@ psa_status_t mbedtls_psa_hash_finish(
         case PSA_ALG_SHA_512:
             ret = mbedtls_sha512_finish( &operation->ctx.sha512, hash );
             break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)
+        case PSA_ALG_SM3:
+            ret = mbedtls_sm3_finish( &operation->ctx.sm3, hash );
+            break;
 #endif
         default:
             (void) hash;
diff --git a/library/psa_crypto_mac.c b/library/psa_crypto_mac.c
index dcf065a6..bede8d7e 100644
--- a/library/psa_crypto_mac.c
+++ b/library/psa_crypto_mac.c
@@ -59,12 +59,11 @@ static psa_status_t psa_hmac_setup_internal(
      * `block_size > sizeof( ipad ) || block_size > sizeof( hmac->opad )`
      * because that triggers -Wlogical-op on GCC 7.3. */
     if( block_size > sizeof( ipad ) )
-        return( PSA_ERROR_NOT_SUPPORTED );
+        return( PSA_ERROR_NOT_SUPPORTED ); 
     if( block_size > sizeof( hmac->opad ) )
         return( PSA_ERROR_NOT_SUPPORTED );
     if( block_size < hash_size )
         return( PSA_ERROR_NOT_SUPPORTED );
-
     if( key_length > block_size )
     {
         status = psa_hash_compute( hash_alg, key, key_length,
diff --git a/library/riscv_cm32_psa_cipher.c b/library/riscv_cm32_psa_cipher.c
new file mode 100644
index 00000000..d8930c8d
--- /dev/null
+++ b/library/riscv_cm32_psa_cipher.c
@@ -0,0 +1,583 @@
+#include <string.h>
+#include "psa/cm32m4xxr_aes.h"
+#include "psa/crypto_types.h"
+#include "riscv_cm32_psa_cipher.h"
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+
+static psa_status_t riscv_cm32_cipher_psa_cipher_setup(
+    risv_cm32_driver_cipher_context_t *operation,
+    const psa_key_attributes_t *attributes,
+    const uint8_t *key_buffer, size_t key_buffer_size,
+    psa_algorithm_t alg,
+    uint32_t cipher_operation )
+{
+    uint32_t ret = 0;
+    size_t key_bits;
+    psa_key_type_t key_type = attributes->private_core.private_type;
+
+    key_bits = attributes->private_core.private_bits;
+
+    memset(&operation->unhandled_data, 0, 16);
+    operation->unhandled_data_length = 0;
+    switch( key_type )
+    {
+        case PSA_KEY_TYPE_AES:
+            memset(&operation->param.aes_ctx, 0, sizeof(AES_PARM));
+
+            if ( key_bits != 128 ) /* only support AES-128 */
+                return( PSA_ERROR_NOT_SUPPORTED );
+
+            operation->param.aes_ctx.En_De = cipher_operation ? (AES_ENC): (AES_DEC);
+            switch( alg ) {
+                case PSA_ALG_ECB_NO_PADDING:
+                    operation->param.aes_ctx.Mode = AES_ECB;
+                    break;
+                case PSA_ALG_CBC_NO_PADDING:
+                    operation->param.aes_ctx.Mode = AES_CBC;
+                    break;
+                case PSA_ALG_CTR:
+                    operation->param.aes_ctx.Mode = AES_CTR;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+
+            operation->param.aes_ctx.keyWordLen = key_buffer_size / sizeof(uint32_t);
+            operation->param.aes_ctx.key = (uint32_t *)key_buffer;
+            ret = AES_Init(&operation->param.aes_ctx);
+            if ( ret != AES_Init_OK ) {
+                return( PSA_ERROR_NOT_SUPPORTED );
+            }
+
+            break;
+
+        case PSA_KEY_TYPE_DES:
+            memset(&operation->param.des_ctx, 0, sizeof(DES_PARM));
+
+            switch( key_bits ) {
+                case 64:
+                    operation->param.des_ctx.keyMode = DES_KEY;
+                    break;
+                case 128:
+                    operation->param.des_ctx.keyMode = TDES_2KEY;
+                    break;
+                case 192:
+                    operation->param.des_ctx.keyMode = TDES_3KEY;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+
+            operation->param.des_ctx.En_De = cipher_operation ? (DES_ENC): (DES_DEC);
+            switch( alg ) {
+                case PSA_ALG_ECB_NO_PADDING:
+                    operation->param.des_ctx.Mode = DES_ECB;
+                    break;
+                case PSA_ALG_CBC_NO_PADDING:
+                    operation->param.des_ctx.Mode = DES_CBC;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+
+            operation->param.des_ctx.key = (uint32_t *)key_buffer;
+            ret = DES_Init(&operation->param.des_ctx);
+            if ( ret != DES_Init_OK ) {
+                return( PSA_ERROR_NOT_SUPPORTED );
+            }
+
+            break;
+
+        case PSA_KEY_TYPE_SM4:
+            memset(&operation->param.sm4_ctx, 0, sizeof(SM4_PARM));
+
+            if ( key_bits != 128 ) /* only support SM4-128 */
+                return( PSA_ERROR_NOT_SUPPORTED );
+            
+            operation->param.sm4_ctx.EnDeMode = cipher_operation ? (SM4_ENC): (SM4_DEC);
+            switch( alg ) {
+                case PSA_ALG_ECB_NO_PADDING:
+                    operation->param.sm4_ctx.workingMode = SM4_ECB;
+                    break;
+                case PSA_ALG_CBC_NO_PADDING:
+                    operation->param.sm4_ctx.workingMode = SM4_CBC;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+
+            operation->param.sm4_ctx.key = (uint32_t *)key_buffer;
+            ret = SM4_Init(&operation->param.sm4_ctx);
+            if ( ret != SM4_Init_OK ) {
+                return( PSA_ERROR_NOT_SUPPORTED );
+            }
+            break;
+        default:
+            return( PSA_ERROR_BAD_STATE );            
+    }
+
+    operation->alg = alg;
+    operation->key_type = key_type;
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_cipher_encrypt_setup(
+    risv_cm32_driver_cipher_context_t *operation,
+    const psa_key_attributes_t *attributes,
+    const uint8_t *key_buffer, size_t key_buffer_size,
+    psa_algorithm_t alg )
+{
+    return( riscv_cm32_cipher_psa_cipher_setup( operation, attributes,
+                              key_buffer, key_buffer_size,
+                              alg, MBEDTLS_ENCRYPT ) );
+}
+
+psa_status_t riscv_cm32_cipher_decrypt_setup(
+    risv_cm32_driver_cipher_context_t *operation,
+    const psa_key_attributes_t *attributes,
+    const uint8_t *key_buffer, size_t key_buffer_size,
+    psa_algorithm_t alg )
+{
+    return( riscv_cm32_cipher_psa_cipher_setup( operation, attributes,
+                              key_buffer, key_buffer_size,
+                              alg, MBEDTLS_DECRYPT ) );
+}
+
+psa_status_t riscv_cm32_cipher_set_iv(
+    risv_cm32_driver_cipher_context_t *operation,
+    const uint8_t *iv, size_t iv_length )
+{
+    switch( operation->key_type ) {
+        case PSA_KEY_TYPE_AES:
+            switch( operation->alg ) {
+                case PSA_ALG_ECB_NO_PADDING:
+                    if (iv_length != 0)
+                        return( PSA_ERROR_BAD_STATE );
+                    operation->param.aes_ctx.iv = NULL;
+                    break;
+                case PSA_ALG_CBC_NO_PADDING:
+                case PSA_ALG_CTR:
+                    if (iv_length != 16)
+                        return( PSA_ERROR_BAD_STATE );
+                    operation->param.aes_ctx.iv = (uint32_t*)iv;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+            break;
+        case PSA_KEY_TYPE_DES:
+            switch( operation->alg  ) {
+                case PSA_ALG_ECB_NO_PADDING:
+                    if (iv_length != 0)
+                        return( PSA_ERROR_BAD_STATE );
+                    operation->param.des_ctx.iv = NULL;
+                    break;
+                case PSA_ALG_CBC_NO_PADDING:
+                    if (iv_length != 8)
+                        return( PSA_ERROR_BAD_STATE );
+                    operation->param.des_ctx.iv = (uint32_t*)iv;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+            break;
+        case PSA_KEY_TYPE_SM4:
+            switch( operation->alg  ) {
+                case PSA_ALG_ECB_NO_PADDING:
+                    if (iv_length != 0)
+                        return( PSA_ERROR_BAD_STATE );
+                    operation->param.sm4_ctx.iv = NULL;
+                    break;
+                case PSA_ALG_CBC_NO_PADDING:
+                    if (iv_length != 16)
+                        return( PSA_ERROR_BAD_STATE );
+                    operation->param.sm4_ctx.iv = (uint32_t*)iv;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+            break;
+        default:
+            return( PSA_ERROR_BAD_STATE );
+    }
+
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_cipher_update(
+    risv_cm32_driver_cipher_context_t *operation,
+    const uint8_t *input, size_t input_length,
+    uint8_t *output, size_t output_size, size_t *output_length )
+{
+    uint32_t ret = 0;
+
+    size_t block_size = 0;
+    size_t copy_size  = 0;
+
+    uint8_t *data = (uint8_t*)input;
+    size_t   data_size = input_length;
+    size_t   update_size = 0;
+    size_t   block_numbs = 0;
+    size_t   unhdl_bytes = 0;
+
+    switch( operation->key_type ) {
+        case PSA_KEY_TYPE_AES:
+            block_size = 16; 
+            break;
+        case PSA_KEY_TYPE_DES:
+            block_size =  8;
+            break;
+        case PSA_KEY_TYPE_SM4:
+            block_size = 16;
+            break;
+        default:
+            return( PSA_ERROR_BAD_STATE );
+    }
+
+    if (operation->unhandled_data_length > 0) {
+        copy_size = (block_size - operation->unhandled_data_length);
+        copy_size = (copy_size < data_size)?(copy_size):(data_size);
+        memcpy(&operation->unhandled_data[operation->unhandled_data_length], 
+                data, copy_size);
+        operation->unhandled_data_length += copy_size;
+
+        data      += copy_size;
+        data_size -= copy_size;        
+    }
+    block_numbs = data_size / block_size;
+    unhdl_bytes = data_size % block_size;
+    data_size   = data_size - unhdl_bytes;
+
+    /* step1: update */
+    if (operation->unhandled_data_length == block_size) {
+        if (output_size < block_size) {
+            return( PSA_ERROR_BUFFER_TOO_SMALL );
+        }
+
+        switch( operation->key_type ) {
+            case PSA_KEY_TYPE_AES:
+                operation->param.aes_ctx.in  = (uint32_t*)operation->unhandled_data;
+                operation->param.aes_ctx.out = (uint32_t*)output;
+                operation->param.aes_ctx.inWordLen = block_size / sizeof(uint32_t);
+                ret = AES_Crypto(&operation->param.aes_ctx);
+                if ( ret != AES_Crypto_OK ) {
+                    return( PSA_ERROR_GENERIC_ERROR );
+                }
+                break;
+            case PSA_KEY_TYPE_DES:
+                operation->param.des_ctx.in  = (uint32_t*)operation->unhandled_data;
+                operation->param.des_ctx.out = (uint32_t*)output;
+                operation->param.des_ctx.inWordLen = block_size / sizeof(uint32_t);
+                ret = DES_Crypto(&operation->param.des_ctx);
+                if ( ret != DES_Crypto_OK ) {
+                    return( PSA_ERROR_GENERIC_ERROR );
+                }
+                break;
+            case PSA_KEY_TYPE_SM4:
+                operation->param.sm4_ctx.in  = (uint32_t*)operation->unhandled_data;
+                operation->param.sm4_ctx.out = (uint32_t*)output;
+                operation->param.sm4_ctx.inWordLen = block_size / sizeof(uint32_t);
+                ret = SM4_Crypto(&operation->param.sm4_ctx);
+                if ( ret != SM4_Crypto_OK ) {
+                    return( PSA_ERROR_GENERIC_ERROR );
+                }
+                break;
+        }
+
+        output_size -= block_size;
+        output      += block_size;
+        update_size += block_size;
+
+        operation->unhandled_data_length = 0;
+    }
+
+    /* step1: update */
+    if (block_numbs > 0) {
+        if (output_size < block_size) {
+            return( PSA_ERROR_BUFFER_TOO_SMALL );
+        }
+
+        switch( operation->key_type ) {
+            case PSA_KEY_TYPE_AES:
+                operation->param.aes_ctx.in  = (uint32_t*)data;
+                operation->param.aes_ctx.out = (uint32_t*)output;
+                operation->param.aes_ctx.inWordLen = data_size / sizeof(uint32_t);
+                ret = AES_Crypto(&operation->param.aes_ctx);
+                if ( ret != AES_Crypto_OK ) {
+                    return( PSA_ERROR_GENERIC_ERROR );
+                }
+                break;
+            case PSA_KEY_TYPE_DES:
+                operation->param.des_ctx.in  = (uint32_t*)data;
+                operation->param.des_ctx.out = (uint32_t*)output;
+                operation->param.des_ctx.inWordLen = data_size / sizeof(uint32_t);
+                ret = DES_Crypto(&operation->param.des_ctx);
+                if ( ret != DES_Crypto_OK ) {
+                    return( PSA_ERROR_GENERIC_ERROR );
+                }
+                break;
+            case PSA_KEY_TYPE_SM4:
+                operation->param.sm4_ctx.in  = (uint32_t*)data;
+                operation->param.sm4_ctx.out = (uint32_t*)output;
+                operation->param.sm4_ctx.inWordLen = data_size / sizeof(uint32_t);
+                ret = SM4_Crypto(&operation->param.sm4_ctx);
+                if ( ret != SM4_Crypto_OK ) {
+                    return( PSA_ERROR_GENERIC_ERROR );
+                }
+                break;
+        }
+
+        data        += data_size;
+        output_size -= data_size;
+        output      += data_size;
+        update_size += data_size;
+    }
+
+    if (unhdl_bytes > 0) {
+        memcpy(&operation->unhandled_data[operation->unhandled_data_length], 
+                data, unhdl_bytes);
+        operation->unhandled_data_length += unhdl_bytes;
+    }
+
+    *output_length = update_size;
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_cipher_finish(
+    risv_cm32_driver_cipher_context_t *operation,
+    uint8_t *output, size_t output_size, size_t *output_length )
+{
+    uint32_t ret = 0;
+    size_t block_size = 0;
+    size_t update_size = 0;
+
+    switch( operation->key_type ) {
+        case PSA_KEY_TYPE_AES:
+            block_size = 16; 
+            break;
+        case PSA_KEY_TYPE_DES:
+            block_size =  8;
+            break;
+        case PSA_KEY_TYPE_SM4:
+            block_size = 16;
+            break;
+        default:
+            return( PSA_ERROR_BAD_STATE );
+    }
+
+    /* step1: update */
+    if (operation->unhandled_data_length == block_size) {
+        if (output_size < block_size) {
+            return( PSA_ERROR_BUFFER_TOO_SMALL );
+        }
+
+        switch( operation->key_type ) {
+            case PSA_KEY_TYPE_AES:
+                operation->param.aes_ctx.in  = (uint32_t*)operation->unhandled_data;
+                operation->param.aes_ctx.out = (uint32_t*)output;
+                operation->param.aes_ctx.inWordLen = block_size / sizeof(uint32_t);
+                ret = AES_Crypto(&operation->param.aes_ctx);
+                if ( ret != AES_Crypto_OK ) {
+                    return( PSA_ERROR_GENERIC_ERROR );
+                }
+                break;
+            case PSA_KEY_TYPE_DES:
+                operation->param.des_ctx.in  = (uint32_t*)operation->unhandled_data;
+                operation->param.des_ctx.out = (uint32_t*)output;
+                operation->param.des_ctx.inWordLen = block_size / sizeof(uint32_t);
+                ret = DES_Crypto(&operation->param.des_ctx);
+                if ( ret != DES_Crypto_OK ) {
+                    return( PSA_ERROR_GENERIC_ERROR );
+                }
+                break;
+            case PSA_KEY_TYPE_SM4:
+                operation->param.sm4_ctx.in  = (uint32_t*)operation->unhandled_data;
+                operation->param.sm4_ctx.out = (uint32_t*)output;
+                operation->param.sm4_ctx.inWordLen = block_size / sizeof(uint32_t);
+                ret = SM4_Crypto(&operation->param.sm4_ctx);
+                if ( ret != SM4_Crypto_OK ) {
+                    return( PSA_ERROR_GENERIC_ERROR );
+                }
+                break;
+        }
+
+        update_size += block_size;
+        
+        operation->unhandled_data_length = 0;
+    }
+
+    *output_length = update_size;
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_cipher_abort( risv_cm32_driver_cipher_context_t *operation )
+{
+    switch( operation->key_type ) {
+        case PSA_KEY_TYPE_AES:
+            AES_Close();
+            break;
+        case PSA_KEY_TYPE_DES:
+            DES_Close();
+            break;
+        case PSA_KEY_TYPE_SM4:
+            SM4_Close();
+            break;
+        default:
+            return( PSA_ERROR_BAD_STATE );
+    }
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_cipher_encrypt( const psa_key_attributes_t *attributes,
+                                         const uint8_t *key_buffer,
+                                         size_t key_buffer_size,
+                                         psa_algorithm_t alg,
+                                         const uint8_t *iv,
+                                         size_t iv_length,
+                                         const uint8_t *input,
+                                         size_t input_length,
+                                         uint8_t *output,
+                                         size_t output_size,
+                                         size_t *output_length )
+{
+    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
+    risv_cm32_driver_cipher_context_t operation;
+    size_t update_output_length = 0;
+    size_t finish_output_length = 0;
+
+    status = riscv_cm32_cipher_encrypt_setup( &operation, attributes,
+                                               key_buffer, key_buffer_size,
+                                               alg );
+    if( status != PSA_SUCCESS )
+        goto exit;
+
+    if( iv_length > 0 )
+    {
+        status = riscv_cm32_cipher_set_iv( &operation, iv, iv_length );
+        if( status != PSA_SUCCESS )
+            goto exit;
+    }
+
+    status = riscv_cm32_cipher_update( &operation, input, input_length,
+                                        output, output_size,
+                                        &update_output_length );
+    if( status != PSA_SUCCESS )
+        goto exit;
+
+    status = riscv_cm32_cipher_finish( &operation,
+                                        output + update_output_length,
+                                        output_size - update_output_length,
+                                        &finish_output_length );
+    if( status != PSA_SUCCESS )
+        goto exit;
+
+    *output_length = update_output_length + finish_output_length;
+
+exit:
+    if( status == PSA_SUCCESS ){
+        status = riscv_cm32_cipher_abort( &operation );
+    }
+        
+    else
+        riscv_cm32_cipher_abort( &operation );
+    return( status );
+}
+
+psa_status_t riscv_cm32_cipher_decrypt( const psa_key_attributes_t *attributes,
+                                         const uint8_t *key_buffer,
+                                         size_t key_buffer_size,
+                                         psa_algorithm_t alg,
+                                         const uint8_t *input,
+                                         size_t input_length,
+                                         uint8_t *output,
+                                         size_t output_size,
+                                         size_t *output_length )
+{
+    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
+    risv_cm32_driver_cipher_context_t operation;
+    size_t olength, accumulated_length;
+    size_t iv_length;
+
+    status = riscv_cm32_cipher_decrypt_setup( &operation, attributes,
+                                               key_buffer, key_buffer_size,
+                                               alg );                                              
+    if( status != PSA_SUCCESS )
+        goto exit;
+
+
+    switch( operation.key_type ) {
+        case PSA_KEY_TYPE_AES:
+            switch( operation.alg ) {
+                case PSA_ALG_ECB_NO_PADDING:
+                    iv_length = 0;
+                    break;
+                case PSA_ALG_CBC_NO_PADDING:
+                case PSA_ALG_CTR:
+                    iv_length = 16;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+            break;
+        case PSA_KEY_TYPE_DES:
+            switch( operation.alg  ) {
+                case PSA_ALG_ECB_NO_PADDING:
+                    iv_length = 0;
+                    break;
+                case PSA_ALG_CBC_NO_PADDING:
+                    iv_length = 8;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+            break;
+        case PSA_KEY_TYPE_SM4:
+            switch( operation.alg  ) {
+                case PSA_ALG_ECB_NO_PADDING:
+                    iv_length = 0;   
+                    break;
+                case PSA_ALG_CBC_NO_PADDING:
+                    iv_length = 16;
+                    break;
+                default:
+                    return( PSA_ERROR_NOT_SUPPORTED );
+            }
+            break;
+        default:
+            return( PSA_ERROR_BAD_STATE );
+    }
+
+    if( iv_length > 0 )
+    {
+        status = riscv_cm32_cipher_set_iv( &operation,
+                                            input, iv_length );                                           
+        if( status != PSA_SUCCESS )
+            goto exit;
+    }
+
+    status = riscv_cm32_cipher_update( &operation, input + iv_length,
+                                        input_length - iv_length,
+                                        output, output_size, &olength );                                       
+    if( status != PSA_SUCCESS )
+        goto exit;
+
+    accumulated_length = olength;
+
+    status = riscv_cm32_cipher_finish( &operation, output + accumulated_length,
+                                        output_size - accumulated_length,
+                                        &olength );
+    if( status != PSA_SUCCESS )
+        goto exit;
+
+    *output_length = accumulated_length + olength;
+
+exit:
+    if ( status == PSA_SUCCESS )
+        status = riscv_cm32_cipher_abort( &operation );
+    else
+        riscv_cm32_cipher_abort( &operation );
+
+    return( status );
+}
+#endif
diff --git a/library/riscv_cm32_psa_cipher.h b/library/riscv_cm32_psa_cipher.h
new file mode 100644
index 00000000..249c7309
--- /dev/null
+++ b/library/riscv_cm32_psa_cipher.h
@@ -0,0 +1,57 @@
+#ifndef RISCV_CM32_PSA_AES_H
+#define RISCV_CM32_PSA_AES_H
+#ifdef PSA_CRYPTO_DRIVER_RISCV_CM32
+#include "psa/crypto.h"
+#include "psa/cm32m4xxr_aes.h"
+
+psa_status_t riscv_cm32_cipher_encrypt_setup(
+    risv_cm32_driver_cipher_context_t *operation,
+    const psa_key_attributes_t *attributes,
+    const uint8_t *key_buffer, size_t key_buffer_size,
+    psa_algorithm_t alg );
+
+psa_status_t riscv_cm32_cipher_decrypt_setup(
+    risv_cm32_driver_cipher_context_t *operation,
+    const psa_key_attributes_t *attributes,
+    const uint8_t *key_buffer, size_t key_buffer_size,
+    psa_algorithm_t alg );
+
+psa_status_t riscv_cm32_cipher_set_iv(
+    risv_cm32_driver_cipher_context_t *operation,
+    const uint8_t *iv, size_t iv_length );
+
+psa_status_t riscv_cm32_cipher_update(
+    risv_cm32_driver_cipher_context_t *operation,
+    const uint8_t *input, size_t input_length,
+    uint8_t *output, size_t output_size, size_t *output_length );
+
+psa_status_t riscv_cm32_cipher_finish(
+    risv_cm32_driver_cipher_context_t *operation,
+    uint8_t *output, size_t output_size, size_t *output_length );
+
+psa_status_t riscv_cm32_cipher_abort( risv_cm32_driver_cipher_context_t *operation );
+
+psa_status_t riscv_cm32_cipher_encrypt( const psa_key_attributes_t *attributes,
+                                         const uint8_t *key_buffer,
+                                         size_t key_buffer_size,
+                                         psa_algorithm_t alg,
+                                         const uint8_t *iv,
+                                         size_t iv_length,
+                                         const uint8_t *input,
+                                         size_t input_length,
+                                         uint8_t *output,
+                                         size_t output_size,
+                                         size_t *output_length );
+
+psa_status_t riscv_cm32_cipher_decrypt( const psa_key_attributes_t *attributes,
+                                         const uint8_t *key_buffer,
+                                         size_t key_buffer_size,
+                                         psa_algorithm_t alg,
+                                         const uint8_t *input,
+                                         size_t input_length,
+                                         uint8_t *output,
+                                         size_t output_size,
+                                         size_t *output_length );
+
+#endif
+#endif /* RISCV_CM32_PSA_AES_H */
diff --git a/library/riscv_cm32_psa_hash.c b/library/riscv_cm32_psa_hash.c
new file mode 100644
index 00000000..d7a0da8c
--- /dev/null
+++ b/library/riscv_cm32_psa_hash.c
@@ -0,0 +1,224 @@
+#include <string.h>
+#include "psa/cm32m4xxr_hash.h"
+#include "psa/crypto_types.h"
+#include "riscv_cm32_psa_hash.h"
+
+#if defined(PSA_CRYPTO_DRIVER_RISCV_CM32)
+
+psa_status_t riscv_cm32_hash_setup(
+    HASH_CTX *ctx,
+    psa_algorithm_t alg )
+{
+    uint32_t ret = HASH_Init_ERROR;
+    switch( alg )
+    {
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_MD5)          
+        case PSA_ALG_MD5:
+            ctx->hashAlg = HASH_ALG_MD5;
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_1)          
+        case PSA_ALG_SHA_1:
+            ctx->hashAlg = HASH_ALG_SHA1;
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)            
+        case PSA_ALG_SHA_224:
+            ctx->hashAlg = HASH_ALG_SHA224;
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256)            
+        case PSA_ALG_SHA_256:
+            ctx->hashAlg = HASH_ALG_SHA256;
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)            
+        case PSA_ALG_SM3:
+            ctx->hashAlg = HASH_ALG_SM3;
+            break;
+#endif            
+        default:
+            return( PSA_ERROR_NOT_SUPPORTED );
+    }
+
+    ctx->sequence = HASH_SEQUENCE_FALSE;
+
+    ret = HASH_Init(ctx);
+    if ( ret != HASH_Init_OK ) {
+        return( PSA_ERROR_NOT_SUPPORTED );
+    }
+    ret = HASH_Start(ctx);
+    if ( ret != HASH_Start_OK ) {
+        return( PSA_ERROR_NOT_SUPPORTED );
+    }
+
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_hash_clone(
+    const HASH_CTX *source_ctx,
+    HASH_CTX *target_ctx )
+{
+    switch( source_ctx->hashAlg->HashAlgID )
+    {
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_MD5)             
+        case ALG_MD5:
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_1)              
+        case ALG_SHA1:
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)            
+        case ALG_SHA224:
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256)               
+        case ALG_SHA256:
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)             
+        case ALG_SM3:
+            break;
+#endif            
+        default:
+             return( PSA_ERROR_BAD_STATE );
+    }
+
+    memcpy( target_ctx, source_ctx, sizeof(HASH_CTX) );
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_hash_update(
+    HASH_CTX *ctx,
+    const uint8_t *input,
+    size_t input_length )
+{
+    uint32_t ret = HASH_Update_ERROR;
+    switch( ctx->hashAlg->HashAlgID )
+    {
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_MD5)         
+        case ALG_MD5:
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_1)              
+        case ALG_SHA1:
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)            
+        case ALG_SHA224:
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256)              
+        case ALG_SHA256:
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)             
+        case ALG_SM3:
+            break;
+#endif            
+        default:
+             return( PSA_ERROR_BAD_STATE );
+    }
+
+    ret = HASH_Update( ctx, ( uint8_t* )input, input_length );
+    if ( ret != HASH_Update_OK ) {
+        return( PSA_ERROR_GENERIC_ERROR );
+    }
+
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_hash_finish(
+    HASH_CTX *ctx,
+    uint8_t *hash,
+    size_t hash_size,
+    size_t *hash_length )
+{
+    size_t actual_hash_length = 0;
+
+    uint32_t ret = HASH_Update_ERROR;
+    switch( ctx->hashAlg->HashAlgID )
+    {
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_MD5)         
+        case ALG_MD5:
+            actual_hash_length = 16;
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_1)              
+        case ALG_SHA1:
+            actual_hash_length = 20;
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_224)            
+        case ALG_SHA224:
+            actual_hash_length = 28;
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SHA_256)               
+        case ALG_SHA256:
+            actual_hash_length = 32;
+            break;
+#endif
+#if defined(MBEDTLS_PSA_BUILTIN_ALG_SM3)             
+        case ALG_SM3:
+            actual_hash_length = 32;
+            break;
+#endif            
+        default:
+             return( PSA_ERROR_BAD_STATE );
+    }
+
+    if( hash_size < actual_hash_length ) {
+        return( PSA_ERROR_BUFFER_TOO_SMALL );
+    }
+
+    ret = HASH_Complete( ctx, hash );
+    if ( ret != HASH_Complete_OK ) {
+        return( PSA_ERROR_GENERIC_ERROR );
+    }
+
+    *hash_length = actual_hash_length;
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_hash_abort(
+    HASH_CTX *ctx )
+{
+    HASH_Close();
+
+    return( PSA_SUCCESS );
+}
+
+psa_status_t riscv_cm32_hash_compute(
+    psa_algorithm_t alg,
+    const uint8_t *input,
+    size_t input_length,
+    uint8_t *hash,
+    size_t hash_size,
+    size_t *hash_length)
+{
+    HASH_CTX ctx;
+    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;
+    psa_status_t abort_status = PSA_ERROR_CORRUPTION_DETECTED;
+
+    *hash_length = hash_size;
+    status = riscv_cm32_hash_setup( &ctx, alg );
+    if( status != PSA_SUCCESS )
+        goto exit;
+    status = riscv_cm32_hash_update( &ctx, input, input_length );
+    if( status != PSA_SUCCESS )
+        goto exit;
+    status = riscv_cm32_hash_finish( &ctx, hash, hash_size, hash_length );
+    if( status != PSA_SUCCESS )
+        goto exit;
+
+exit:
+    abort_status = riscv_cm32_hash_abort( &ctx );
+    if( status == PSA_SUCCESS )
+        return( abort_status );
+    else
+        return( status );
+}
+
+#endif /* PSA_CRYPTO_DRIVER_RISCV_CM32 */
diff --git a/library/riscv_cm32_psa_hash.h b/library/riscv_cm32_psa_hash.h
new file mode 100644
index 00000000..3b157d3b
--- /dev/null
+++ b/library/riscv_cm32_psa_hash.h
@@ -0,0 +1,37 @@
+#ifndef RISCV_CM32_PSA_HASH_H
+#define RISCV_CM32_PSA_HASH_H
+
+#include "psa/crypto.h"
+#include "psa/cm32m4xxr_hash.h"
+
+psa_status_t riscv_cm32_hash_compute(
+    psa_algorithm_t alg,
+    const uint8_t *input,
+    size_t input_length,
+    uint8_t *hash,
+    size_t hash_size,
+    size_t *hash_length);
+
+psa_status_t riscv_cm32_hash_setup(
+    HASH_CTX *ctx,
+    psa_algorithm_t alg );
+
+psa_status_t riscv_cm32_hash_clone(
+    const HASH_CTX *source_ctx,
+    HASH_CTX *target_ctx );
+
+psa_status_t riscv_cm32_hash_update(
+    HASH_CTX *ctx,
+    const uint8_t *input,
+    size_t input_length );
+
+psa_status_t riscv_cm32_hash_finish(
+    HASH_CTX *ctx,
+    uint8_t *hash,
+    size_t hash_size,
+    size_t *hash_length );
+
+psa_status_t riscv_cm32_hash_abort(
+    HASH_CTX *ctx );
+
+#endif 
diff --git a/library/sm2.c b/library/sm2.c
new file mode 100644
index 00000000..56f4cf97
--- /dev/null
+++ b/library/sm2.c
@@ -0,0 +1,874 @@
+/*
+ * SM2 Encryption alogrithm
+ *
+ * References:
+ * - GM/T 0003-2012 Chinese National Standard:
+ *      Public Key Cryptographic Algorithm SM2 Based on Elliptic Curves
+ * - GM/T 0009-2012 SM2 cryptography algorithm application specification
+ * - GM/T 0015-2012 Digital certificate format based on SM2 algorithm
+ *
+ * Thanks to MbedTLS.
+ */
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "mbedtls/mbedtls_config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+
+#if defined(MBEDTLS_SM2_C)
+
+#include "mbedtls/sm2.h"
+
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#define mbedtls_calloc      calloc
+#define mbedtls_printf      printf
+#define mbedtls_free        free
+#endif /* MBEDTLS_PLATFORM_C */
+
+#if !defined(MBEDTLS_SM2_ALT)
+
+#if !defined(MBEDTLS_SM2_CRYPT_ALT) || !defined(MBEDTLS_SM2_SIGN_ALT)
+/**
+ * Get random r in [1, n-1]
+ */
+static int sm2_get_rand(mbedtls_sm2_context *ctx, mbedtls_mpi *r,
+        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
+{
+    int ret;
+    size_t blind_tries = 0;
+    size_t nlen;
+    do {
+        nlen = (ctx->grp.nbits + 7) / 8;
+        MBEDTLS_MPI_CHK(mbedtls_mpi_fill_random(r, nlen, f_rng, p_rng));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(r, 8 * nlen - ctx->grp.nbits));
+
+        /* See mbedtls_ecp_gen_keypair() */
+        if (++blind_tries > 30)
+            return (MBEDTLS_ERR_SM2_RANDOM_FAILED);
+    } while (mbedtls_mpi_cmp_int(r, 1) < 0 ||
+            mbedtls_mpi_cmp_mpi(r, &ctx->grp.N) >= 0);
+cleanup:
+    return (ret);
+}
+#endif /* !MBEDTLS_SM2_CRYPT_ALT || !MBEDTLS_SM2_SIGN_ALT */
+
+#if !defined(MBEDTLS_SM2_CRYPT_ALT)
+/**
+ * SM2 KDF (ISO/IEC 15946-2 3.1.3)
+ * (GM/T 0003-2012 - Part 3: Key Exchange Protocol 5.4.3)
+ */
+static int mbedtls_sm2_pbkdf2(mbedtls_md_context_t *ctx,
+        const unsigned char *password, size_t plen,
+        const unsigned char *salt, size_t slen,
+        unsigned int iteration_count,
+        uint32_t key_length, unsigned char *output)
+{
+    int ret, j;
+    unsigned int i;
+    unsigned char md1[MBEDTLS_MD_MAX_SIZE];
+    unsigned char work[MBEDTLS_MD_MAX_SIZE];
+    unsigned char md_size = mbedtls_md_get_size(ctx->md_info);
+    size_t use_len;
+    unsigned char *out_p = output;
+    unsigned char counter[4];
+
+    memset(counter, 0, 4);
+    counter[3] = 1;
+
+    if (iteration_count > 0xFFFFFFFF)
+        return (MBEDTLS_ERR_SM2_BAD_INPUT_DATA);
+
+    while (key_length) {
+        /* U1 ends up in work */
+        if ((ret = mbedtls_md_starts(ctx)) != 0)
+            return ret;
+        if ((ret = mbedtls_md_update(ctx, password, plen)) != 0)
+            return ret;
+        if ((ret = mbedtls_md_update(ctx, salt, slen)) != 0)
+            return ret;
+        if ((ret = mbedtls_md_update(ctx, counter, 4)) != 0)
+            return ret;
+        if ((ret = mbedtls_md_finish(ctx, work)) != 0)
+            return ret;
+
+        memcpy(md1, work, md_size);
+
+        for (i = 1; i < iteration_count; i++) {
+            /* U2 ends up in md1 */
+            if ((ret = mbedtls_md_hmac_starts(ctx, password, plen)) != 0)
+                return (ret);
+            if ((ret = mbedtls_md_hmac_update(ctx, md1, md_size)) != 0)
+                return (ret);
+            if ((ret = mbedtls_md_hmac_finish(ctx, md1)) != 0)
+                return (ret);
+
+            /* U1 xor U2 */
+            for (j = 0; j < md_size; j++)
+                work[j] ^= md1[j];
+        }
+
+        use_len = (key_length < md_size) ? key_length : md_size;
+        memcpy(out_p, work, use_len);
+
+        key_length -= (uint32_t)use_len;
+        out_p += use_len;
+
+        for (i = 4; i > 0; i--)
+            if (++counter[i - 1] != 0)
+                break;
+    }
+
+    return (0);
+}
+
+int mbedtls_sm2_encrypt(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const unsigned char *input, size_t ilen,
+        unsigned char *output, size_t *olen,
+        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
+{
+    int ret = 0;
+    size_t i;
+    mbedtls_mpi k;
+    mbedtls_mpi h;
+    mbedtls_ecp_point point;
+    mbedtls_md_context_t md_ctx;
+    size_t xlen, ylen;
+    unsigned char *xym = NULL;
+
+    mbedtls_mpi_init(&k);
+    mbedtls_mpi_init(&h);
+    mbedtls_md_init(&md_ctx);
+    mbedtls_ecp_point_init(&point);
+    MBEDTLS_MPI_CHK(mbedtls_md_setup(&md_ctx,
+                mbedtls_md_info_from_type(md_alg), 0));
+
+    do {
+        /* A1: rand k in [1, n-1] */
+        MBEDTLS_MPI_CHK(sm2_get_rand(ctx, &k, f_rng, p_rng));
+
+        /* A2: C1 = [k]G = (x1, y1) */
+        MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&ctx->grp, &point, &k, &ctx->grp.G,
+                    NULL, NULL));
+        output[0] = MBEDTLS_ECP_POINT_CONVERSION_UNCOMPRESSED;
+        *olen = 1;
+        MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.X, output + *olen,
+                    mbedtls_mpi_size(&point.X)));
+        *olen += mbedtls_mpi_size(&point.X);
+        MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.Y, output + *olen,
+                    mbedtls_mpi_size(&point.Y)));
+        *olen += mbedtls_mpi_size(&point.Y);
+
+        /* A3: check [h]P != O */
+        MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&h, 1));
+        MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&ctx->grp, &point, &h, &ctx->Q,
+                    NULL, NULL));
+        MBEDTLS_MPI_CHK(mbedtls_ecp_is_zero(&point));
+
+        /* A4: [k]P = (x2, y2) */
+        MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&ctx->grp, &point, &k, &ctx->Q,
+                    NULL, NULL));
+
+        /* A5: t = KDF(x2 || y2, klen) */
+        xlen = mbedtls_mpi_size(&point.X);
+        ylen = mbedtls_mpi_size(&point.Y);
+        if ((xym = mbedtls_calloc(1, xlen + ylen + ilen)) == NULL) {
+            MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_ALLOC_FAILED);
+        }
+        MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.X, xym, xlen));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.Y, xym + xlen, ylen));
+        MBEDTLS_MPI_CHK(mbedtls_sm2_pbkdf2(&md_ctx, xym, xlen + ylen,
+                    NULL, 0, 0, ilen, xym + xlen + ylen));
+        for (i = 0; i < ilen; i++) {
+            if (*(xym + xlen + ylen + i)) {
+                break;
+            }
+        }
+        if (i >= xlen + ylen) {
+            continue;
+        }
+
+        break;
+    } while (0);
+
+    /* A6: C2 = M xor t */
+    for (i = 0; i < ilen; i++) {
+        output[*olen + i] = input[i] ^ *(xym + xlen + ylen + i);
+    }
+    *olen += ilen;
+
+    /* A7: C3 = Hash(x2 || M || y2) */
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.X, xym, xlen));
+    memmove(xym + xlen, input, ilen);
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.Y, xym + xlen + ilen, ylen));
+    MBEDTLS_MPI_CHK(mbedtls_md(md_ctx.md_info, xym, xlen + ilen + ylen,
+                output + *olen));
+    *olen += mbedtls_md_get_size(md_ctx.md_info);
+
+cleanup:
+    mbedtls_mpi_free(&k);
+    mbedtls_mpi_free(&h);
+    mbedtls_ecp_point_free(&point);
+    if (xym) {
+        mbedtls_free(xym);
+    }
+    mbedtls_md_free(&md_ctx);
+
+    return (ret);
+}
+
+int mbedtls_sm2_decrypt(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const unsigned char *input, size_t ilen,
+        unsigned char *output, size_t *olen)
+{
+    int ret = 0;
+    size_t i;
+    mbedtls_mpi h;
+    mbedtls_ecp_point C1;
+    mbedtls_ecp_point point;
+    mbedtls_md_context_t md_ctx;
+    size_t c1len, ptlen, mdlen, xlen, ylen;
+    unsigned char *xym = NULL;
+
+    mbedtls_ecp_point_init(&C1);
+    mbedtls_ecp_point_init(&point);
+    mbedtls_mpi_init(&h);
+    mbedtls_md_init(&md_ctx);
+    MBEDTLS_MPI_CHK(mbedtls_md_setup(&md_ctx,
+                mbedtls_md_info_from_type(md_alg), 0));
+
+    /* B1: get C1 */
+    c1len = 1 + (ctx->grp.nbits + 7) / 8 * 2;
+    MBEDTLS_MPI_CHK(mbedtls_ecp_point_read_binary(&ctx->grp, &C1,
+                input, c1len));
+
+    /* B2: check [h]C1 != O */
+    MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&h, 1));
+    MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&ctx->grp, &point, &h, &C1, NULL, NULL));
+    MBEDTLS_MPI_CHK(mbedtls_ecp_is_zero(&point));
+
+    /* B3: [d]C1 = (x2, y2) */
+    MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&ctx->grp, &point, &ctx->d, &C1,
+                NULL, NULL));
+
+    /* B4: t = KDF(x2 || y2, klen) */
+    xlen = mbedtls_mpi_size(&point.X);
+    ylen = mbedtls_mpi_size(&point.Y);
+    mdlen = mbedtls_md_get_size(md_ctx.md_info);
+    ptlen = ilen - c1len - mdlen;
+    if ((xym = mbedtls_calloc(1, xlen + ylen + ptlen)) == NULL) {
+        MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_ALLOC_FAILED);
+    }
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.X, xym, xlen));
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.Y, xym + xlen, ylen));
+    MBEDTLS_MPI_CHK(mbedtls_sm2_pbkdf2(&md_ctx, xym, xlen + ylen,
+                NULL, 0, 0, ptlen, xym + xlen + ylen));
+    for (i = 0; i < ptlen; i++) {
+        if (*(xym + xlen + ylen + i)) {
+            break;
+        }
+    }
+    if (i >= xlen + ylen) {
+        MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_KDF_FAILED);
+    }
+
+    /* B5: M' = C2 xor t */
+    for (i = 0; i < ptlen; i++) {
+        output[i] = input[c1len + i] ^ *(xym + xlen + ylen + i);
+    }
+    *olen = ptlen;
+
+    /* B6: check Hash(x2 || M' || y2) == C3 */
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.X, xym, xlen));
+    memmove(xym + xlen, output, *olen);
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&point.Y,
+                xym + xlen + *olen, ylen));
+    MBEDTLS_MPI_CHK(mbedtls_md(md_ctx.md_info, xym, xlen + *olen + ylen, xym));
+    if (memcmp(input + c1len + ptlen, xym, mdlen)) {
+        MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_DECRYPT_BAD_HASH);
+    }
+
+cleanup:
+    mbedtls_mpi_free(&h);
+    mbedtls_ecp_point_free(&point);
+    mbedtls_ecp_point_free(&C1);
+    if (xym) {
+        mbedtls_free(xym);
+    }
+    mbedtls_md_free(&md_ctx);
+
+    return (ret);
+}
+#endif /* !MBEDTLS_SM2_CRYPT_ALT */
+
+#if !defined(MBEDTLS_SM2_SIGN_ALT)
+int mbedtls_sm2_sign(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const unsigned char *hash, unsigned char *sig,
+        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
+{
+    int ret = 0;
+    mbedtls_mpi k;
+    mbedtls_mpi e;
+    mbedtls_mpi r;
+    mbedtls_mpi s;
+    mbedtls_ecp_point point;
+
+    mbedtls_mpi_init(&e);
+    mbedtls_mpi_init(&k);
+    mbedtls_mpi_init(&r);
+    mbedtls_mpi_init(&s);
+    mbedtls_ecp_point_init(&point);
+
+    /**
+     * A1: M' = Z || M
+     * A2: e = Hash(M')
+     * Parameter <hash> is the digest of <M'>, need convert to bignum <e>.
+     */
+    do {
+        /* A3: rand k in [1, n-1] */
+        MBEDTLS_MPI_CHK(sm2_get_rand(ctx, &k, f_rng, p_rng));
+
+        /* A4: (x1, y1) = [k]G */
+        MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&ctx->grp, &point, &k, &ctx->grp.G,
+                    NULL, NULL));
+
+        /* A5: r = (e + x1) mod n; if (r == 0 || r + k == n) goto A3; */
+        MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&e, hash,
+                    mbedtls_md_get_size(mbedtls_md_info_from_type(md_alg))));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&r, &e, &point.X));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&r, &r, &ctx->grp.N));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&s, &r, &k));
+        if (mbedtls_mpi_cmp_int(&r, 0) == 0 ||
+                mbedtls_mpi_cmp_mpi(&s, &ctx->grp.N) == 0) {
+            continue;
+        }
+        MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&r, sig,
+                    mbedtls_mpi_size(&r)));
+
+        /* A6: s = (((1 + d)^-1) * (k - r * d)) mod n; if (s == 0) goto A3; */
+        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&r, &r, &ctx->d));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&r, &k, &r));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&s, &ctx->d, 1));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_inv_mod(&s, &s, &ctx->grp.N));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&s, &s, &r));
+        MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&s, &s, &ctx->grp.N));
+        if (mbedtls_mpi_cmp_int(&s, 0) == 0) {
+            continue;
+        }
+
+        break;
+    } while (1);
+
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&s, sig + (ctx->grp.nbits + 7) / 8,
+                mbedtls_mpi_size(&s)));
+
+cleanup:
+    mbedtls_mpi_free(&k);
+    mbedtls_mpi_free(&e);
+    mbedtls_mpi_free(&r);
+    mbedtls_mpi_free(&s);
+    mbedtls_ecp_point_free(&point);
+
+    return (ret);
+}
+
+int mbedtls_sm2_verify(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const unsigned char *hash, const unsigned char *sig)
+{
+    int ret = 0;
+    mbedtls_mpi r;
+    mbedtls_mpi s;
+    mbedtls_mpi e;
+    mbedtls_mpi t;
+    mbedtls_ecp_point point;
+
+    mbedtls_mpi_init(&r);
+    mbedtls_mpi_init(&s);
+    mbedtls_mpi_init(&e);
+    mbedtls_mpi_init(&t);
+    mbedtls_ecp_point_init(&point);
+
+    /* B1,B2: check r, s in [1, n-1] */
+    MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&r, sig, (ctx->grp.nbits + 7) / 8));
+    MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&s, sig + (ctx->grp.nbits + 7) / 8,
+            (ctx->grp.nbits + 7) / 8));
+    if (mbedtls_mpi_cmp_int(&r, 1) < 0 ||
+            mbedtls_mpi_cmp_mpi(&r, &ctx->grp.N) >= 0 ||
+            mbedtls_mpi_cmp_int(&s, 1) < 0 ||
+            mbedtls_mpi_cmp_mpi(&s, &ctx->grp.N) >= 0) {
+        MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_BAD_SIGNATURE - 1);
+    }
+
+    /**
+     * B3: M' = Z || M
+     * B4: e' = Hash(M')
+     * Parameter <hash> is the digest of <M'>, need convert to bignum <e>.
+     */
+    MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&e, hash,
+                mbedtls_md_get_size(mbedtls_md_info_from_type(md_alg))));
+
+    /* B5: t = (r + s) mod n; if (t == 0) return error; */
+    MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&t, &r, &s));
+    MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&t, &t, &ctx->grp.N));
+    if (mbedtls_mpi_cmp_int(&t, 0) == 0) {
+        MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_BAD_SIGNATURE - 2);
+    }
+
+    /* B6: (x1, y1) = [s]G + [t]P */
+    MBEDTLS_MPI_CHK(mbedtls_ecp_muladd(&ctx->grp, &point,
+                &s, &ctx->grp.G, &t, &ctx->Q));
+
+    /* B7: R = (e + x1) mod n; if (R == r) Success; else Failed; */
+    mbedtls_mpi_free(&t);
+    mbedtls_mpi_init(&t);
+    MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&t, &e, &point.X));
+    MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&t, &t, &ctx->grp.N));
+    if (mbedtls_mpi_cmp_mpi(&t, &r) != 0) {
+        MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_BAD_SIGNATURE - 3);
+    }
+
+cleanup:
+    mbedtls_mpi_free(&r);
+    mbedtls_mpi_free(&s);
+    mbedtls_mpi_free(&e);
+    mbedtls_mpi_free(&t);
+    mbedtls_ecp_point_free(&point);
+
+    return (ret);
+}
+
+int mbedtls_sm2_hash_z(mbedtls_sm2_context *ctx, mbedtls_md_type_t md_alg,
+        const char *id, size_t idlen, unsigned char *z)
+{
+    int ret = 0;
+    unsigned char * m = NULL;
+    unsigned char * p;
+    size_t mlen;
+    size_t l;
+    const char * def_id = MBEDTLS_SM2_GMT09_DEFAULT_ID;
+    size_t def_id_len = strlen(def_id);
+    const mbedtls_md_info_t * md_info = NULL;
+
+    if (id != NULL) {
+        def_id = (char *)id;
+        def_id_len = idlen;
+    }
+    md_info = mbedtls_md_info_from_type(md_alg);
+    if (md_info == NULL) {
+        MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_BAD_INPUT_DATA);
+    }
+    mlen = 2 + def_id_len
+        + mbedtls_mpi_size(&ctx->grp.A) + mbedtls_mpi_size(&ctx->grp.B)
+        + mbedtls_mpi_size(&ctx->grp.G.X) + mbedtls_mpi_size(&ctx->grp.G.Y)
+        + mbedtls_mpi_size(&ctx->Q.X) + mbedtls_mpi_size(&ctx->Q.Y);
+    if ((m = mbedtls_calloc(1, mlen)) == NULL) {
+        MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_ALLOC_FAILED);
+    }
+
+    m[0] = (def_id_len >> 5) & 0xFF;
+    m[1] = (def_id_len << 3) & 0xFF;
+    p = m + 2;
+    memmove(p, def_id, def_id_len);
+    p += def_id_len;
+    l = mbedtls_mpi_size(&ctx->grp.A);
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&ctx->grp.A, p, l));
+    p += l;
+    l = mbedtls_mpi_size(&ctx->grp.B);
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&ctx->grp.B, p, l));
+    p += l;
+    l = mbedtls_mpi_size(&ctx->grp.G.X);
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&ctx->grp.G.X, p, l));
+    p += l;
+    l = mbedtls_mpi_size(&ctx->grp.G.Y);
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&ctx->grp.G.Y, p, l));
+    p += l;
+    l = mbedtls_mpi_size(&ctx->Q.X);
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&ctx->Q.X, p, l));
+    p += l;
+    l = mbedtls_mpi_size(&ctx->Q.Y);
+    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary(&ctx->Q.Y, p, l));
+    p += l;
+    MBEDTLS_MPI_CHK(mbedtls_md(md_info, m, p - m, z));
+
+cleanup:
+    if (m) {
+        mbedtls_free(m);
+    }
+
+    return (ret);
+}
+
+int mbedtls_sm2_hash_e(mbedtls_md_type_t md_alg, const unsigned char *z,
+        const unsigned char *input, size_t ilen, unsigned char *e)
+{
+    int ret = 0;
+    const mbedtls_md_info_t * md_info = NULL;
+    mbedtls_md_context_t md_ctx;
+
+    md_info = mbedtls_md_info_from_type(md_alg);
+    if (md_info == NULL)
+        MBEDTLS_MPI_CHK(MBEDTLS_ERR_SM2_BAD_INPUT_DATA);
+
+    mbedtls_md_init(&md_ctx);
+    if((ret = mbedtls_md_setup(&md_ctx, md_info, 0)) != 0)
+        goto cleanup;
+
+    if ((ret = mbedtls_md_starts(&md_ctx)) != 0)
+        return ret;
+    if ((ret = mbedtls_md_update(&md_ctx, z, mbedtls_md_get_size(md_info))) != 0)
+        return ret;
+    if ((ret = mbedtls_md_update(&md_ctx, input, ilen)) != 0)
+        return ret;
+    if ((ret = mbedtls_md_finish(&md_ctx, e)) != 0)
+        return ret;
+
+cleanup:
+    mbedtls_md_free(&md_ctx);
+
+    return (ret);
+}
+#endif /* !MBEDTLS_SM2_SIGN_ALT */
+
+#if !defined(MBEDTLS_SM2_GENKEY_ALT)
+/*
+ * Generate key pair
+ */
+int mbedtls_sm2_genkey(mbedtls_sm2_context *ctx, mbedtls_ecp_group_id gid,
+        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng)
+{
+    return (mbedtls_ecp_group_load(&ctx->grp, gid) ||
+            mbedtls_ecp_gen_keypair(&ctx->grp, &ctx->d, &ctx->Q, f_rng, p_rng));
+}
+#endif /* !MBEDTLS_SM2_GENKEY_ALT */
+
+int mbedtls_sm2_from_keypair(mbedtls_sm2_context *ctx,
+        const mbedtls_ecp_keypair *key)
+{
+    int ret;
+
+    if( ( ret = mbedtls_ecp_group_copy( &ctx->grp, &key->grp ) ) != 0 ||
+        ( ret = mbedtls_mpi_copy( &ctx->d, &key->d ) ) != 0 ||
+        ( ret = mbedtls_ecp_copy( &ctx->Q, &key->Q ) ) != 0 )
+    {
+        mbedtls_sm2_free( ctx );
+    }
+
+    return( ret );
+}
+
+void mbedtls_sm2_init(mbedtls_sm2_context *ctx)
+{
+    mbedtls_ecp_keypair_init(ctx);
+}
+
+void mbedtls_sm2_free(mbedtls_sm2_context *ctx)
+{
+    mbedtls_ecp_keypair_free(ctx);
+}
+
+#endif /* !MBEDTLS_SM2_ALT */
+
+#if defined(MBEDTLS_SELF_TEST)
+
+/*
+ * SM2 test vectors from: GM/T 0003-2012 Chinese National Standard
+ */
+static const unsigned char sm2_test_plaintext[] = { /* "encryption standard" */
+    0x65, 0x6E, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69,
+    0x6F, 0x6E, 0x20, 0x73, 0x74, 0x61, 0x6E, 0x64,
+    0x61, 0x72, 0x64,
+};
+static const unsigned char sm2_test_ciphertext[] = {
+    0x04, 0x24, 0x5C, 0x26, 0xFB, 0x68, 0xB1, 0xDD,
+    0xDD, 0xB1, 0x2C, 0x4B, 0x6B, 0xF9, 0xF2, 0xB6,
+    0xD5, 0xFE, 0x60, 0xA3, 0x83, 0xB0, 0xD1, 0x8D,
+    0x1C, 0x41, 0x44, 0xAB, 0xF1, 0x7F, 0x62, 0x52,
+    0xE7, 0x76, 0xCB, 0x92, 0x64, 0xC2, 0xA7, 0xE8,
+    0x8E, 0x52, 0xB1, 0x99, 0x03, 0xFD, 0xC4, 0x73,
+    0x78, 0xF6, 0x05, 0xE3, 0x68, 0x11, 0xF5, 0xC0,
+    0x74, 0x23, 0xA2, 0x4B, 0x84, 0x40, 0x0F, 0x01,
+    0xB8, 0x65, 0x00, 0x53, 0xA8, 0x9B, 0x41, 0xC4,
+    0x18, 0xB0, 0xC3, 0xAA, 0xD0, 0x0D, 0x88, 0x6C,
+    0x00, 0x28, 0x64, 0x67, 0x9C, 0x3D, 0x73, 0x60,
+    0xC3, 0x01, 0x56, 0xFA, 0xB7, 0xC8, 0x0A, 0x02,
+    0x76, 0x71, 0x2D, 0xA9, 0xD8, 0x09, 0x4A, 0x63,
+    0x4B, 0x76, 0x6D, 0x3A, 0x28, 0x5E, 0x07, 0x48,
+    0x06, 0x53, 0x42, 0x6D,
+};
+static const unsigned char sm2_test1_prik[] = {
+    0x16, 0x49, 0xAB, 0x77, 0xA0, 0x06, 0x37, 0xBD,
+    0x5E, 0x2E, 0xFE, 0x28, 0x3F, 0xBF, 0x35, 0x35,
+    0x34, 0xAA, 0x7F, 0x7C, 0xB8, 0x94, 0x63, 0xF2,
+    0x08, 0xDD, 0xBC, 0x29, 0x20, 0xBB, 0x0D, 0xA0,
+};
+static const unsigned char sm2_test1_pubk[] = {
+    0x04,
+
+    0x43, 0x5B, 0x39, 0xCC, 0xA8, 0xF3, 0xB5, 0x08,
+    0xC1, 0x48, 0x8A, 0xFC, 0x67, 0xBE, 0x49, 0x1A,
+    0x0F, 0x7B, 0xA0, 0x7E, 0x58, 0x1A, 0x0E, 0x48,
+    0x49, 0xA5, 0xCF, 0x70, 0x62, 0x8A, 0x7E, 0x0A,
+
+    0x75, 0xDD, 0xBA, 0x78, 0xF1, 0x5F, 0xEE, 0xCB,
+    0x4C, 0x78, 0x95, 0xE2, 0xC1, 0xCD, 0xF5, 0xFE,
+    0x01, 0xDE, 0xBB, 0x2C, 0xDB, 0xAD, 0xF4, 0x53,
+    0x99, 0xCC, 0xF7, 0x7B, 0xBA, 0x07, 0x6A, 0x42,
+};
+static const unsigned char sm2_test1_rand_fix[] = {
+    0x4C, 0x62, 0xEE, 0xFD, 0x6E, 0xCF, 0xC2, 0xB9,
+    0x5B, 0x92, 0xFD, 0x6C, 0x3D, 0x95, 0x75, 0x14,
+    0x8A, 0xFA, 0x17, 0x42, 0x55, 0x46, 0xD4, 0x90,
+    0x18, 0xE5, 0x38, 0x8D, 0x49, 0xDD, 0x7B, 0x4F,
+};
+
+static const unsigned char sm2_test_messagetext[] = {   /* message digest */
+    0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
+    0x64, 0x69, 0x67, 0x65, 0x73, 0x74,
+};
+static const unsigned char sm2_test2_rand_fix[] = {
+    0x6C, 0xB2, 0x8D, 0x99, 0x38, 0x5C, 0x17, 0x5C,
+    0x94, 0xF9, 0x4E, 0x93, 0x48, 0x17, 0x66, 0x3F,
+    0xC1, 0x76, 0xD9, 0x25, 0xDD, 0x72, 0xB7, 0x27,
+    0x26, 0x0D, 0xBA, 0xAE, 0x1F, 0xB2, 0xF9, 0x6F, 
+};
+static const unsigned char sm2_test2_prik[] = {
+    0x12, 0x8B, 0x2F, 0xA8, 0xBD, 0x43, 0x3C, 0x6C,
+    0x06, 0x8C, 0x8D, 0x80, 0x3D, 0xFF, 0x79, 0x79,
+    0x2A, 0x51, 0x9A, 0x55, 0x17, 0x1B, 0x1B, 0x65,
+    0x0C, 0x23, 0x66, 0x1D, 0x15, 0x89, 0x72, 0x63,
+};
+static const unsigned char sm2_test2_pubk[] = {
+    0x04,
+
+    0x0A, 0xE4, 0xC7, 0x79, 0x8A, 0xA0, 0xF1, 0x19,
+    0x47, 0x1B, 0xEE, 0x11, 0x82, 0x5B, 0xE4, 0x62,
+    0x02, 0xBB, 0x79, 0xE2, 0xA5, 0x84, 0x44, 0x95,
+    0xE9, 0x7C, 0x04, 0xFF, 0x4D, 0xF2, 0x54, 0x8A,
+
+    0x7C, 0x02, 0x40, 0xF8, 0x8F, 0x1C, 0xD4, 0xE1,
+    0x63, 0x52, 0xA7, 0x3C, 0x17, 0xB7, 0xF1, 0x6F,
+    0x07, 0x35, 0x3E, 0x53, 0xA1, 0x76, 0xD6, 0x84,
+    0xA9, 0xFE, 0x0C, 0x6B, 0xB7, 0x98, 0xE8, 0x57,
+};
+static const char sm2_test_ID[] = {            /* "ALICE123@YAHOO.COM" */
+    0x41, 0x4C, 0x49, 0x43, 0x45, 0x31, 0x32, 0x33,
+    0x40, 0x59, 0x41, 0x48, 0x4F, 0x4F, 0x2E, 0x43,
+    0x4F, 0x4D,
+};
+static const unsigned char sm2_test_z[] = {
+    0xF4, 0xA3, 0x84, 0x89, 0xE3, 0x2B, 0x45, 0xB6,
+    0xF8, 0x76, 0xE3, 0xAC, 0x21, 0x68, 0xCA, 0x39,
+    0x23, 0x62, 0xDC, 0x8F, 0x23, 0x45, 0x9C, 0x1D,
+    0x11, 0x46, 0xFC, 0x3D, 0xBF, 0xB7, 0xBC, 0x9A,
+};
+static const unsigned char sm2_test_md[] = {
+    0xB5, 0x24, 0xF5, 0x52, 0xCD, 0x82, 0xB8, 0xB0,
+    0x28, 0x47, 0x6E, 0x00, 0x5C, 0x37, 0x7F, 0xB1,
+    0x9A, 0x87, 0xE6, 0xFC, 0x68, 0x2D, 0x48, 0xBB,
+    0x5D, 0x42, 0xE3, 0xD9, 0xB9, 0xEF, 0xFE, 0x76,
+};
+static const unsigned char sm2_test_sign[] = {
+    0x40, 0xF1, 0xEC, 0x59, 0xF7, 0x93, 0xD9, 0xF4,
+    0x9E, 0x09, 0xDC, 0xEF, 0x49, 0x13, 0x0D, 0x41,
+    0x94, 0xF7, 0x9F, 0xB1, 0xEE, 0xD2, 0xCA, 0xA5,
+    0x5B, 0xAC, 0xDB, 0x49, 0xC4, 0xE7, 0x55, 0xD1,
+    0x6F, 0xC6, 0xDA, 0xC3, 0x2C, 0x5D, 0x5C, 0xF1,
+    0x0C, 0x77, 0xDF, 0xB2, 0x0F, 0x7C, 0x2E, 0xB6,
+    0x67, 0xA4, 0x57, 0x87, 0x2F, 0xB0, 0x9E, 0xC5,
+    0x63, 0x27, 0xA6, 0x7E, 0xC7, 0xDE, 0xEB, 0xE7,
+};
+
+static int sm2_set_fix_rng(void * p_rng, unsigned char * buf, size_t size)
+{
+    memmove(buf, p_rng, size);
+    return 0;
+}
+
+int mbedtls_sm2_self_test(int verbose)
+{
+    int ret = 0;
+    mbedtls_sm2_context ctx;
+    unsigned char output[512];
+    size_t olen;
+
+    mbedtls_sm2_init(&ctx);
+    if ((ret = mbedtls_ecp_group_load(&ctx.grp,
+                    MBEDTLS_ECP_DP_SM2P256T1)) != 0) {
+        mbedtls_printf("load group failed\n");
+        goto cleanup;
+    }
+
+    if( verbose != 0 )
+        mbedtls_printf( "  SM2 key validation: " );
+
+    if ((ret = mbedtls_mpi_read_binary(&ctx.d,
+                    sm2_test1_prik, sizeof(sm2_test1_prik))) != 0) {
+        mbedtls_printf("read private key1 failed\n");
+        goto cleanup;
+    }
+    if ((ret = mbedtls_ecp_point_read_binary(&ctx.grp, &ctx.Q,
+            sm2_test1_pubk, sizeof(sm2_test1_pubk))) != 0) {
+        mbedtls_printf("read public key1 failed\n");
+        goto cleanup;
+    }
+
+    if (((ret = mbedtls_ecp_check_pubkey(&ctx.grp, &ctx.Q)) != 0) ||
+            (ret = mbedtls_ecp_check_privkey(&ctx.grp, &ctx.d) != 0)) {
+        if (verbose != 0) {
+            mbedtls_printf("failed\n");
+        }
+        goto cleanup;
+    }
+
+    if (verbose)
+        mbedtls_printf("passed\n  SM2 encryption: ");
+
+    if ((ret = mbedtls_sm2_encrypt(&ctx, MBEDTLS_MD_SM3,
+                    sm2_test_plaintext, sizeof(sm2_test_plaintext),
+                    output, &olen,
+                    sm2_set_fix_rng, (void *)sm2_test1_rand_fix)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf( "failed\n" );
+        }
+        goto cleanup;
+    }
+    if (memcmp(output, sm2_test_ciphertext, sizeof(sm2_test_ciphertext)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf( "check failed\n" );
+        }
+        ret = 1;
+        goto cleanup;
+    }
+
+    if (verbose != 0) {
+        mbedtls_printf("passed\n  SM2 decryption: ");
+    }
+
+    if ((ret = mbedtls_sm2_decrypt(&ctx, MBEDTLS_MD_SM3,
+                    sm2_test_ciphertext, sizeof(sm2_test_ciphertext),
+                    output, &olen)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf( "failed\n" );
+        }
+        goto cleanup;
+    }
+    if (memcmp(output, sm2_test_plaintext, sizeof(sm2_test_plaintext)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf( "check failed\n" );
+        }
+        ret = 1;
+        goto cleanup;
+    }
+
+    if (verbose != 0) {
+        mbedtls_printf("passed\n  SM2 key validation: ");
+    }
+
+    if ((ret = mbedtls_mpi_read_binary(&ctx.d,
+                    sm2_test2_prik, sizeof(sm2_test2_prik))) != 0) {
+        mbedtls_printf("read private key2 failed\n");
+        goto cleanup;
+    }
+    if ((ret = mbedtls_ecp_point_read_binary(&ctx.grp, &ctx.Q,
+                    sm2_test2_pubk, sizeof(sm2_test2_pubk))) != 0) {
+        mbedtls_printf("read public key2 failed\n");
+        goto cleanup;
+    }
+
+    if (((ret = mbedtls_ecp_check_pubkey(&ctx.grp, &ctx.Q)) != 0) ||
+            (ret = mbedtls_ecp_check_privkey(&ctx.grp, &ctx.d) != 0)) {
+        if (verbose != 0) {
+            mbedtls_printf("failed\n");
+        }
+        goto cleanup;
+    }
+
+    if (verbose != 0) {
+        mbedtls_printf("passed\n  SM2 Get Z: ");
+    }
+
+    if ((ret = mbedtls_sm2_hash_z(&ctx, MBEDTLS_MD_SM3,
+                    sm2_test_ID, sizeof(sm2_test_ID), output)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf( "failed\n" );
+        }
+        goto cleanup;
+    }
+    if (memcmp(output, sm2_test_z, sizeof(sm2_test_z)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf( "check failed\n" );
+        }
+        ret = 1;
+        goto cleanup;
+    }
+
+    if (verbose != 0) {
+        mbedtls_printf("passed\n  SM2 Get hash: ");
+    }
+
+    if ((ret = mbedtls_sm2_hash_e(MBEDTLS_MD_SM3,
+                    sm2_test_z, sm2_test_messagetext,
+                    sizeof(sm2_test_messagetext), output)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf("failed\n");
+        }
+        goto cleanup;
+    }
+    if (memcmp(output, sm2_test_md, sizeof(sm2_test_md)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf("check failed\n");
+        }
+        ret = 1;
+        goto cleanup;
+    }
+
+    if (verbose != 0) {
+        mbedtls_printf("passed\n  SM2 sign: ");
+    }
+
+    if ((ret = mbedtls_sm2_sign(&ctx, MBEDTLS_MD_SM3, sm2_test_md, output,
+                    sm2_set_fix_rng, (void *)sm2_test2_rand_fix)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf( "failed\n" );
+        }
+        goto cleanup;
+    }
+    if (memcmp(output, sm2_test_sign, sizeof(sm2_test_sign)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf( "check failed\n" );
+        }
+        ret = 1;
+        goto cleanup;
+    }
+
+    if (verbose != 0) {
+        mbedtls_printf("passed\n  SM2 verify: ");
+    }
+
+    if ((ret = mbedtls_sm2_verify(&ctx, MBEDTLS_MD_SM3,
+                    sm2_test_md, sm2_test_sign)) != 0) {
+        if (verbose != 0) {
+            mbedtls_printf( "failed\n" );
+        }
+        goto cleanup;
+    }
+
+    if (verbose != 0) {
+        mbedtls_printf("passed\n");
+    }
+
+    if (verbose != 0) {
+        mbedtls_printf("\n");
+    }
+
+cleanup:
+    mbedtls_sm2_free(&ctx);
+    return ret;
+}
+#endif /* MBEDTLS_SELF_TEST */
+
+#endif /* MBEDTLS_SM2_C */
diff --git a/library/sm3.c b/library/sm3.c
new file mode 100644
index 00000000..94981195
--- /dev/null
+++ b/library/sm3.c
@@ -0,0 +1,488 @@
+/*
+ * SM3 Encryption alogrithm
+ * GM/T 0004-2012 Chinese National Standard refers to: http://www.oscca.gov.cn/ 
+ * Thanks to MbedTLS.
+ * Thanks to author: goldboar (goldboar@163.com).
+ */
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "mbedtls/mbedtls_config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+#if defined(MBEDTLS_SM3_C)
+
+#include "mbedtls/sm3.h"
+#include <string.h>
+
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
+#include <stdio.h>
+#define mbedtls_printf      printf
+#endif /* MBEDTLS_PLATFORM_C */
+
+#if !defined(MBEDTLS_SM3_ALT)
+/* Implementation that should never be optimized out by the compiler */
+static void mbedtls_zeroize( void *v, size_t n ) {
+    volatile unsigned char *p = v; while( n-- ) *p++ = 0;
+}
+
+/*
+ * 32-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_UINT32_BE
+#define GET_UINT32_BE(n,b,i)                            \
+{                                                       \
+    (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \
+        | ( (uint32_t) (b)[(i) + 1] << 16 )             \
+        | ( (uint32_t) (b)[(i) + 2] <<  8 )             \
+        | ( (uint32_t) (b)[(i) + 3]       );            \
+}
+#endif
+
+#ifndef PUT_UINT32_BE
+#define PUT_UINT32_BE(n,b,i)                            \
+{                                                       \
+    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (unsigned char) ( (n)       );       \
+}
+#endif
+
+void mbedtls_sm3_init(mbedtls_sm3_context *ctx)
+{
+    memset(ctx, 0, sizeof(mbedtls_sm3_context));
+}
+
+void mbedtls_sm3_free( mbedtls_sm3_context *ctx )
+{
+    if(ctx == NULL)
+        return;
+
+    mbedtls_zeroize(ctx, sizeof(mbedtls_sm3_context));
+}
+
+void mbedtls_sm3_clone(mbedtls_sm3_context *dst,
+        const mbedtls_sm3_context *src)
+{
+    *dst = *src;
+}
+
+/*
+ * SM3 context setup
+ */
+int mbedtls_sm3_starts(mbedtls_sm3_context *ctx)
+{
+    ctx->total[0] = 0;
+    ctx->total[1] = 0;
+
+    ctx->state[0] = 0x7380166F;
+    ctx->state[1] = 0x4914B2B9;
+    ctx->state[2] = 0x172442D7;
+    ctx->state[3] = 0xDA8A0600;
+    ctx->state[4] = 0xA96F30BC;
+    ctx->state[5] = 0x163138AA;
+    ctx->state[6] = 0xE38DEE4D;
+    ctx->state[7] = 0xB0FB0E4E;
+    return 0;
+}
+
+#if !defined(MBEDTLS_SM3_PROCESS_ALT)
+int mbedtls_sm3_process(mbedtls_sm3_context *ctx,
+        const unsigned char data[64])
+{
+    uint32_t SS1, SS2, TT1, TT2, W[68], W1[64];
+    uint32_t A, B, C, D, E, F, G, H;
+    uint32_t T[64];
+    uint32_t Temp1, Temp2, Temp3, Temp4, Temp5;
+    int j;
+
+    for (j = 0; j < 16; j++)
+        T[j] = 0x79CC4519;
+    for (j = 16; j < 64; j++)
+        T[j] = 0x7A879D8A;
+
+    GET_UINT32_BE( W[ 0], data,  0 );
+    GET_UINT32_BE( W[ 1], data,  4 );
+    GET_UINT32_BE( W[ 2], data,  8 );
+    GET_UINT32_BE( W[ 3], data, 12 );
+    GET_UINT32_BE( W[ 4], data, 16 );
+    GET_UINT32_BE( W[ 5], data, 20 );
+    GET_UINT32_BE( W[ 6], data, 24 );
+    GET_UINT32_BE( W[ 7], data, 28 );
+    GET_UINT32_BE( W[ 8], data, 32 );
+    GET_UINT32_BE( W[ 9], data, 36 );
+    GET_UINT32_BE( W[10], data, 40 );
+    GET_UINT32_BE( W[11], data, 44 );
+    GET_UINT32_BE( W[12], data, 48 );
+    GET_UINT32_BE( W[13], data, 52 );
+    GET_UINT32_BE( W[14], data, 56 );
+    GET_UINT32_BE( W[15], data, 60 );
+
+#define FF0(x,y,z) ( (x) ^ (y) ^ (z))
+#define FF1(x,y,z) (((x) & (y)) | ( (x) & (z)) | ( (y) & (z)))
+
+#define GG0(x,y,z) ( (x) ^ (y) ^ (z))
+#define GG1(x,y,z) (((x) & (y)) | ( (~(x)) & (z)) )
+
+
+#define  SHL(x,n) (((x) & 0xFFFFFFFF) << (n % 32))
+#define ROTL(x,n) (SHL((x),n) | ((x) >> (32 - (n % 32))))
+
+#define P0(x) ((x) ^  ROTL((x),9) ^ ROTL((x),17))
+#define P1(x) ((x) ^  ROTL((x),15) ^ ROTL((x),23))
+
+    for (j = 16; j < 68; j++) {
+        //W[j] = P1( W[j-16] ^ W[j-9] ^ ROTL(W[j-3],15)) ^ ROTL(W[j - 13],7 ) ^ W[j-6];
+        //Why thd release's result is different with the debug's ?
+        //Below is okay. Interesting, Perhaps VC6 has a bug of Optimizaiton.
+
+        Temp1 = W[j - 16] ^ W[j - 9];
+        Temp2 = ROTL(W[j - 3], 15);
+        Temp3 = Temp1 ^ Temp2;
+        Temp4 = P1(Temp3);
+        Temp5 =  ROTL(W[j - 13], 7 ) ^ W[j - 6];
+        W[j] = Temp4 ^ Temp5;
+    }
+    for (j = 0; j < 64; j++) {
+        W1[j] = W[j] ^ W[j+4];
+    }
+    A = ctx->state[0];
+    B = ctx->state[1];
+    C = ctx->state[2];
+    D = ctx->state[3];
+    E = ctx->state[4];
+    F = ctx->state[5];
+    G = ctx->state[6];
+    H = ctx->state[7];
+    for (j = 0; j < 16; j++) {
+        SS1 = ROTL((ROTL(A, 12) + E + ROTL(T[j], j)), 7);
+        SS2 = SS1 ^ ROTL(A, 12);
+        TT1 = FF0(A, B, C) + D + SS2 + W1[j];
+        TT2 = GG0(E, F, G) + H + SS1 + W[j];
+        D = C;
+        C = ROTL(B, 9);
+        B = A;
+        A = TT1;
+        H = G;
+        G = ROTL(F, 19);
+        F = E;
+        E = P0(TT2);
+    }
+
+    for (j = 16; j < 64; j++) {
+        SS1 = ROTL((ROTL(A, 12) + E + ROTL(T[j], j)), 7);
+        SS2 = SS1 ^ ROTL(A, 12);
+        TT1 = FF1(A, B, C) + D + SS2 + W1[j];
+        TT2 = GG1(E, F, G) + H + SS1 + W[j];
+        D = C;
+        C = ROTL(B, 9);
+        B = A;
+        A = TT1;
+        H = G;
+        G = ROTL(F, 19);
+        F = E;
+        E = P0(TT2);
+    }
+
+    ctx->state[0] ^= A;
+    ctx->state[1] ^= B;
+    ctx->state[2] ^= C;
+    ctx->state[3] ^= D;
+    ctx->state[4] ^= E;
+    ctx->state[5] ^= F;
+    ctx->state[6] ^= G;
+    ctx->state[7] ^= H;
+
+    return 0;
+}
+#endif /* !MBEDTLS_SM3_PROCESS_ALT */
+
+/*
+ * SM3 process buffer
+ */
+int mbedtls_sm3_update(mbedtls_sm3_context *ctx,
+        const unsigned char *input, int ilen)
+{
+    int fill;
+    uint32_t left;
+    if (ilen <= 0)
+        return 1;
+
+    left = ctx->total[0] & 0x3F;
+    fill = 64 - left;
+
+    ctx->total[0] += ilen;
+    ctx->total[0] &= 0xFFFFFFFF;
+
+    if (ctx->total[0] < (uint32_t) ilen)
+        ctx->total[1]++;
+    if (left && ilen >= fill) {
+        memcpy((void *) (ctx->buffer + left), (void *) input, fill);
+        mbedtls_sm3_process(ctx, ctx->buffer);
+        input += fill;
+        ilen  -= fill;
+        left = 0;
+    }
+    while (ilen >= 64) {
+        mbedtls_sm3_process(ctx, input);
+        input += 64;
+        ilen  -= 64;
+    }
+    if (ilen > 0) {
+        memcpy((void *) (ctx->buffer + left), (void *) input, ilen);
+    }
+    return 0;
+}
+
+static const unsigned char sm3_padding[64] = {
+ 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/*
+ * SM3 final digest
+ */
+int mbedtls_sm3_finish(mbedtls_sm3_context *ctx, unsigned char output[32])
+{
+    uint32_t last, padn;
+    uint32_t high, low;
+    unsigned char msglen[8];
+
+    high = (ctx->total[0] >> 29)
+         | (ctx->total[1] <<  3);
+    low  = (ctx->total[0] <<  3);
+
+    PUT_UINT32_BE(high, msglen, 0);
+    PUT_UINT32_BE(low,  msglen, 4);
+
+    last = ctx->total[0] & 0x3F;
+    padn = (last < 56) ? (56 - last) : (120 - last);
+
+    mbedtls_sm3_update(ctx, (unsigned char *) sm3_padding, padn);
+    mbedtls_sm3_update(ctx, msglen, 8);
+
+    PUT_UINT32_BE(ctx->state[0], output,  0);
+    PUT_UINT32_BE(ctx->state[1], output,  4);
+    PUT_UINT32_BE(ctx->state[2], output,  8);
+    PUT_UINT32_BE(ctx->state[3], output, 12);
+    PUT_UINT32_BE(ctx->state[4], output, 16);
+    PUT_UINT32_BE(ctx->state[5], output, 20);
+    PUT_UINT32_BE(ctx->state[6], output, 24);
+    PUT_UINT32_BE(ctx->state[7], output, 28);
+
+    return 0;
+}
+
+#endif /* !MBEDTLS_SM3_ALT */
+
+/*
+ * output = SM3(input buffer)
+ */
+int mbedtls_sm3(const unsigned char *input, int ilen,
+        unsigned char output[32])
+{   
+    int ret;
+    mbedtls_sm3_context ctx;
+
+    ret = mbedtls_sm3_starts(&ctx);
+    ret = mbedtls_sm3_update(&ctx, input, ilen);
+    ret = mbedtls_sm3_finish(&ctx, output);
+
+    memset(&ctx, 0, sizeof(mbedtls_sm3_context));
+
+    return ret;
+}
+
+#if defined(MBEDTLS_SM3_FILE) && defined(MBEDTLS_FS_IO)
+/*
+ * output = SM3(file contents)
+ */
+int mbedtls_sm3_file(const char *path, unsigned char output[32])
+{
+    FILE *f;
+    size_t n;
+    mbedtls_sm3_context ctx;
+    unsigned char buf[1024];
+
+    if ((f = fopen(path, "rb")) == NULL)
+        return (1);
+
+    mbedtls_sm3_starts(&ctx);
+
+    while ((n = fread(buf, 1, sizeof(buf), f)) > 0)
+        mbedtls_sm3_update(&ctx, buf, (int)n);
+
+    mbedtls_sm3_finish(&ctx, output);
+
+    memset(&ctx, 0, sizeof(mbedtls_sm3_context));
+
+    if (ferror(f) != 0) {
+        fclose(f);
+        return (2);
+    }
+
+    fclose(f);
+    return (0);
+}
+#endif /* MBEDTLS_SM3_FILE && MBEDTLS_FS_IO */
+
+#if defined(MBEDTLS_SM3_HMAC_C)
+#if !defined(MBEDTLS_SM3_HMAC_ALT)
+
+/*
+ * SM3 HMAC context setup
+ */
+void mbedtls_sm3_hmac_starts(mbedtls_sm3_context *ctx,
+        unsigned char *key, int keylen)
+{
+    int i;
+    unsigned char sum[32];
+
+    if (keylen > 64) {
+        mbedtls_sm3(key, keylen, sum);
+        keylen = 32;
+        // keylen = (is224) ? 28 : 32;
+        key = sum;
+    }
+
+    memset(ctx->ipad, 0x36, 64);
+    memset(ctx->opad, 0x5C, 64);
+
+    for (i = 0; i < keylen; i++) {
+        ctx->ipad[i] = (unsigned char)(ctx->ipad[i] ^ key[i]);
+        ctx->opad[i] = (unsigned char)(ctx->opad[i] ^ key[i]);
+    }
+
+    mbedtls_sm3_starts(ctx);
+    mbedtls_sm3_update(ctx, ctx->ipad, 64);
+
+    memset(sum, 0, sizeof(sum));
+}
+
+/*
+ * SM3 HMAC process buffer
+ */
+void mbedtls_sm3_hmac_update(mbedtls_sm3_context *ctx,
+        unsigned char *input, int ilen)
+{
+    mbedtls_sm3_update(ctx, input, ilen);
+}
+
+/*
+ * SM3 HMAC final digest
+ */
+void mbedtls_sm3_hmac_finish(mbedtls_sm3_context *ctx, unsigned char output[32])
+{
+    int hlen;
+    unsigned char tmpbuf[32];
+
+    // is224 = ctx->is224;
+    hlen =  32;
+
+    mbedtls_sm3_finish(ctx, tmpbuf);
+    mbedtls_sm3_starts(ctx);
+    mbedtls_sm3_update(ctx, ctx->opad, 64);
+    mbedtls_sm3_update(ctx, tmpbuf, hlen);
+    mbedtls_sm3_finish(ctx, output);
+
+    memset(tmpbuf, 0, sizeof(tmpbuf));
+}
+
+#endif /* !MBEDTLS_SM3_HMAC_ALT */
+
+/*
+ * output = HMAC-SM#(hmac key, input buffer)
+ */
+void mbedtls_sm3_hmac(unsigned char *key, int keylen,
+        unsigned char *input, int ilen,
+        unsigned char output[32])
+{
+    mbedtls_sm3_context ctx;
+
+    mbedtls_sm3_hmac_starts(&ctx, key, keylen);
+    mbedtls_sm3_hmac_update(&ctx, input, ilen);
+    mbedtls_sm3_hmac_finish(&ctx, output);
+
+    memset(&ctx, 0, sizeof(mbedtls_sm3_context));
+}
+
+#endif /* MBEDTLS_SM3_HMAC_C */
+
+#if defined(MBEDTLS_SELF_TEST)
+
+/*
+ * SM3 test vectors from: GM/T 0004-2012 Chinese National Standard
+ */
+static const unsigned char sm3_test_buf[2][65] = {
+    { "abc" },
+    { "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd" },
+};
+
+static const int sm3_test_buflen[2] = {
+    3, 64,
+};
+
+static const unsigned char sm3_test_sum[2][32] = {
+    {   0x66, 0xc7, 0xf0, 0xf4, 0x62, 0xee, 0xed, 0xd9,
+        0xd1, 0xf2, 0xd4, 0x6b, 0xdc, 0x10, 0xe4, 0xe2,
+        0x41, 0x67, 0xc4, 0x87, 0x5c, 0xf2, 0xf7, 0xa2,
+        0x29, 0x7d, 0xa0, 0x2b, 0x8f, 0x4b, 0xa8, 0xe0, },
+    {   0xde, 0xbe, 0x9f, 0xf9, 0x22, 0x75, 0xb8, 0xa1,
+        0x38, 0x60, 0x48, 0x89, 0xc1, 0x8e, 0x5a, 0x4d,
+        0x6f, 0xdb, 0x70, 0xe5, 0x38, 0x7e, 0x57, 0x65,
+        0x29, 0x3d, 0xcb, 0xa3, 0x9c, 0x0c, 0x57, 0x32, },
+};
+
+int mbedtls_sm3_self_test(int verbose)
+{
+    int i;
+    int ret = 0;
+    unsigned char sm3sum[32];
+    mbedtls_sm3_context ctx;
+
+    mbedtls_sm3_init(&ctx);
+
+    for (i = 0; i < 2; i++) {
+        if (verbose != 0) {
+            mbedtls_printf("  SM3 test #%d: ", i + 1);
+        }
+        mbedtls_sm3_starts(&ctx);
+        mbedtls_sm3_update(&ctx, sm3_test_buf[i], sm3_test_buflen[i]);
+        mbedtls_sm3_finish(&ctx, sm3sum);
+
+        if (memcmp(sm3sum, sm3_test_sum[i], 32) != 0) {
+            int j;
+            mbedtls_printf("\n sum:");
+            for (j = 0; j < 32; j++) {
+                mbedtls_printf(" %02x", sm3sum[j] & 0xff);
+            }
+            mbedtls_printf("\n chk:");
+            for (j = 0; j < 32; j++) {
+                mbedtls_printf(" %02x", sm3_test_sum[i][j] & 0xff);
+            }
+            mbedtls_printf("\n");
+            if (verbose != 0) {
+                mbedtls_printf("failed\n");
+            }
+            ret = 1;
+            goto exit;
+        }
+        if (verbose != 0) {
+            mbedtls_printf("passed\n");
+        }
+    }
+    if (verbose != 0) {
+        mbedtls_printf("\n");
+    }
+exit:
+    mbedtls_sm3_free(&ctx);
+    return (ret);
+}
+#endif /* MBEDTLS_SELF_TEST */
+
+#endif /* MBEDTLS_SM3_C */
diff --git a/library/sm4.c b/library/sm4.c
new file mode 100644
index 00000000..6a938f8a
--- /dev/null
+++ b/library/sm4.c
@@ -0,0 +1,472 @@
+/*
+ * SM4 Encryption alogrithm (SMS4 algorithm)
+ * GM/T 0002-2012 Chinese National Standard refers to: http://www.oscca.gov.cn/ 
+ * Thanks to MbedTLS.
+ * Thanks to author: goldboar (goldboar@163.com).
+ */
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "mbedtls/mbedtls_config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+
+#if defined(MBEDTLS_SM4_C)
+
+#include "mbedtls/sm4.h"
+
+#if defined(MBEDTLS_PLATFORM_C)
+#include "mbedtls/platform.h"
+#else
+#include <stdio.h>
+#define mbedtls_printf      printf
+#endif /* MBEDTLS_PLATFORM_C */
+extern int mbedtls_sm4_crypt_cbc(mbedtls_sm4_context *ctx, int mode, size_t length,
+        unsigned char iv[MBEDTLS_SM4_KEY_SIZE],
+        const unsigned char *input, unsigned char *output);
+
+#if !defined(MBEDTLS_SM4_ALT)
+
+/* Implementation that should never be optimized out by the compiler */
+static void mbedtls_zeroize( void *v, size_t n ) {
+    volatile unsigned char *p = v; while( n-- ) *p++ = 0;
+}
+
+#define SWAP(a, b) { unsigned long t = a; a = b; b = t; t = 0; }
+
+void mbedtls_sm4_init(mbedtls_sm4_context *ctx)
+{
+    memset(ctx, 0, sizeof(mbedtls_sm4_context));
+}
+void mbedtls_sm4_free(mbedtls_sm4_context *ctx)
+{
+    if(ctx == NULL) {
+        return;
+    }
+    mbedtls_zeroize(ctx, sizeof(mbedtls_sm4_context));
+}
+
+#if !defined(MBEDTLS_SM4_SETKEY_ALT) || !defined(MBEDTLS_SM4_CRYPT_ECB_ALT)
+/* rotate shift left marco definition */
+#define  SHL(x, n) (((x) & 0xFFFFFFFF) << n)
+#define ROTL(x, n) (SHL((x), n) | ((x) >> (32 - n)))
+
+/*
+ * 32-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_UINT32_BE
+#define GET_UINT32_BE(n,b,i)                            \
+{                                                       \
+    (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \
+        | ( (uint32_t) (b)[(i) + 1] << 16 )             \
+        | ( (uint32_t) (b)[(i) + 2] <<  8 )             \
+        | ( (uint32_t) (b)[(i) + 3]       );            \
+}
+#endif
+
+#ifndef PUT_UINT32_BE
+#define PUT_UINT32_BE(n,b,i)                            \
+{                                                       \
+    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (unsigned char) ( (n)       );       \
+}
+#endif
+
+/*
+ * Expanded SM4 S-boxes
+ * Sbox table: 8bits input convert to 8 bits output.
+ */
+static const unsigned char sbox_table[256] =
+{
+    0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7,
+    0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05,
+    0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3,
+    0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99,
+    0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a,
+    0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62,
+    0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95,
+    0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6,
+    0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba,
+    0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8,
+    0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b,
+    0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35,
+    0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2,
+    0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87,
+    0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52,
+    0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e,
+    0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5,
+    0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1,
+    0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55,
+    0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3,
+    0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60,
+    0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f,
+    0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f,
+    0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51,
+    0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f,
+    0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8,
+    0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd,
+    0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0,
+    0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e,
+    0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84,
+    0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20,
+    0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48,
+};
+
+/**
+ * \brief       look up in SboxTable and get the related value.
+ * \param  [in] inch: 0x00~0xFF (8 bits unsigned value).
+ */
+static unsigned char sm4_sbox(unsigned char inch)
+{
+    unsigned char *tbl = (unsigned char *)sbox_table;
+    unsigned char val = (unsigned char)(tbl[inch]);
+    return val;
+}
+#endif /* !MBEDTLS_SM4_SETKEY_ALT || !MBEDTLS_SM4_CRYPT_ECB_ALT */
+
+#if !defined(MBEDTLS_SM4_SETKEY_ALT)
+/* Fixed parameter */
+static const uint32_t ck[32] =
+{
+    0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
+    0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
+    0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
+    0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
+    0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
+    0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
+    0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
+    0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279,
+};
+
+/* System parameter */
+static const uint32_t fk[4] = 
+{
+    0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc,
+};
+
+/**
+ * \brief       Calculating round encryption key.
+ * \param  [in] a: a is a 32 bits unsigned value;
+ * \return      sk[i]: i { 0, 1, 2, 3, ... 31, }.
+ */
+static uint32_t sm4_calc_rk(uint32_t ka)
+{
+    uint32_t bb = 0;
+    uint32_t rk = 0;
+    unsigned char a[4];
+    unsigned char b[4];
+    PUT_UINT32_BE(ka, a, 0);
+    b[0] = sm4_sbox(a[0]);
+    b[1] = sm4_sbox(a[1]);
+    b[2] = sm4_sbox(a[2]);
+    b[3] = sm4_sbox(a[3]);
+    GET_UINT32_BE(bb, b, 0)
+    rk = bb ^ (ROTL(bb, 13)) ^ (ROTL(bb, 23));
+    return rk;
+}
+
+static void mbedtls_sm4_setkey(uint32_t sk[32],
+        const unsigned char key[MBEDTLS_SM4_KEY_SIZE])
+{
+    unsigned long mk[4];
+    unsigned long k[36];
+    unsigned long i = 0;
+
+    GET_UINT32_BE(mk[0], key, 0);
+    GET_UINT32_BE(mk[1], key, 4);
+    GET_UINT32_BE(mk[2], key, 8);
+    GET_UINT32_BE(mk[3], key, 12);
+    k[0] = mk[0] ^ fk[0];
+    k[1] = mk[1] ^ fk[1];
+    k[2] = mk[2] ^ fk[2];
+    k[3] = mk[3] ^ fk[3];
+    for (; i < 32; i++) {
+        k[i + 4] = k[i] ^ (sm4_calc_rk(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ ck[i]));
+        sk[i] = k[i + 4];
+    }
+}
+
+/*
+ * SM4 key schedule (128-bit, encryption)
+ */
+int mbedtls_sm4_setkey_enc(mbedtls_sm4_context *ctx,
+        const unsigned char key[MBEDTLS_SM4_KEY_SIZE])
+{
+    mbedtls_sm4_setkey(ctx->sk, key);
+    return 0;
+}
+
+/*
+ * SM4 key schedule (128-bit, decryption)
+ */
+int mbedtls_sm4_setkey_dec(mbedtls_sm4_context *ctx,
+        const unsigned char key[MBEDTLS_SM4_KEY_SIZE])
+{
+    int i;
+    mbedtls_sm4_setkey(ctx->sk, key);
+    for (i = 0; i < MBEDTLS_SM4_KEY_SIZE; i++) {
+        SWAP(ctx->sk[i], ctx->sk[31 - i]);
+    }
+    return 0;
+}
+#endif /* !MBEDTLS_SM4_SETKEY_ALT */
+
+#if !defined(MBEDTLS_SM4_CRYPT_ECB_ALT)
+/**
+ * \brief       "T algorithm" == "L algorithm" + "t algorithm".
+ * \param  [in] a: a is a 32 bits unsigned value;
+ * \return      c: c is calculated with line algorithm "L" and nonline
+ *              algorithm "t"
+ */
+static uint32_t sm4_lt(unsigned long ka)
+{
+    unsigned long bb = 0;
+    unsigned long c = 0;
+    unsigned char a[4];
+    unsigned char b[4];
+    PUT_UINT32_BE(ka, a, 0);
+    b[0] = sm4_sbox(a[0]);
+    b[1] = sm4_sbox(a[1]);
+    b[2] = sm4_sbox(a[2]);
+    b[3] = sm4_sbox(a[3]);
+    GET_UINT32_BE(bb, b, 0);
+    c = bb ^ (ROTL(bb, 2)) ^ (ROTL(bb, 10)) ^ (ROTL(bb, 18)) ^ (ROTL(bb, 24));
+    return c;
+}
+
+/**
+ * \brief       Calculating and getting encryption/decryption contents.
+ * \param  [in] x0: original contents;
+ * \param  [in] x1: original contents;
+ * \param  [in] x2: original contents;
+ * \param  [in] x3: original contents;
+ * \param  [in] rk: encryption/decryption key;
+ * return the contents of encryption/decryption contents.
+ */
+static uint32_t sm4_f(uint32_t x0,
+                      uint32_t x1,
+                      uint32_t x2,
+                      uint32_t x3,
+                      uint32_t rk)
+{
+    return (x0 ^ sm4_lt(x1 ^ x2 ^ x3 ^ rk));
+}
+
+/*
+ * SM4 standard one round processing
+ */
+static void sm4_one_round(uint32_t sk[32],
+        const unsigned char input[MBEDTLS_SM4_KEY_SIZE],
+        unsigned char output[MBEDTLS_SM4_KEY_SIZE])
+{
+    uint32_t i = 0;
+    uint32_t b[36];
+
+    memset(b, 0, sizeof(b));
+    GET_UINT32_BE(b[0], input, 0);
+    GET_UINT32_BE(b[1], input, 4);
+    GET_UINT32_BE(b[2], input, 8);
+    GET_UINT32_BE(b[3], input, 12);
+    while (i < 32) {
+        b[i + 4] = sm4_f(b[i], b[i + 1], b[i + 2], b[i + 3], sk[i]);
+        i++;
+    }
+    PUT_UINT32_BE(b[35], output, 0);
+    PUT_UINT32_BE(b[34], output, 4);
+    PUT_UINT32_BE(b[33], output, 8);
+    PUT_UINT32_BE(b[32], output, 12);
+}
+
+int mbedtls_sm4_crypt_ecb(mbedtls_sm4_context *ctx, int mode,
+        const unsigned char input[MBEDTLS_SM4_KEY_SIZE],
+        unsigned char output[MBEDTLS_SM4_KEY_SIZE])
+{
+    ((void) mode);
+    sm4_one_round(ctx->sk, input, output);
+    return 0;
+}
+#endif /* !MBEDTLS_SM4_CRYPT_ECB_ALT */
+
+#if defined(MBEDTLS_CIPHER_MODE_CBC)
+/*
+ * SM4-CBC buffer encryption/decryption
+ */
+int mbedtls_sm4_crypt_cbc(mbedtls_sm4_context *ctx, int mode, size_t length,
+        unsigned char iv[MBEDTLS_SM4_KEY_SIZE],
+        const unsigned char *input, unsigned char *output)
+{
+    int i;
+    unsigned char temp[MBEDTLS_SM4_KEY_SIZE];
+
+    if (length % MBEDTLS_SM4_KEY_SIZE) {
+        return (MBEDTLS_ERR_SM4_INVALID_INPUT_LENGTH);
+    }
+
+    if (mode == MBEDTLS_SM4_ENCRYPT) {
+        while (length > 0) {
+            for (i = 0; i < MBEDTLS_SM4_KEY_SIZE; i++) {
+                output[i] = (unsigned char)(input[i] ^ iv[i]);
+            }
+
+            mbedtls_sm4_crypt_ecb(ctx, mode, output, output);
+            memcpy(iv, output, MBEDTLS_SM4_KEY_SIZE);
+
+            input  += MBEDTLS_SM4_KEY_SIZE;
+            output += MBEDTLS_SM4_KEY_SIZE;
+            length -= MBEDTLS_SM4_KEY_SIZE;
+        }
+    }
+    else { /* MBEDTLS_SM4_DECRYPT */
+        while (length > 0) {
+            memcpy(temp, input, MBEDTLS_SM4_KEY_SIZE);
+            mbedtls_sm4_crypt_ecb(ctx, mode, input, output);
+
+            for (i = 0; i < MBEDTLS_SM4_KEY_SIZE; i++) {
+                output[i] = (unsigned char)(output[i] ^ iv[i]);
+            }
+            memcpy(iv, temp, MBEDTLS_SM4_KEY_SIZE);
+
+            input  += MBEDTLS_SM4_KEY_SIZE;
+            output += MBEDTLS_SM4_KEY_SIZE;
+            length -= MBEDTLS_SM4_KEY_SIZE;
+        }
+    }
+
+    return( 0 );
+}
+#endif /* MBEDTLS_CIPHER_MODE_CBC */
+int mbedtls_sm4_crypt_ctr( mbedtls_sm4_context *ctx,
+                           size_t length,
+                           size_t *nc_off,
+                           unsigned char nonce_counter[16],
+                           unsigned char stream_block[16],
+                           const unsigned char *input,
+                           unsigned char *output )
+{
+    int c, i;
+    int ret = 0;
+    size_t n;
+
+    // AES_VALIDATE_RET( ctx != NULL );
+    // AES_VALIDATE_RET( nc_off != NULL );
+    // AES_VALIDATE_RET( nonce_counter != NULL );
+    // AES_VALIDATE_RET( stream_block != NULL );
+    // AES_VALIDATE_RET( input != NULL );
+    // AES_VALIDATE_RET( output != NULL );
+
+    n = *nc_off;
+
+    if ( n > 0x0F )
+        return( -0X0021  );
+
+    while( length-- )
+    {
+        if( n == 0 ) {
+            ret = mbedtls_sm4_crypt_ecb( ctx, 1, nonce_counter, stream_block );
+            if( ret != 0 )
+                goto exit;
+
+            for( i = 16; i > 0; i-- )
+                if( ++nonce_counter[i - 1] != 0 )
+                    break;
+        }
+        c = *input++;
+        *output++ = (unsigned char)( c ^ stream_block[n] );
+
+        n = ( n + 1 ) & 0x0F;
+    }
+
+    *nc_off = n;
+    ret = 0;
+
+exit:
+    return( ret );
+}
+
+#endif /* !MBEDTLS_SM4_ALT */
+
+#if defined(MBEDTLS_SELF_TEST)
+
+/*
+ * SM4 test vectors from: GM/T 0002-2012 Chinese National Standard
+ */
+static const unsigned char sm4_test_buf[16] = {
+    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
+};
+
+static const unsigned char sm4_test_key[16] = {
+    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
+    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
+};
+
+static const unsigned char sm4_test_ecb_enc[2][16] = {
+    {   0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
+        0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46, },
+    {   0x59, 0x52, 0x98, 0xc7, 0xc6, 0xfd, 0x27, 0x1f,
+        0x04, 0x02, 0xf8, 0x04, 0xc3, 0x3d, 0x3f, 0x66, },
+};
+
+int mbedtls_sm4_self_test(int verbose)
+{
+    int ret = 0, i, j, k, u, v;
+    mbedtls_sm4_context ctx;
+    unsigned char buf[16];
+    unsigned char key[16];
+    const unsigned char *srctext = NULL, *desttext = NULL;
+
+    memcpy(key, sm4_test_key, 16);
+    mbedtls_sm4_init(&ctx);
+    for (i = 0; i < 4; i++) {
+        u = i >> 1;
+        v = i  & 1;
+
+        k = 1;
+        if (u == 1) {
+            k = 1000000;
+        }
+        if (v == MBEDTLS_SM4_DECRYPT) {
+            srctext = sm4_test_ecb_enc[u];
+            desttext = sm4_test_buf;
+            mbedtls_sm4_setkey_dec(&ctx, key);
+        }
+        else {
+            srctext = sm4_test_buf;
+            desttext = sm4_test_ecb_enc[u];
+            mbedtls_sm4_setkey_enc(&ctx, key);
+        }
+        if (verbose) {
+            mbedtls_printf("  SM4-ECB #%d (%s):", k,
+                    (v == MBEDTLS_SM4_DECRYPT) ? "dec" : "enc");
+        }
+
+        memcpy(buf, srctext, 16);
+        for (j = 0; j < k; j++) {
+            mbedtls_sm4_crypt_ecb(&ctx, v, buf, buf);
+        }
+        if (memcmp(buf, desttext, 16)) {
+            if (verbose) {
+                mbedtls_printf("failed\n");
+            }
+            ret = 1;
+            goto exit;
+        }
+        if (verbose != 0) {
+            mbedtls_printf("passed\n");
+        }
+    }
+    if (verbose != 0) {
+        mbedtls_printf("\n");
+    }
+
+    ret = 0;
+exit:
+    mbedtls_sm4_free(&ctx);
+
+    return (ret);
+}
+#endif /* MBEDTLS_SELF_TEST */
+
+#endif /* MBEDTLS_SM4_C */
diff --git a/programs/test/benchmark.c b/programs/test/benchmark.c
index a6d83e75..b9132134 100644
--- a/programs/test/benchmark.c
+++ b/programs/test/benchmark.c
@@ -46,6 +46,7 @@ int main( void )
 #include "mbedtls/sha1.h"
 #include "mbedtls/sha256.h"
 #include "mbedtls/sha512.h"
+#include "mbedtls/sm3.h"
 
 #include "mbedtls/des.h"
 #include "mbedtls/aes.h"
@@ -518,7 +519,7 @@ unsigned char buf[BUFSIZE];
 
 typedef struct {
     char md5, ripemd160, sha1, sha256, sha512,
-         des3, des,
+         des3, des,sm3,
          aes_cbc, aes_gcm, aes_ccm, aes_xts, chachapoly,
          aes_cmac, des3_cmac,
          aria, camellia, chacha20,
diff --git a/scripts/generate_errors.pl b/scripts/generate_errors.pl
index 0a03f02e..d333f659 100755
--- a/scripts/generate_errors.pl
+++ b/scripts/generate_errors.pl
@@ -47,7 +47,7 @@ my $error_format_file = $data_dir.'/error.fmt';
 
 my @low_level_modules = qw( AES ARIA ASN1 BASE64 BIGNUM
                             CAMELLIA CCM CHACHA20 CHACHAPOLY CMAC CTR_DRBG DES
-                            ENTROPY ERROR GCM HKDF HMAC_DRBG MD5
+                            ENTROPY ERROR GCM HKDF HMAC_DRBG LMS LMOTS MD5
                             NET OID PADLOCK PBKDF2 PLATFORM POLY1305 RIPEMD160
                             SHA1 SHA256 SHA512 THREADING );
 my @high_level_modules = qw( CIPHER DHM ECP MD
diff --git a/tests/suites/test_suite_lmots.data b/tests/suites/test_suite_lmots.data
new file mode 100644
index 00000000..ed192bf7
--- /dev/null
+++ b/tests/suites/test_suite_lmots.data
@@ -0,0 +1,29 @@
+LMOTS sign-verify test #1
+lmots_sign_verify_test:"c41ba177a0ca1ec31dfb2e145237e65b"
+
+LMOTS sign-verify test #2
+lmots_sign_verify_test:"55a6647a581004306792b653a561d9f3"
+
+LMOTS hash-sigs interop test #1
+lmots_verify_test:"C80B24A82D52963AB241C84DCF0EEE55BB24F9F0":"00000004DB3B6B24FD191CE8894AE3C4E2CE2DE0C3F5D508691A9162F37704E07838488466CCD746E55BC8E3055C7A4D4DA2E10775DAFA2E8E5FEFB1CEB25973BC3323B61DE5E2EA7DCFF15DA482320F958023CA2E718C69B977019E8F2FCD47151388E2E5E11170AFE93BDEB508362B3A317835A9DDEB18F0CDCCC0731902DB3D37F441C93A490DE53962A915AB5060A1C157D61DDF061F272362AB7FD9EE95AE48D3448F204C81A3F260792784E1BFB49871A27C09CC549A406520F0B40BC74CAAD082EAAB12C994B8495B8C80E96384FF2222255BE6C4EE5AF439534E616F9C0B53E951F69D59BD0506C0C0366A679A8329ACF6E2D1D4E4EF49D35375A8EA46FCF3C9B2F8E033C242EC61B796E43B901407077A2AF3F0AABD2D0CB9004F10D91B57C2D5E8BA7BA9268FF94962CC102F55B5120D7D2F7A3BE281BA01D78895ADA2F05B77967EDA0E1EDEAFBB9BBC3D68DCBF682FBC70467FA2BEE5DE65F54247C4BE5BEF41F5108B6CD09E7698E3AAEA04B60746EDD0E2623B66B092DDA21EFA5A0D36805D101D805CC06F0E818B46059B3984C8B8A526C4239F66ED34B8CA57E178DC5E7B8D2BE029114B4CE466E2B5A081729B3F3A3F3845DDE177062F201C09125ED3CC381AF35EAD795440C421A136F941F09F3E4BA9E0203CBA875AF477AB0246342700F323E65DC327D27966377D871FD9C58BEC8797DEF35E1D0751A554719828B87332F601884EBFECB63A8D4F390785B3826BFA384BE502D2322C919ABD12A486C2AB124DCB7B74DE91241A30EF0388411E52145A88971C6C0A4E7C4F23EDD8D6008065A3D108C6B1EC5219BB0DFDBD37EE3A7A8DD37E3563A5777838FCA61E9E744813F39CF70B5A0F50E1BD4FF8733A3BDA76D2135969809D91A9786F22DC2ACBA4E0164C411019EC77A0BD253A42AC7528FC7C0DA1711FBD6C23825207060463080F9E04B7D819C8B150C22B8BA87C6277696EC409369C48AC0E3233DE52D31EF6D2207D2B57DFC2D0C43BE8212EAE6CB1BACBC2D3568E5527A14065D5F1F56AAE2AFB5FB1CEFFC228A30692BD030C71F4872DB54F2632CD919DA61576CF58D1EBE3D7988183A9C789EB74A3D7F6BBEBAC035A43397BF684C9E1130B252940DBA4454311A6A3D54D9386D48E1D5A3E70944EDF725AEDC5440CD610F79AB05A43C917FFC15213295EB8CB8432B6554A47C2AD419ADD52E0F5E0BD7A1E0F873257E69F8647F3A07093387B7A64C4812CDBEE536E45D531F89653AC5F14A4715CFF40692346FE6CBF2F9B92D9F1101C379AFD5E6154605059C1DA463B407E79C139396623DC7F15EEFCE424C8E214C6A645EF002F90A230D8F62177CBCF2A688D4F822B119835AD3D3A619F46230257A5AD59CB0924B2584DBA96AADE0A2487E7409EE5993A4F0E3DC46C10B96595CDD17D72C35EF4A52C5906655B0AE649B5DE03B7D46F3839E808761EE05E9300050647593C048669A952324B0188ED225AD11BED3FD94E44E134FB9D6DAD53CC34ECF62695E30637C4528C450D62174E2F8ABA2C09F134412EF889C24B36224BE4259B363A9D8EB89BAEE16BE1898D46":"000000048440BBD3F47A167DD2D0E446DBCEA774000000138686E25BC07C69B43A2D3B7165DFF85C134177C876EA47D96FEF069BC96A981A":0
+
+LMOTS hash-sigs interop test #2
+lmots_verify_test:"85A77D026E8C704B14EF665DEB0A648350FA8859":"00000004BEEF900CA9A14982E011A5A94503D566288932AD4B9CB85D1551C766A56F788B0D223FBA0E1AD722BE48365B4CE5DA21051B3A79EAD8C1046944192EE51E162DE1E9AE9B13DD8FA90867A17666CB8967F7CD7F4F5383703CCFF555EEBDC8123AF3C4E39D0A5D61725B6A7F23CE587D256C08D31510BCD895106CD524B432A9211CDCBDF5ADDAD5F1D76D428A76DF2556FFA8AB546CFAAA7F2FE86164B976FDA2940498DB0D1A2DE29972FFD55D83E7CA3318DBAC31670565A1E5F59E36342F887E0EF7855AD93CA5F1951307D79EEA375168BC35A3A0B053AEBDB4D7157AD929B0D7DE9FC1E8C32C9A2D679843CBC77560EEDA5959D0AC8407648344C6952649A303E7B6FCC2EE979E1B2786B898A01E2918894DB4E37A0ED79A30260A45959B4BB3016F081181190CB740376389827B2D56DF7EC00871DC9A198B74C7C6086C940A845D54198F2D5DD7A47F97A192F33A85AAA1304A3251B82AC33C5E7B3BA20D2A9BD49BBEE0B2DA2338E578E6F139BB7596DC3BD89E86CB393C42765B9FE85457116906C3F9A8499CF5E539A5CCB3F6D1F36CA209DE6942F807E579AF0EBF072EA110A812C9E420647CE7C8B2BDBB5F56C5B3B7EA80A53C3574F4ED32E4708DFEED60280ABBE2021B3791B0CB09C1F0731353234A6A327CDDFD4E3E2D9DD5A16FCDE3EEF09C67065BD702C07B53A005D3FE7D23FFD77D40E49C82165EB104343A166E808A3CAEDE1A43AE3A82E1788B49C565CF88A2AB8E2FD37657D53E3679D7A818D864F55144011AB498A4A985C46342F3562FD80ECB86497C3DBB759006E5FFFDC01CAA15C69B716174EDCB6E9870CF391003D3826451D1BEFDCC84C093428EE01DAF883190F5D2542B36A7DE44A453AECD5E93B768ACEE75076BE3D73A66F17CFD8E4A49B1F61CE9446815A86FF5FB0EA070A751893C85360C038A161D3DD4D2C66F440E7265153AB346EF620156605C028DD9636FAE0C9A20DF09303ECC5E57A6424505530F70D25F1C95FE51CBD82C2AD0015EB9AD5379CEC463FA0331A14DD971B7C2311FC45979C531653E7252884BAB7C49F8CD652BDF6FDFA76984445C63B54ED22B4A8A267D091381BE7B9B7608133968BA46106BF42B9091F78C085E674D1F70FB91C68D07733F6412B1583DD2F37C6ECAD6BCCE1A1C7D0A7CA80677F679A5AFE08D15427E5C78CE6EB9AA90F51F40343DC9FD1316DCEB2C1EF8EA217B714B0DE1AEECE04D19D0D7757481EDA6E8C51BE85B7B24720E8D62B8AEC56C1A1B9D278B874AACC0B492CF44ED4E7B1200C82323C1AFA0FC776E92B227E8979E3A92EAB05FCF18A43AE648397088F4991F73ECE22C03B3F42F51C0C0FE0DF37919D048FB473F7AB0E33310B9782DE56384BD888CE5E2A644E20A52DD47F710DB0D3169991E29E716ABFD84CA4850080B6C252CB96CD8979189819E532DF56ECB172F773919733BF4D442901EBFB656EBFED4C6D83FAFF288279779499091C94432ECDF83188048AB596D65BC48FA708D485F9CDC50C8B470DFE22157E8F5EE366722A04E8CE7B861573E5FC97D34055BB50B562738F803B202F7F8":"00000004DE9CE10EA7125AC6399B6B3C7EE24224000000161D61E675F3EA19C5B95DA4EE2E35BA061B39E7639F3989F8AE4B0696B3F87E4E":0
+
+LMOTS hash-sigs interop test #3
+lmots_verify_test:"C32F83EFBFD87F386A6C0850CBB93A75F2506A35":"00000004BD2D174BEBEEF1CAF06E4BF1088DE2AAB17C0528579BD4E1C4A1ED583C36BDACA49798373961B605EAEFAEFC0B4BC39C7AD30572CD29BEBE9AEE503CA2D8BF8C31C8A1B71CF67A18EE01A8A878699F22A1AEE32731E51E3EAD3775EFD8339E263C5A4544559506BA5502B9AEF59217ABC24923EC5E28D18BA18B0D964DB277007A76B8075B39F48CDA92148C9BAE1C7E5421CA753FA2D6BEAE8F49977E4E5B6F38D35BA28A526A53061E57BB92DA0EBBD4AE01AE9FADBED74F503DC39FA2E10C20B47DFB3DFBE25EC35618D2307D21716B10F8FB5095B42C289D1847E5D6F9988C6763D288667D3B658A4F3613E084DAE8B78E0B295A6ED28E88C676995AA5EB1533CDF8EB6F95A5E5117F06B1759495A9CB6E40FBF1F97FF73FDCBFD315C48DA631AB0425CA0633817C46F25E84AEEA37DD77310EE56815E83F862EF14E15FC1246243AA02F40EA32567237D5ADC2944BD63CF55FA4F0DE251B3F5C067D9EC396D5E20F9CEF2C555D89DA721D91D6D607653B97636AB10B74F39FA984D23A3D276EFF5F49C336274A66AC491EDE34686C6CFC17F5312FD3E3E5749A2E472011FA391A5ACF09D918B01704B447FD5E3EA6BB726A3475775DFE6A98CE5473CDEDB630EA4D604BAF36A8B8A8E567F05929E8A74970AA742FBC945021017E464E753D5AC497925AA4AECA0CBF562B2E39F891E177FD8E4E61A698B099D21F13EFD0DE5357A1970314D8E3AA1D2A84D3BCF75A7876C16F585322CC4C613FE3AC8FEA5F258FC9C7200765E9209378C362AFC1A478A117D913CE2BEFEB51103E48D0802618C50918005F1AA4228B67BA1A1B001A91A032019A135B8AEEE3D0158A602C8DCCE5A6580DECC16204E410CBB15FCF36704BB2ECB826A229E45C454B4A5DFC12796E636B300C624DB4E6EAB424B17A18A5A5F52399F247A1507A5985D06F90889FE381129148AF8447B392D4EC0775D91502B48D9F212FCE3F81639901C462F752E27FBEEC9E2B7F8CCD16053FB839E8ADF8CD3E8FF8AF3B3E884F4F524C2026BD3B337B7058B53CFC7596F9C813FFD746B8AC0012C60E96140934B4EED1D8602E57A1A6EBC01FCFD66053AF9614FAF0D0F7320D50D440F2A3148A0DAEF5E2FA31F854D56045065AFAA52A60DC3321E2D7C104FF505057D55CD94C53C31C14DB0DAA4D55C4065CD9BCD78E1B8532A680F7DC3544021346CC59ADEC061DDA1B7606BAF28AD87C39AB8AF3D03E981EFFE50B4D5347175517EF212E61F02B594A96492091AC82625D334504EF19BEEE52E01B111D43313F35EC69C88EF38926071506AB3A5B372DD6F2B901AC1E12E61CCB3ACD3D0777A7A10F137126DAD0D1970D369A067C3A1F19D9CB8756D7130B7EB0C08CF725EB2ADFAD61204195CE14F3C99A88A9B8FA2FDCBD612DF9266614DEA073C9EDABE07B3793048167D4DA49B305AE27974D48A296871350DE036CAA348D2F9A9CB19DC094E5904E25DDCF5657227DCD2A4E620121FBDA032A58836EDC14F3A7C4E51319A60F91F941CC61757498B769799394574C9D198426AC3499F0D0BA1770AD6BAA0D3716333F785A9D7D":"00000004DA66203A7E7BCA2362DB3C8E897A84B10000000D1BD4EE08FAA341C2CE018BD12776E1B8E6B8B2C1EEDAE6BD0998E52F089936FE":0
+
+LMOTS hash-sigs interop negative test (altered random value)
+lmots_verify_test:"C80B24A82D52963AB241C84DCF0EEE55BB24F9F0":"00000004CB3B6B24FD191CE8894AE3C4E2CE2DE0C3F5D508691A9162F37704E07838488466CCD746E55BC8E3055C7A4D4DA2E10775DAFA2E8E5FEFB1CEB25973BC3323B61DE5E2EA7DCFF15DA482320F958023CA2E718C69B977019E8F2FCD47151388E2E5E11170AFE93BDEB508362B3A317835A9DDEB18F0CDCCC0731902DB3D37F441C93A490DE53962A915AB5060A1C157D61DDF061F272362AB7FD9EE95AE48D3448F204C81A3F260792784E1BFB49871A27C09CC549A406520F0B40BC74CAAD082EAAB12C994B8495B8C80E96384FF2222255BE6C4EE5AF439534E616F9C0B53E951F69D59BD0506C0C0366A679A8329ACF6E2D1D4E4EF49D35375A8EA46FCF3C9B2F8E033C242EC61B796E43B901407077A2AF3F0AABD2D0CB9004F10D91B57C2D5E8BA7BA9268FF94962CC102F55B5120D7D2F7A3BE281BA01D78895ADA2F05B77967EDA0E1EDEAFBB9BBC3D68DCBF682FBC70467FA2BEE5DE65F54247C4BE5BEF41F5108B6CD09E7698E3AAEA04B60746EDD0E2623B66B092DDA21EFA5A0D36805D101D805CC06F0E818B46059B3984C8B8A526C4239F66ED34B8CA57E178DC5E7B8D2BE029114B4CE466E2B5A081729B3F3A3F3845DDE177062F201C09125ED3CC381AF35EAD795440C421A136F941F09F3E4BA9E0203CBA875AF477AB0246342700F323E65DC327D27966377D871FD9C58BEC8797DEF35E1D0751A554719828B87332F601884EBFECB63A8D4F390785B3826BFA384BE502D2322C919ABD12A486C2AB124DCB7B74DE91241A30EF0388411E52145A88971C6C0A4E7C4F23EDD8D6008065A3D108C6B1EC5219BB0DFDBD37EE3A7A8DD37E3563A5777838FCA61E9E744813F39CF70B5A0F50E1BD4FF8733A3BDA76D2135969809D91A9786F22DC2ACBA4E0164C411019EC77A0BD253A42AC7528FC7C0DA1711FBD6C23825207060463080F9E04B7D819C8B150C22B8BA87C6277696EC409369C48AC0E3233DE52D31EF6D2207D2B57DFC2D0C43BE8212EAE6CB1BACBC2D3568E5527A14065D5F1F56AAE2AFB5FB1CEFFC228A30692BD030C71F4872DB54F2632CD919DA61576CF58D1EBE3D7988183A9C789EB74A3D7F6BBEBAC035A43397BF684C9E1130B252940DBA4454311A6A3D54D9386D48E1D5A3E70944EDF725AEDC5440CD610F79AB05A43C917FFC15213295EB8CB8432B6554A47C2AD419ADD52E0F5E0BD7A1E0F873257E69F8647F3A07093387B7A64C4812CDBEE536E45D531F89653AC5F14A4715CFF40692346FE6CBF2F9B92D9F1101C379AFD5E6154605059C1DA463B407E79C139396623DC7F15EEFCE424C8E214C6A645EF002F90A230D8F62177CBCF2A688D4F822B119835AD3D3A619F46230257A5AD59CB0924B2584DBA96AADE0A2487E7409EE5993A4F0E3DC46C10B96595CDD17D72C35EF4A52C5906655B0AE649B5DE03B7D46F3839E808761EE05E9300050647593C048669A952324B0188ED225AD11BED3FD94E44E134FB9D6DAD53CC34ECF62695E30637C4528C450D62174E2F8ABA2C09F134412EF889C24B36224BE4259B363A9D8EB89BAEE16BE1898D46":"000000048440BBD3F47A167DD2D0E446DBCEA774000000138686E25BC07C69B43A2D3B7165DFF85C134177C876EA47D96FEF069BC96A981A":MBEDTLS_ERR_LMOTS_VERIFY_FAILED
+
+LMOTS negative test (invalid type) #1
+lmots_verify_test:"0000000000000000000000000000000000000000":"0000000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":"0000000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA
+
+LMOTS negative test (invalid type) #2
+lmots_verify_test:"0000000000000000000000000000000000000000":"0000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":"0000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":MBEDTLS_ERR_LMOTS_BAD_INPUT_DATA
+
+LMOTS key import / export test
+lmots_import_export_test:"000000048440BBD3F47A167DD2D0E446DBCEA774000000138686E25BC07C69B43A2D3B7165DFF85C134177C876EA47D96FEF069BC96A981A"
+
+LMOTS key reuse test
+lmots_reuse_test:"cfcd1e81193e310c9d931d1b00818d14"
diff --git a/tests/suites/test_suite_lmots.function b/tests/suites/test_suite_lmots.function
new file mode 100644
index 00000000..6de94d12
--- /dev/null
+++ b/tests/suites/test_suite_lmots.function
@@ -0,0 +1,108 @@
+/* BEGIN_HEADER */
+#include "mbedtls/lmots.h"
+#include "mbedtls/entropy.h"
+#include "mbedtls/ctr_drbg.h"
+
+/* END_HEADER */
+
+/* BEGIN_DEPENDENCIES
+ * depends_on:MBEDTLS_LMOTS_C:MBEDTLS_SHA256_C:MBEDTLS_CTR_DRBG_C
+ * END_DEPENDENCIES
+ */
+
+/* BEGIN_CASE */
+void lmots_sign_verify_test ( data_t * msg )
+{
+    mbedtls_lmots_context ctx;
+    unsigned char sig[MBEDTLS_LMOTS_SIG_LEN];
+    mbedtls_entropy_context entropy_ctx;
+    mbedtls_ctr_drbg_context drbg_ctx;
+    uint8_t seed[16];
+
+    mbedtls_entropy_init( &entropy_ctx );
+    mbedtls_ctr_drbg_init( &drbg_ctx );
+    mbedtls_lmots_init( &ctx );
+
+    TEST_ASSERT( mbedtls_ctr_drbg_seed( &drbg_ctx, mbedtls_entropy_func,
+                 &entropy_ctx, (uint8_t*)"", 0 ) == 0 );
+    TEST_ASSERT( mbedtls_ctr_drbg_random( &drbg_ctx, seed, sizeof( seed ) ) == 0 );
+
+    TEST_ASSERT( mbedtls_lmots_set_algorithm_type(&ctx, MBEDTLS_LMOTS_SHA256_N32_W8) == 0 );
+    TEST_ASSERT( mbedtls_lmots_gen_privkey(&ctx, (uint8_t[16]){0}, 0x12, seed, sizeof( seed ) ) == 0 );
+    TEST_ASSERT( mbedtls_lmots_gen_pubkey(&ctx) == 0 );
+    TEST_ASSERT( mbedtls_lmots_sign(&ctx, mbedtls_ctr_drbg_random, &drbg_ctx, msg->x, msg->len, sig ) == 0 );
+    TEST_ASSERT( mbedtls_lmots_verify(&ctx, msg->x, msg->len, sig) == 0 );
+
+exit:
+    mbedtls_entropy_free( &entropy_ctx );
+    mbedtls_ctr_drbg_free( &drbg_ctx );
+    mbedtls_lmots_free( &ctx );
+}
+/* END_CASE */
+
+/* BEGIN_CASE */
+void lmots_verify_test ( data_t * msg, data_t * sig, data_t * pub_key,
+                          int expected_rc )
+{
+    mbedtls_lmots_context ctx;
+
+    mbedtls_lmots_init( &ctx );
+
+    mbedtls_lmots_import_pubkey( &ctx, pub_key->x );
+
+    TEST_ASSERT(mbedtls_lmots_verify( &ctx, msg->x, msg->len, sig->x ) == expected_rc );
+
+exit:
+    mbedtls_lmots_free( &ctx );
+}
+/* END_CASE */
+
+/* BEGIN_CASE */
+void lmots_import_export_test (  data_t * pub_key )
+{
+    mbedtls_lmots_context ctx;
+    uint8_t exported_pub_key[MBEDTLS_LMOTS_PUBKEY_LEN];
+
+    mbedtls_lmots_init( &ctx );
+    TEST_ASSERT( mbedtls_lmots_import_pubkey( &ctx, pub_key->x ) == 0 );
+    TEST_ASSERT( mbedtls_lmots_export_pubkey( &ctx, exported_pub_key ) == 0 );
+
+    TEST_ASSERT( memcmp( pub_key->x, exported_pub_key, MBEDTLS_LMOTS_PUBKEY_LEN ) == 0 );
+
+exit:
+    mbedtls_lmots_free( &ctx );
+}
+/* END_CASE */
+
+/* BEGIN_CASE */
+void lmots_reuse_test ( data_t * msg )
+{
+    mbedtls_lmots_context ctx;
+    unsigned char sig[MBEDTLS_LMOTS_SIG_LEN];
+    mbedtls_entropy_context entropy_ctx;
+    mbedtls_ctr_drbg_context drbg_ctx;
+    uint8_t seed[16];
+
+    mbedtls_entropy_init( &entropy_ctx );
+    mbedtls_ctr_drbg_init( &drbg_ctx );
+    TEST_ASSERT( mbedtls_ctr_drbg_seed(&drbg_ctx, mbedtls_entropy_func,
+                 &entropy_ctx, (uint8_t*)"", 0 ) == 0 );
+
+    mbedtls_ctr_drbg_random( &drbg_ctx, seed, sizeof( seed ) );
+
+    mbedtls_lmots_init( &ctx );
+    TEST_ASSERT( mbedtls_lmots_set_algorithm_type( &ctx, MBEDTLS_LMOTS_SHA256_N32_W8 ) == 0 );
+    TEST_ASSERT( mbedtls_lmots_gen_privkey(&ctx, (uint8_t[16]){0}, 0x12, seed, sizeof( seed ) ) == 0 );
+    TEST_ASSERT( mbedtls_lmots_sign(&ctx, mbedtls_ctr_drbg_random, &drbg_ctx, msg->x, msg->len, sig ) == 0 );
+
+    /* Running another sign operation should fail, since the key should now have
+     * been erased.
+     */
+    TEST_ASSERT( mbedtls_lmots_sign(&ctx, mbedtls_ctr_drbg_random, &drbg_ctx, msg->x, msg->len, sig ) != 0 );
+
+exit:
+    mbedtls_entropy_free( &entropy_ctx );
+    mbedtls_ctr_drbg_free( &drbg_ctx );
+    mbedtls_lmots_free( &ctx );
+}
+/* END_CASE */
diff --git a/tests/suites/test_suite_lms.data b/tests/suites/test_suite_lms.data
new file mode 100644
index 00000000..b17fddc1
--- /dev/null
+++ b/tests/suites/test_suite_lms.data
@@ -0,0 +1,32 @@
+LMS sign-verify test
+lms_sign_verify_test:"c41ba177a0ca1ec31dfb2e145237e65b"
+
+LMS hash-sigs interop test #1
+lms_verify_test:"D5557C719EBB0DBECF563E5CDB16568BB11CD779":"0000000000000004C167A9AC495BD4EA34CD8EE5AAA2A656D518C33612FD87171421BFC3977CFA99765C6D496499C72A1DE21360DA57EB96BC83DB8AA92E560054C7805B04E336162FB4C411B509F76959F2458B0E53CF830E0145CCD439D494259EA4818CA68924A7E8B9DD36D6A9C7849B72F9338ED6C80A3E70B717E8E65B991B2FF9D8B49820E8ABC9E2ECC17DB38E855DA75D84DF9885C7F9DFB4ABC209CFF1D37D66595371D688A203CB89168945200C39169F784B19665CE1FB47D58BFA734C3E0E7E31D1206A033C6D8E25B7E45CA779A5FDE00C6B1CAC44884F2B52A380E1F6D8753549F7F4948A95AEA83703CF3AA108FA4F735AFC0DA1A03C378033D8B5959E7BE05D3C5070E709181AC09EFEC04128ABD7E8F37304FAD4B66373D4A83CFC1EF632DF6DB95577C2C6101CBDC807109ED8AE831FFB73DBC80942C58F334663B980F982C74B943BF7C57147250AADE595310387E3BB1A2705E9EC73DE7FABDA5EC0B1141A18798215B9A70F8D688357C833ED869059A2AA3360155EF84426288198D0FBB78223816B17093684C48942ED18FCD351C34E108E5B71D1CE39E318B5D991B650C46A91112E013E1180F2054C7A22429CAB31512BA34EA3AD9B68C5001EB70C993297CCF11914ECAF059922DAEE7D90ACE2567495ADA066E7DA1679CA45DAC1990B17184E7BE2E6A0F26AD77F19855D074F5B37372277484CE30B80A0540173C1B310C3E7B683A487B5D0676218EA1F65FEA444C493FC535E948EAB62252DCC90516BB45B60D4253DB6979FE342DC5CA1B86B01B2D8EBA79B0BC7B6984535616B792BB45F3C0E20B506E0694E1D5BA28FE96D34FE2BE354777D090404DD3508E9F7918FF5593ADB468478CA8A1F6AF752CC76F401E373B71471D9D70F455C8A73E4E7B6714394B1DD0E2A816AF3D5149835DAE477A70DEE0BDAC22F99A04BFB7C2D4AD53079C326F620DFD3F7CED4AB7F2E291507AA046331050F9E2205C52B36CBAEE817C5C3B1FBCDE61C54C8CB7B67E0570FA44728EC8FD091D5CEDC19C6B99840F7A0E49086F707E959D34B30E255B67BBAA24FADE532BF3D21825626E114BD8213170B0C2F01733D4ED420D01EE3ACD5F84DACE674AE7127DB0A80ACE252CAD9ADADDAFAB27281AFD6DDD72DB5AF878326C45D7DB1EFF8BC40895A3473A52461D076881310AD9937307217B5C0448B509EF9BA075936CC09E11B8838D3A6BC5EF9FAEA85A3EC87EEFDF2E38CD9732730085375A4FFC4E0A213B0E1FC3DE2D37F1EDACC3030F617F3459A03BFCF776A05FD3B7FD135782F6D6E7C5E92B56A1316525B26D3AE1CEA3C0C7CF3AA7B1E72B7599A31B50837D79A7AB61B9A9E2B7AABD2D605C97E302EB4B66C0588C24147955EA0892A54D42843568FE0863E7EFEAE336D302E672EA62689B4DAA02DD5BC99D93886EC7F411C53CE1CAEAB59FBC0B06E0E294F1900F8C626C6FF520AE2323DA797CDC120DBC19F7FEBA0E13429508C5B838A0F8B9B28A069C5DD40E2F6CC2C95FC6ACE7E1351516817BD2DC1AE08D498AD2B0BD1D8374942FF31FC6A4689C592244C919C3561E73DD4986FA500000006BBF34F6EE152B64FCDD1CB6848D2DA761798707060431761006E2EBD9312851F4F3DF3C46E10F643DDD58CB3D9F4D371F655EE26271F2DDE84A14CAA6A077DD96AF83849DE6CA8F2F3248902CBF49630C18C3EE3123D951CE9162D0E742B899AF9E5DA8D28A41C7CADF0194CDB09418BF48BF322F8C5E9563524196FA8AB785B43C4EA41A36148028D2F4C7356CDEEB09532CD7F2C80FC36589FF7A9954100C8697AEB014997C3088C242B4F70D26CE7F7E77384A9CF536EC5C5329E08BD6C1D65EFEFC1389A42D16FFB43A0E1D7661220E92A4A59703FB28410E73A677E803D4441929DFD7269E6F77AE8CA8C70B67B250A8728291EA5D4E3F03D505639408C88156DCBECC137142FA3585C09D99B84D8C380A5D29CE2ADA10A25F7CF939FE23288551F37FE2B7233BF97C0F5726B972E087BCBA095957CCD794794A4F50027":"00000006000000046B0927585C8547228D495361D73B970C287A2254BF8F1B170E55ACC9520A56CE5D2C711B6617718B49247D28CCC6D11D":0
+
+LMS hash-sigs interop test #2
+lms_verify_test:"DA16BE0B8FB691248486ACAFD531BE6EE4C362E0":"000000000000000484FCD0D791D175A0F86D64B2E8949F793CA9FFDC0347DE125DDB2F895BB9D2B43740B9B326B24F934D67586812BE6F3FB57E76FB12FBAD60A685F22A82C95C84AFAE63F47BB3CD951D483F61F5626B2B5FB6FDCA0CF02293EFDE1EB0AF6712D635678E825099E95435B43EF83C49C6589054D0905D82D597FB11A721D2232AD168FD179724539699C21163D5ADEB52290CB711C368572FF8BB95AA61DF2AD128307E768E73D3CF2BAFEAC8B6CD165BDD0316D2663D1ED61A15FB974082FC66A55E13ABA4FD084970EF6A59B0DFA1E934BF0E056C86E9B4C5B94CF863AB9F23BE2DB6A140A9CAA8DB31C83B21BDBDCD07304A52EB8501869D86BFDB68A376D94F847EED7E4CAB6A6EEC063945AE4DAF657D5509249E7FE430F5A13B188C4DD311F01746CE28F4F6540041EF6ADB299F712F591C83B0C12C1FB3E4A878C63217E25E08C004571FFC69E9C684E46F4D36C36409EBF3EB15F32A187176F4D177E0FE0E71ADFD4DA4AD2D57A0256B29AD5DAA6867AED20CC862AF5729D030514D41BB8D74551D8E925322C81A357A586227BBC885AB683BF835E9333A056AFEE96F2AD0FF6D6E235A9E2BC342ACBCF0B8EACC95E7B74215F6C65F12829433301F004EE1D9CFD16A4A1D092F48E99AEAE9E1FA4619ECE5E05F5C19F33C4C94A774EB8955409E3CFA73D8807CAA7C55FE45E980C7E7626AAA193F18A3AA7E525FFA6466D728FA25563DD383D855A0B6F8C011AC8C79C853CBED3A016DC26EF6E90B3E78119E465B9962A42B6AC168C1CDC9DB860D740B0C797303E2A62445FA618B5EB417BD4385C15BC548FEDF4D4842CA43F95188FFF63EB5D4AC85DAE618FDFB6CF5969EA0A3A52F73A4AC4957BC4EBCFEF593923EC79196021B25ED8D7558E4AF41ED74941585AC575CF1971D4F4C7C9E9516276734FF9FAFC7DE661F3090F71C98962789B31EA0FE406E2EF02F6F16B1708258C7559B8E05E27D647AD472805C865299FE30A5FE451DA7F2C493A37AA1655D492EC891B9AF559E12104CDD2EEB2E54138A1FB5A403AA32CEEB3946471A299604FA2DD3CA3E9567D01A3CEE5D09A1C2768B521C0C6142AF297CA5BFB3878B32D37D415542C15F655CB051240F3BA8FCE0E38449A0D7010A9B56BA2283E3A2047215813ED2090F7BDF16A40ADE32AB4E669684E6DEB6A94633E6643F29D10914F5A361C964CA9145514D4B80B45F3276EB0C649622034E71925FA038EB35E64C71CBDB11E91D779339516A351BD2A722CB60C2CBF145689B2E3F6FAEB74C3B58283929F70023503A96FED6A5D7D8A9E495FE1D85E0FCEC555F86747347D2FB5219FF65EFD144A5E1E88C63BE4259C42F6899C103536D75E0526508649E2836CACB94E88BD954B88EAC26F17B27BF62546C5C7573E2BC9EF4B65B8AE4951AF532F968FF050E504CC236DC48379E4390079DE451DCE710F9674D753C85B9FF7E7B09ED051EDD14C33AAFC8A188AE06234DFB61FE5A75C7A760B5286E1D6993BCEA0AB8A2C1D632145BD6A9F109ABB04E0B102D50DCB8C607AD6BA8C5FA5B21663E5A40194CA5DC2294BE10044E8D96AA0000000694ABC63BC5B27730C5223943C8341461474033BE3A221AFFDE66242AF14510CC656480CBDFC0B35205C89258A18BF6C29C4708CB2572DE15EE5DD481BC47060254954B5C5DD881AE6B358F7CDAB6F117235AAAC625B2750DB72BA4A96D7DFAA889BE780416E1CB264A413C6713710102D1D433BC6D0A47BF08AA74FD613D292A867261181BBD73557EE3AEB0F63579B71E58E97BAC1AACA3F34646350A13BB7ACE0AB3B062C41518768ABF3D32FB2F6A5E5C7F6B8B04C943D25A82F03F977755D74FD717A4B7E7674B03B577405210E23A2FE050E036DB0730359366A9436AD2CBCCE3E649F9E40023B2C12D9F5AA824319EAF571FD4842E573BB100BE9715D7B71F75521640D9B69B889349A283D62350D3A37264C89930F40603A5458B124EA850BA59024A46A8F325C9A9776817D739692FFAEA2758249888BF79D66FD496":"00000006000000043FC8322D04908C7C06C0D8B7A0CE24FA3AC253393CF9A56CF760294A06E75223E38C9E5329DDC493D8B51B1A4BBE41F8":0
+
+LMS hash-sigs interop test #3
+lms_verify_test:"331D543362A163390508127AFB9894B8C18C6E0A":"0000000000000004F5378439E9C229550D40B725FD56BE48DB785093E62BD29B723C61FABEDCFD486EFA120445339DE2A21A8C7465073ACBFD6DE3E50F395AAC20E0BCB23B088C416199F80B540AA81B2C0B12B7785152263522E8F79AEBE3B28315CC834AEB68475CADBC724DB6B7B7F594A7F9DA2505F5F44DAA7EEF70B72665A250C1F61A19F3FA4CBF389BEB9B31DC327882D7983EEED46DA8E00AEBEF85AE179EBF6D8CC7F720E9F963C4D30DD4015DAA27993D0780AFD7A45688422B1444AD866FEFE12EBD94B4D313517708A6E652D6206A8B263E234685D8133C2258EF6CA9E9C6FFD6D153598B13B59576897DC4F77C71609427866A347AE62B5C3BACB0A2E44B60F2CCB4989B0C57F3E785CDCF22B1FC8C3460A163FF2BE7A578E82429BA823F392A13C11A5639A42453972D2185E81809EF0666F8F01F575FBD9A46135F45651AA814D9BA84F774A9E9303FD55038CA41A21484BA9C38E69BCE4E37052971690ED3EEC4ED9AD41B0AEAE4DCC913443B9FA5418FB75DC1725FA989BA8DB5D9E221804FC7F36F3135C8B93AFF66DF89408CFD50993D308E51DF00540F380C0AD06266B80F646B917BA58384B55658EAD2D453766C4843FCDD934E8352A6DF6A081A15BDE07BF67E977E72BFE1AC37F411111A0A4D101A2CCF95EBEC7FCFC82B45DBA88939B0831987AE4D15C05A2E08F713BB0B6BB0E2436B7F9C83D2D869432465DEB9185913DE215937EFB4A52DA50BEF88688F5AB4397A04B14CDBFA5BFD948CD6EA1122D9D3C2927DE9D066297AA2C6FE8E478EC0F41459287EF9B8A1A56164C72AE3DCE5E914E8BC3C3821E0ADD6D1C9048D71BD71F71F3A6E04E63687298DE5A3704ADA82AA369CCD7F342F79E988A7BE066CA55944E0E3712F472891761E5617DC048C69AA4C250AA1560D6591FC0E7492027BEED67310E3482B1487E41DEA5E070894A5FB93FF4462D1F60C4B1CA7C15275EEA2B3790ED12EA930FD7F7F07D60807E4AAB73D1F889DABF2E687A487F331AC17D8DE24E8448E672F87424F0D1A73721A1A987519D0E3BB91D15D012B1FCDB6E23EEA17E93869C5199984CE8A068CA96C3096273F8B23160A79EE0C208D9B70ED5E23CB3586DFD33E02D06F1C646250BD664C27D2BB9614FF5F043A6FEE1A235DA10DCAADB19205CB839BD616BB36B738AA28E1D4F767BD8BAB6C2F84887C7B2E16CF6E07AF90C1FCB6E6E5A4CC894072AF4393C63F7119FF694BF0A043AF5F0825557A99C40BABBDA97D5648687D493367812743335A8AD7696562538C8BA5DED182C4DC818E7E9F630B29A9534E2583E0F4B5862D4E4DB250A350BAF360EF133838FE55AA683E253746A704654EF692F4F818F5A172AB0B84673D0AF77CC1DF189AA5BB013E833D1B0943918768AC6A83E6BFB306D3C3786BD2C87129BFEA1C380A84C4983D262184427284BF3DEB9B4C58FB1899B07B9F60B4402618168B1445653E8E48CD92C048684302A6F5C217F110D6699707BA42316CB31FE8F4DA6B82243CF1264751225594AF1BB670339A9189163DB9E985A99BCF83A3039AF3E65BBCD8364745356B29D761853E00000006CDE5B63B9763DA3EABCFFDA517688BDEC2AE9213E6B0FD7003D95458798AE9449DE4F1135E093B39F597A34B14AAB7F596E25BA469533442F54C14921ABCC5D04A05486CD16C8564E6A19C11BEDA574A9800107DCEAD013A7E6A32966B5BBE9FDFDB0184FE0707209B6D9EC43066899717E487E5FDEE02061EA5069B2D6C9C87D6BEB1310F1B9E723AE372DB7BE9EF6657F51FD0DE62464D3B37755095829F625EA76F5FD7FCD5829863F963FCD7F9FFFF3729688D025DF7952B067C62198E4C6CE06E960B0BAC6ADBC9459D9AC0BE1BAD46F95A121BBBE6953BAA10252419E2AB6BCA1B0AA1FA64DF728160B4FB7A62499C24D269FF59977649064C5986D615E6952EA0DA5B1C04C443BC27A63D391D5BFAE824F0161791E65896DC100EAF80037FD800A5079337554BD990E0D0A1A4C4C45741E72FB3E840665F2881D2CCC5":"000000060000000461F2DF219685CF313043780A57C18071725490AB8D53B676D484238BA8C373572407938CC578045649964958C0A872FA":0
+
+LMS hash-sigs interop negative test (altered random value)
+lms_verify_test:"D5557C719EBB0DBECF563E5CDB16568BB11CD779":"0000000000000004B167A9AC495BD4EA34CD8EE5AAA2A656D518C33612FD87171421BFC3977CFA99765C6D496499C72A1DE21360DA57EB96BC83DB8AA92E560054C7805B04E336162FB4C411B509F76959F2458B0E53CF830E0145CCD439D494259EA4818CA68924A7E8B9DD36D6A9C7849B72F9338ED6C80A3E70B717E8E65B991B2FF9D8B49820E8ABC9E2ECC17DB38E855DA75D84DF9885C7F9DFB4ABC209CFF1D37D66595371D688A203CB89168945200C39169F784B19665CE1FB47D58BFA734C3E0E7E31D1206A033C6D8E25B7E45CA779A5FDE00C6B1CAC44884F2B52A380E1F6D8753549F7F4948A95AEA83703CF3AA108FA4F735AFC0DA1A03C378033D8B5959E7BE05D3C5070E709181AC09EFEC04128ABD7E8F37304FAD4B66373D4A83CFC1EF632DF6DB95577C2C6101CBDC807109ED8AE831FFB73DBC80942C58F334663B980F982C74B943BF7C57147250AADE595310387E3BB1A2705E9EC73DE7FABDA5EC0B1141A18798215B9A70F8D688357C833ED869059A2AA3360155EF84426288198D0FBB78223816B17093684C48942ED18FCD351C34E108E5B71D1CE39E318B5D991B650C46A91112E013E1180F2054C7A22429CAB31512BA34EA3AD9B68C5001EB70C993297CCF11914ECAF059922DAEE7D90ACE2567495ADA066E7DA1679CA45DAC1990B17184E7BE2E6A0F26AD77F19855D074F5B37372277484CE30B80A0540173C1B310C3E7B683A487B5D0676218EA1F65FEA444C493FC535E948EAB62252DCC90516BB45B60D4253DB6979FE342DC5CA1B86B01B2D8EBA79B0BC7B6984535616B792BB45F3C0E20B506E0694E1D5BA28FE96D34FE2BE354777D090404DD3508E9F7918FF5593ADB468478CA8A1F6AF752CC76F401E373B71471D9D70F455C8A73E4E7B6714394B1DD0E2A816AF3D5149835DAE477A70DEE0BDAC22F99A04BFB7C2D4AD53079C326F620DFD3F7CED4AB7F2E291507AA046331050F9E2205C52B36CBAEE817C5C3B1FBCDE61C54C8CB7B67E0570FA44728EC8FD091D5CEDC19C6B99840F7A0E49086F707E959D34B30E255B67BBAA24FADE532BF3D21825626E114BD8213170B0C2F01733D4ED420D01EE3ACD5F84DACE674AE7127DB0A80ACE252CAD9ADADDAFAB27281AFD6DDD72DB5AF878326C45D7DB1EFF8BC40895A3473A52461D076881310AD9937307217B5C0448B509EF9BA075936CC09E11B8838D3A6BC5EF9FAEA85A3EC87EEFDF2E38CD9732730085375A4FFC4E0A213B0E1FC3DE2D37F1EDACC3030F617F3459A03BFCF776A05FD3B7FD135782F6D6E7C5E92B56A1316525B26D3AE1CEA3C0C7CF3AA7B1E72B7599A31B50837D79A7AB61B9A9E2B7AABD2D605C97E302EB4B66C0588C24147955EA0892A54D42843568FE0863E7EFEAE336D302E672EA62689B4DAA02DD5BC99D93886EC7F411C53CE1CAEAB59FBC0B06E0E294F1900F8C626C6FF520AE2323DA797CDC120DBC19F7FEBA0E13429508C5B838A0F8B9B28A069C5DD40E2F6CC2C95FC6ACE7E1351516817BD2DC1AE08D498AD2B0BD1D8374942FF31FC6A4689C592244C919C3561E73DD4986FA500000006BBF34F6EE152B64FCDD1CB6848D2DA761798707060431761006E2EBD9312851F4F3DF3C46E10F643DDD58CB3D9F4D371F655EE26271F2DDE84A14CAA6A077DD96AF83849DE6CA8F2F3248902CBF49630C18C3EE3123D951CE9162D0E742B899AF9E5DA8D28A41C7CADF0194CDB09418BF48BF322F8C5E9563524196FA8AB785B43C4EA41A36148028D2F4C7356CDEEB09532CD7F2C80FC36589FF7A9954100C8697AEB014997C3088C242B4F70D26CE7F7E77384A9CF536EC5C5329E08BD6C1D65EFEFC1389A42D16FFB43A0E1D7661220E92A4A59703FB28410E73A677E803D4441929DFD7269E6F77AE8CA8C70B67B250A8728291EA5D4E3F03D505639408C88156DCBECC137142FA3585C09D99B84D8C380A5D29CE2ADA10A25F7CF939FE23288551F37FE2B7233BF97C0F5726B972E087BCBA095957CCD794794A4F50027":"00000006000000046B0927585C8547228D495361D73B970C287A2254BF8F1B170E55ACC9520A56CE5D2C711B6617718B49247D28CCC6D11D":MBEDTLS_ERR_LMS_VERIFY_FAILED
+
+LMS negative test (invalid lms type) #1
+lms_verify_test:"0000000000000000000000000000000000000000":"000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":"0000000700000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":MBEDTLS_ERR_LMS_BAD_INPUT_DATA
+
+LMS negative test (invalid lms type) #2
+lms_verify_test:"0000000000000000000000000000000000000000":"000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":"0000000500000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":MBEDTLS_ERR_LMS_BAD_INPUT_DATA
+
+LMS negative test (invalid lm_ots type) #1
+lms_verify_test:"0000000000000000000000000000000000000000":"000000000000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":"0000000600000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":MBEDTLS_ERR_LMS_BAD_INPUT_DATA
+
+LMS negative test (invalid lm_ots type) #2
+lms_verify_test:"0000000000000000000000000000000000000000":"000000000000000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":"0000000600000005000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":MBEDTLS_ERR_LMS_BAD_INPUT_DATA
+
+LMS negative test (invalid leaf ID)
+lms_verify_test:"0000000000000000000000000000000000000000":"000004000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":"0000000600000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000":MBEDTLS_ERR_LMS_VERIFY_FAILED
+
+LMS import/export test
+lms_import_export_test:"00000006000000046B0927585C8547228D495361D73B970C287A2254BF8F1B170E55ACC9520A56CE5D2C711B6617718B49247D28CCC6D11D"
diff --git a/tests/suites/test_suite_lms.function b/tests/suites/test_suite_lms.function
new file mode 100644
index 00000000..c3ebb921
--- /dev/null
+++ b/tests/suites/test_suite_lms.function
@@ -0,0 +1,84 @@
+/* BEGIN_HEADER */
+#include "mbedtls/lms.h"
+#include "mbedtls/entropy.h"
+#include "mbedtls/ctr_drbg.h"
+
+/* END_HEADER */
+
+/* BEGIN_DEPENDENCIES
+ * depends_on:MBEDTLS_LMS_C:MBEDTLS_SHA256_C:MBEDTLS_CTR_DRBG_C
+ * END_DEPENDENCIES
+ */
+
+/* BEGIN_CASE */
+void lms_sign_verify_test ( data_t * msg )
+{
+    mbedtls_lms_context ctx;
+    unsigned char sig[MBEDTLS_LMS_SIG_LEN];
+    mbedtls_entropy_context entropy_ctx;
+    mbedtls_ctr_drbg_context drbg_ctx;
+    uint8_t seed[16];
+    int rc;
+
+    mbedtls_entropy_init( &entropy_ctx );
+    mbedtls_ctr_drbg_init( &drbg_ctx );
+    mbedtls_lms_init( &ctx );
+
+    TEST_ASSERT( mbedtls_ctr_drbg_seed( &drbg_ctx, mbedtls_entropy_func,
+                 &entropy_ctx, ( uint8_t* )"", 0 ) == 0 );
+    TEST_ASSERT( mbedtls_ctr_drbg_random( &drbg_ctx, seed, sizeof( seed ) ) == 0 );
+
+    TEST_ASSERT( mbedtls_lms_set_algorithm_type( &ctx, MBEDTLS_LMS_SHA256_M32_H10, MBEDTLS_LMOTS_SHA256_N32_W8 ) == 0 );
+
+    /* Allocation failure isn't a test failure, since it likely just means there's not enough memory to run the test */
+    rc = mbedtls_lms_gen_privkey( &ctx, mbedtls_ctr_drbg_random, &drbg_ctx, seed, sizeof( seed ) );
+    TEST_ASSUME( rc != MBEDTLS_ERR_LMS_ALLOC_FAILED );
+    TEST_ASSERT( rc == 0 );
+
+    TEST_ASSERT( mbedtls_lms_gen_pubkey( &ctx) == 0 );
+
+    TEST_ASSERT( mbedtls_lms_sign( &ctx, mbedtls_ctr_drbg_random, &drbg_ctx, msg->x, msg->len, sig ) == 0 );
+
+    TEST_ASSERT( mbedtls_lms_verify( &ctx, msg->x, msg->len, sig) == 0 );
+
+exit:
+    mbedtls_entropy_free( &entropy_ctx );
+    mbedtls_ctr_drbg_free( &drbg_ctx );
+    mbedtls_lms_free( &ctx );
+}
+/* END_CASE */
+
+/* BEGIN_CASE */
+void lms_verify_test ( data_t * msg, data_t * sig, data_t * pub_key,
+                          int expected_rc )
+{
+    mbedtls_lms_context ctx;
+
+    mbedtls_lms_init( &ctx);
+
+    mbedtls_lms_import_pubkey( &ctx, pub_key->x );
+
+    TEST_ASSERT( mbedtls_lms_verify( &ctx, msg->x, msg->len, sig->x ) == expected_rc );
+
+exit:
+    mbedtls_lms_free( &ctx );
+}
+/* END_CASE */
+
+/* BEGIN_CASE */
+void lms_import_export_test (  data_t * pub_key )
+{
+    mbedtls_lms_context ctx;
+    uint8_t exported_pub_key[MBEDTLS_LMS_PUBKEY_LEN];
+
+    mbedtls_lms_init(&ctx);
+    TEST_ASSERT( mbedtls_lms_import_pubkey( &ctx, pub_key->x ) == 0 );
+    TEST_ASSERT( mbedtls_lms_export_pubkey( &ctx, exported_pub_key) == 0 );
+
+    ASSERT_COMPARE( pub_key->x, MBEDTLS_LMS_PUBKEY_LEN,
+                    exported_pub_key, MBEDTLS_LMS_PUBKEY_LEN );
+
+exit:
+    mbedtls_lms_free( &ctx );
+}
+/* END_CASE */
